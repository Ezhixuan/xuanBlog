[{"title":"Xxl-Job","path":"/post/586965a7/","content":"xxl-job XXL-JOB是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。 源码地址：xxl-job: 一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。 文档地址：分布式任务调度平台XXL-JOB (xuxueli.com) 分布式任务调度 为什么使用xxl-job xxl-job是一款分布式任务调度的开源框架 与Springboot提供的@scheduled定时任务相比 @Scheduled存在以下问题 定时任务失败无法重试 在处理集群任务时会出现重复执行的问题 cron表达式定义在代码之中，不方便修改 当任务量过大时，无法有效分片执行 使用xxl-job来解决这些问题 什么是分布式任务调度 当前软件的架构已经向分布式架构转变，将单体项目拆分成若干服务，服务之间通过网络交互来完成业务处理。在分布式架构下，一个服务往往会部署多个实例来运行业务，在这种分布式系统环境下运行任务调度，称为分布式调度 ​\t1、并行任务调度 并行任务调度实现靠多线程，如果有大量任务需要调度，此时光靠多线程就会有瓶颈了，因为一台计算机CPU的处理能力是有限的。 如果将任务调度程序分布式部署，每个结点还可以部署为集群，这样就可以让多台计算机共同去完成任务调度，我们可以将任务分割为若干个分片，由不同的实例并行执行，来提高任务调度的处理效率。 ​\t2、高可用 若某一个实例宕机，不影响其他实例来执行任务。 ​\t3、弹性扩容 当集群中增加实例就可以提高并执行任务的处理效率。 ​\t4、任务管理与监测 对系统中存在的所有定时任务进行统一的管理及监测。让开发人员及运维人员能够时刻了解任务执行情况，从而做出快速的应急处理响应。 分布式任务调度面临的问题： 当任务调度以集群方式部署，同一个任务调度可能会执行多次，例如：电商系统定期发放优惠券，就可能重复发放优惠券，对公司造成损失，信用卡还款提醒就会重复执行多次，给用户造成烦恼，所以我们需要控制相同的任务在多个运行实例上只执行一次。常见解决方案： 分布式锁，多个实例在任务执行前首先需要获取锁，如果获取失败那么就证明有其他服务已经在运行，如果获取成功那么证明没有服务在运行定时任务，那么就可以执行。 ZooKeeper选举，利用ZooKeeper对Leader实例执行定时任务，执行定时任务的时候判断自己是否是Leader，如果不是则不执行，如果是则执行业务逻辑，这样也能达到目的。 特性 简单灵活 提供Web页面对任务进行管理，管理系统支持用户管理、权限控制； 支持容器部署； 支持通过通用HTTP提供跨平台任务调度； 丰富的任务管理功能 支持页面对任务CRUD操作； 支持在页面编写脚本任务、命令行任务、Java代码任务并执行； 支持任务级联编排，父任务执行结束后触发子任务执行； 支持设置指定任务执行节点路由策略，包括轮询、随机、广播、故障转移、忙碌转移等； 支持Cron方式、任务依赖、调度中心API接口方式触发任务执行 高性能 任务调度流程全异步化设计实现，如异步调度、异步运行、异步回调等，有效对密集调度进行流量削峰； 高可用 任务调度中心、任务执行节点均 集群部署，支持动态扩展、故障转移 支持任务配置路由故障转移策略，执行器节点不可用是自动转移到其他节点执行 支持任务超时控制、失败重试配置 支持任务处理阻塞策略：调度当任务执行节点忙碌时来不及执行任务的处理策略，包括：串行、抛弃、覆盖策略 易于监控运维 支持设置任务失败邮件告警，预留接口支持短信、钉钉告警； 支持实时查看任务执行运行数据统计图表、任务进度监控数据、任务完整执行日志； 部署xxl-job 调度中心环境要求 Maven3+ Jdk1.8+ Mysql5.7+ 初始化调度数据库 请下载项目源码并解压，获取 “调度数据库初始化SQL脚本” 并执行即可。 位置：/xxl-job/doc/db/tables_xxl_job.sql 共8张表 - xxl_job_lock：任务调度锁表；- xxl_job_group：执行器信息表，维护任务执行器信息；- xxl_job_info：调度扩展信息表： 用于保存XXL-JOB调度任务的扩展信息，如任务分组、任务名、机器地址、执行器、执行入参和报警邮件等等；- xxl_job_log：调度日志表： 用于保存XXL-JOB任务调度的历史信息，如调度结果、执行结果、调度入参、调度机器和执行器等等；- xxl_job_logglue：任务GLUE日志：用于保存GLUE更新历史，用于支持GLUE的版本回溯功能；- xxl_job_registry：执行器注册表，维护在线的执行器和调度中心机器地址信息；- xxl_job_user：系统用户表； 调度中心支持集群部署，集群情况下各节点务必连接同一个mysql实例; 如果mysql做主从,调度中心集群节点务必强制走主库; 部署调度中心 调度中心项目：xxl-job-admin 作用：统一管理任务调度平台上调度任务，负责触发调度执行，并且提供任务管理平台。 步骤一：调度中心配置 调度中心配置文件地址：/xxl-job/xxl-job-admin/src/main/resources/application.properties 数据库的连接信息修改为自己的数据库 ### webserver.port=8888server.servlet.context-path=/xxl-job-admin### actuatormanagement.server.servlet.context-path=/actuatormanagement.health.mail.enabled=false### resourcesspring.mvc.servlet.load-on-startup=0spring.mvc.static-path-pattern=/static/**spring.resources.static-locations=classpath:/static/### freemarkerspring.freemarker.templateLoaderPath=classpath:/templates/spring.freemarker.suffix=.ftlspring.freemarker.charset=UTF-8spring.freemarker.request-context-attribute=requestspring.freemarker.settings.number_format=0.############# mybatismybatis.mapper-locations=classpath:/mybatis-mapper/*Mapper.xml#mybatis.type-aliases-package=com.xxl.job.admin.core.model### xxl-job, datasourcespring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?Unicode=true&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver### datasource-poolspring.datasource.type=com.zaxxer.hikari.HikariDataSourcespring.datasource.hikari.minimum-idle=10spring.datasource.hikari.maximum-pool-size=30spring.datasource.hikari.auto-commit=truespring.datasource.hikari.idle-timeout=30000spring.datasource.hikari.pool-name=HikariCPspring.datasource.hikari.max-lifetime=900000spring.datasource.hikari.connection-timeout=10000spring.datasource.hikari.connection-test-query=SELECT 1### xxl-job, emailspring.mail.host=smtp.qq.comspring.mail.port=25spring.mail.username=xxx@qq.comspring.mail.password=xxxspring.mail.properties.mail.smtp.auth=truespring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=truespring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory### xxl-job, access tokenxxl.job.accessToken=### xxl-job, i18n (default is zh_CN, and you can choose &quot;zh_CN&quot;, &quot;zh_TC&quot; and &quot;en&quot;)xxl.job.i18n=zh_CN## xxl-job, triggerpool max sizexxl.job.triggerpool.fast.max=200xxl.job.triggerpool.slow.max=100### xxl-job, log retention daysxxl.job.logretentiondays=30 启动调度中心， localho:8080/xxl-job-amdin 默认登录账号 “admin/123456” docker安装xxl-job 1.创建mysql容器，初始化xxl-job的SQL脚本 docker run -p 3306:3306 --name mysql57 \\-v /opt/mysql/conf:/etc/mysql \\-v /opt/mysql/logs:/var/log/mysql \\-v /opt/mysql/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=root \\-d mysql:5.7 2.拉取镜像 docker pull xuxueli/xxl-job-admin:2.3.0 3.创建容器 docker run -e PARAMS=&quot;--spring.datasource.url=jdbc:mysql://192.168.88.130:3306/xxl_job?Unicode=true&amp;characterEncoding=UTF-8 \\--spring.datasource.username=root \\--spring.datasource.password=123456&quot; \\-p 8888:8080 -v /tmp:/data/applogs \\--name xxl-job-admin --restart=always -d xuxueli/xxl-job-admin:2.3.0 任务调度中心访问地址 默认账号 admin 密码 123456 image-20230816161833815 Springboot集成xxl-job 导入依赖，与使用版本保持一致 &lt;!--xxl-job--&gt;&lt;dependency&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt; application.yml配置 server: port: 8881xxl: job: admin: addresses: http://192.168.200.130:8888/xxl-job-admin executor: appname: xxl-job-executor-sample port: 9999 新建配置类 package com.heima.xxljob.config;import com.xxl.job.core.executor.impl.XxlJobSpringExecutor;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * xxl-job config * * @author xuxueli 2017-04-28 */@Configurationpublic class XxlJobConfig &#123; private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class); @Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;) private String adminAddresses; @Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;) private String appname; @Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;) private int port; @Bean public XxlJobSpringExecutor xxlJobExecutor() &#123; logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;); XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor(); xxlJobSpringExecutor.setAdminAddresses(adminAddresses); xxlJobSpringExecutor.setAppname(appname); xxlJobSpringExecutor.setPort(port); return xxlJobSpringExecutor; &#125;&#125; 任务代码，重要注解:@XxlJob(“JobHandler”) package com.zyxstu.service.impl;import com.xxl.job.core.handler.annotation.XxlJob;import org.springframework.stereotype.Component;@Componentpublic class HelloJob &#123; @XxlJob(&quot;xuanTest&quot;) public void helloJob()&#123; System.out.println(&quot;简单任务执行中。。。&quot;); &#125;&#125; 测试-单节点 启动微服务 在xxl-job的调度中心中启动任务 image-20230816170502010 image-20230816170518069 任务详解-执行器 执行器：任务的绑定的执行器，任务触发调度时将会自动发现注册成功的执行器, 实现任务自动发现功能; 另一方面也可以方便的进行任务分组。每个任务必须绑定一个执行器 image-20210729232926534 image-20210729232825564 以下是执行器的属性说明： 属性名称 说明 AppName 是每个执行器集群的唯一标示AppName, 执行器会周期性以AppName为对象进行自动注册。可通过该配置自动发现注册成功的执行器, 供任务调度时使用; 名称 执行器的名称, 因为AppName限制字母数字等组成,可读性不强, 名称为了提高执行器的可读性; 排序 执行器的排序, 系统中需要执行器的地方,如任务新增, 将会按照该排序读取可用的执行器列表; 注册方式 调度中心获取执行器地址的方式； 机器地址 注册方式为&quot;手动录入&quot;时有效，支持人工维护执行器的地址信息； 自动注册和手动注册的区别和配置 image-20210729233016355 任务详解-基础配置 image-20230816170151366 基础配置 执行器：每个任务必须绑定一个执行器, 方便给任务进行分组 任务描述：任务的描述信息，便于任务管理； 负责人：任务的负责人； 报警邮件：任务调度失败时邮件通知的邮箱地址，支持配置多邮箱地址，配置多个邮箱地址时用逗号分隔 image-20210729234009010 调度配置 调度类型： 无：该类型不会主动触发调度； CRON：该类型将会通过CRON，触发任务调度； 固定速度：该类型将会以固定速度，触发任务调度；按照固定的间隔时间，周期性触发； image-20210729234114283 任务配置 运行模式： ​ BEAN模式：任务以JobHandler方式维护在执行器端；需要结合 “JobHandler” 属性匹配执行器中任务； JobHandler：运行模式为 “BEAN模式” 时生效，对应执行器中新开发的JobHandler类“@JobHandler”注解自定义的value值； 执行参数：任务执行所需的参数； image-20210729234219162 阻塞处理策略 阻塞处理策略：调度过于密集执行器来不及处理时的处理策略； 单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO(First Input First Output)队列并以串行方式运行； 丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败； 覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务； image-20210729234256062 路由策略 当执行器集群部署时，提供丰富的路由策略，包括； FIRST（第一个）：固定选择第一个机器； LAST（最后一个）：固定选择最后一个机器； ROUND（轮询） RANDOM（随机）：随机选择在线的机器； CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。 LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举； LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举； FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度； BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度； SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务； image-20210729234409132","tags":["学习","java","开源框架"]},{"title":"“Hexo”","path":"/post/54193/","content":"什么是 Hexo？ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装 详细参考文档 | Hexo 在安装完前置条件，nodejs、git后 $ npm install -g hexo-cli 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 补充（npm无法安装或速度过慢的问题） 方法一：修改配置文件 这种方法是通过修改npm的全局配置文件，将默认的镜像源改为淘宝镜像。具体步骤如下： 打开终端，输入以下命令，设置淘宝镜像源： npm config set registry https://registry.npm.taobao.org 输入以下命令，查看是否设置成功： npm config get registry 如果返回https://registry.npm.taobao.org/，说明配置的是淘宝镜像。 现在你就可以正常使用npm安装包了，例如： npm install express 这样就会从淘宝镜像下载express包，速度会比官方快很多。 如果你想恢复成原来的官方镜像源，只需要输入以下命令： npm config set registry https://registry.npmjs.org 方法二：通过安装cnpm 这种方法是通过安装一个名为cnpm的工具，它是一个和npm兼容的命令行工具，但是默认使用淘宝镜像源。具体步骤如下： 打开终端，输入以下命令，安装cnpm： npm install -g cnpm --registry=https://registry.npm.taobao.org 输入以下命令，查看是否安装成功： cnpm -v 如果返回cnpm的版本号，说明安装成功。 现在你就可以使用cnpm代替npm安装包了，例如： cnpm install express 这样也会从淘宝镜像下载express包。 如果你想卸载cnpm，只需要输入以下命令： cnpm install express $ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install #启动服务hexo s#停止服务ctrl + C#推送至github组合命令hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 启动对应服务，打开对应网址 安装主题 这里选择的是简洁的stellar 安装与更新 安装方法 在终端中输入： $ npm i hexo-theme-stellar 在 blog/_config.yml 文件中找到并修改： theme: stellar 可以重新启动服务查看效果 image-20230901214253946 绑定github 首先需要拥有github账号并且创建一个仓库 配置对应账户邮箱的ssh密钥 $ ssh-keygen -t rsa -C &quot;你的邮箱&quot; 输入之后一直回车直到生成结束。 image-20230901221254003 到达对应地址的id_rsa.pub文件中获取，一般是在c盘的用户你的用户文件夹的.ssh中 在GitHub setting中新建密钥并添加。 到gitbash中输入 $ git config --global user.name &quot;你的名字&quot;$ git config --global user.email &quot;你的邮箱&quot; 到主题根目录中找到_config.yml文件 在底部添加如下配置 # Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git branch: main repo: git@github.com:Ezhixuan/xuanBlog.git 在gitbash中输入以下命令安装上传插件并上传 $ cnpm install hexo-deployer-git --save$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 至此绑定成功 备份数据 由于某些原因，我们可能会需要修改配置文件等未被上传的文件，但恰巧文件丢失，github上收录的又是编译后的文件，所以对数据进行备份是有必要的。 这里选择在gitee上建立一个私有仓库来存储源码 如果使用gitee记得添加ssh #git初始化git init#创建hexo分支，用来存放源码git checkout -b hexo#git 文件添加git add .#git 提交git commit -m &quot;init&quot;#添加远程仓库git remote add origin &quot;仓库地址&quot;#push到hexo分支git push origin hexo 修改日常 依次执行 $ git add .$ git commit -m &#x27;...&#x27;$ git push origin hexo 如何恢复 当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： $ git clone -b hexo &quot;仓库地址&quot;# 在本地新拷贝的YOURNAME.github.io文件夹下通过Git bash依次执行下列指令：$ npm install hexo$ npm install$ npm install hexo-deployer-git（记得，不需要hexo init这条指令）。 部署上线 因为笔者之前已经部署上线，暂时不多赘述，后续有空会进行补充，可以自行搜索查看一些文档视频等自行部署。","tags":["学习","hexo"]},{"path":"/friends/index.html","content":"种植一棵树，最好的时间是二十年前，其次是现在。Ezhixuan目前大四在读小透明，欢迎来到我的小破站，记录一些学习、生活经历。希望能够结识有趣的、志同道合的朋友。关于友链动态GitHub 我在等你"},{"path":"/about/index.html","content":"种植一棵树，最好的时间是二十年前，其次是现在。Ezhixuan目前大四在读小透明，欢迎来到我的小破站，记录一些学习、生活经历。希望能够结识有趣的、志同道合的朋友。关于友链动态GitHub 关于博客 本身不善言辞，偶尔有感而发会记录下来。 学习上经常记一些笔记，但是存放位置相对零散。 一些奇奇怪怪的原因，不好意思把自己的文章放在大平台上。 戳戳戳这里添加我的联系方式微信QQ-----&gt;微信点击获取二维码，如果图片挂了请联系我o 推荐或者添加我的WX:QQ点击获取二维码，如果图片挂了请联系我o或者添加我的QQ:"},{"path":"/friends/rss/index.html","content":""},{"path":"/timeline/index.html","content":"种植一棵树，最好的时间是二十年前，其次是现在。Ezhixuan目前大四在读小透明，欢迎来到我的小破站，记录一些学习、生活经历。希望能够结识有趣的、志同道合的朋友。关于友链动态GitHub 2023 年 9 月 1 日建立小破站2023 年 9 月 3 日完善一些小功能，添加建站计时，添加分组分页，添加关于自己等2023 年 9 月 4 日添加评论组件giscus更换评论组件由giscus -&gt; waline"},{"path":"/notes/index.html","content":"记录一下"},{"title":"N皇后","path":"/wiki/leetcode/N皇后.html","content":"题目 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。 n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 img 输入：n = 4输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]解释：如上图所示，4 皇后问题存在两个不同的解法。 输入：n = 1输出：[[&quot;Q&quot;]] 思路 首先编写大体框架 class Solution &#123; //主程序 public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; backTracking(); return res; &#125;\t//递归主体\tpublic void backTracking()&#123; //当到达最底行时对结果集进行添加 if(row == n)&#123; res.add(); return; &#125; //回溯主体 //每次向下都需要从头开始判断，所以col = 0 for(int col = 0; col &lt; n; col++)&#123; &#125; &#125;&#125; 初始化 大体框架出来后可以判断出我们至少需要定义结果集res,行数row ,以及用于收集路径且最终被结果集收集的paths。 根据题目可以知道这个paths是由若干个**.组成的并且由Q**替换 所以我们还需要初始化这个paths class Solution &#123; //定义全局的结果集res List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); //主程序 public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; //定义paths并初始化 char[][] paths = new char[n][n]; for(char[] path : paths)&#123; Arrays.fill(path,&#x27;.&#x27;); &#125; backTracking(n, 0, paths); return res; &#125;\t//递归主体\tpublic void backTracking(int n, int row, char[][] paths)&#123; //当到达最底行时对结果集进行添加 if(row == n)&#123; res.add(); return; &#125; //回溯主体 //每次向下都需要从头开始判断，所以col = 0 for(int col = 0; col &lt; n; col++)&#123; &#125; &#125;&#125; 现在关注回溯主体的编写 根据题意，我们在n皇后放下Queen时需要符合规则才放下，所以很容易想到添加时进行合法性判断,以及需要将paths有char转换为list添加进结果集 编写boolean方法isLegal判断是否合法 编写List方法arrayToList进行转换 class Solution &#123; //定义全局的结果集res List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); //主程序 public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; //定义paths并初始化 char[][] paths = new char[n][n]; for(char[] path : paths)&#123; Arrays.fill(path,&#x27;.&#x27;); &#125; backTracking(n, 0, paths); return res; &#125;\t//递归主体\tpublic void backTracking(int n, int row, char[][] paths)&#123; //当到达最底行时对结果集进行添加 if(row == n)&#123; res.add(arrayToList(paths)); return; &#125; //回溯主体 //每次向下都需要从头开始判断，所以col = 0 for(int col = 0; col &lt; n; col++)&#123; if(isLegal(row, col, paths, n))&#123; //当合法时修改Q递归并回溯 paths[row][col] = &#x27;Q&#x27;; backTracking(n, row + 1, paths); paths[row][col] = &#x27;.&#x27;; &#125; &#125; &#125; //char数组转换为List集合 public List arrayToList(char[][] paths)&#123; &#125; //判断是否合法 public boolean isLegal(int row, int col, char[][] paths, int n)&#123; &#125;&#125; 编写数组转换方法 //char数组转换为List集合public List arrayToList(char[][] paths)&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(char[] path : paths)&#123; list.add(String.copyValueOf(path)); &#125; return list;&#125; 编写合法性判断 n皇后需要满足 不同行 不同列 不同对角线 //判断是否合法 //只需要判断之前的值不需要判断之后的值，因为添加值是从前往后添加的 //不能同行 col-- //补充：因为每次添加后会进入下一列，且后续会进行回溯操作，所以不会出现同行情况 //不能同列 row-- //不能同对角线 row-- &amp;&amp; col-- //补充：此时判断为45°对角线，此外还存在135°对角线 //所以还需要判断 row-- &amp;&amp; col++ 的情况 public boolean isLegal(int row, int col, char[][] paths, int n)&#123; //判断是否同列 for(int i = 0; i &lt; n; i++)&#123; if(paths[i][col] == &#x27;Q&#x27;) return false; &#125; //判断45°对角线 for(int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--)&#123; if(paths[i][j] == &#x27;Q&#x27;) return false; &#125; //判断135°对角线 for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt;= n - 1; i--, j++)&#123; if(paths[i][j] == &#x27;Q&#x27;) return false; &#125; return true; &#125;&#125; 以上，得出最后结果 class Solution &#123; //定义全局的结果集res List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); //主程序 public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; //定义paths并初始化 char[][] paths = new char[n][n]; for(char[] path : paths)&#123; Arrays.fill(path,&#x27;.&#x27;); &#125; backTracking(n, 0, paths); return res; &#125;\t//递归主体\tpublic void backTracking(int n, int row, char[][] paths)&#123; //当到达最底行时对结果集进行添加 if(row == n)&#123; res.add(arrayToList(paths)); return; &#125; //回溯主体 //每次向下都需要从头开始判断，所以col = 0 for(int col = 0; col &lt; n; col++)&#123; if(isLegal(row, col, paths, n))&#123; //当合法时修改Q递归并回溯 paths[row][col] = &#x27;Q&#x27;; backTracking(n, row + 1, paths); paths[row][col] = &#x27;.&#x27;; &#125; &#125; &#125; //char数组转换为List集合 public List arrayToList(char[][] paths)&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(char[] path : paths)&#123; list.add(String.copyValueOf(path)); &#125; return list; &#125; //判断是否合法 //只需要判断之前的值不需要判断之后的值，因为添加值是从前往后添加的 //不能同行 col-- //补充：因为每次添加后会进入下一列，且后续会进行回溯操作，所以不会出现同行情况 //不能同列 row-- //不能同对角线 row-- &amp;&amp; col-- //补充：此时判断为45°对角线，此外还存在135°对角线 //所以还需要判断 row-- &amp;&amp; col++ 的情况 public boolean isLegal(int row, int col, char[][] paths, int n)&#123; //判断是否同列 for(int i = 0; i &lt; n; i++)&#123; if(paths[i][col] == &#x27;Q&#x27;) return false; &#125; //判断45°对角线 for(int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--)&#123; if(paths[i][j] == &#x27;Q&#x27;) return false; &#125; //判断135°对角线 for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt;= n - 1; i--, j++)&#123; if(paths[i][j] == &#x27;Q&#x27;) return false; &#125; return true; &#125;&#125;"},{"title":"二分查找","path":"/wiki/leetcode/二分查找.html","content":"关于二分查找 二分查找法（Binary Search）是一种在有序数组中查找目标元素的高效算法。它的基本思想是通过比较目标值和数组中间元素的大小关系，将搜索范围缩小一半，直到找到目标值或确定目标值不存在。 以下是二分查找法的基本步骤： 确定搜索范围：在开始查找之前，确定要在哪个有序数组中进行查找。通常，这个数组会首先进行排序。 初始化指针：设置两个指针，一个指向搜索范围的起始位置（通常为数组的第一个元素），另一个指向搜索范围的结束位置（通常为数组的最后一个元素）。 迭代查找：在每一次迭代中，计算中间元素的索引，即指针的中间位置。然后，将目标值与中间元素进行比较。 如果目标值等于中间元素，则找到目标值，返回其索引。 如果目标值小于中间元素，则目标值可能在中间元素的左侧，将结束指针移动到中间元素的前一个位置。 如果目标值大于中间元素，则目标值可能在中间元素的右侧，将起始指针移动到中间元素的后一个位置。 更新搜索范围：根据比较的结果，更新搜索范围，将搜索范围缩小一半。 重复迭代：重复执行步骤 3 和步骤 4，直到找到目标值或确定目标值不存在。如果起始指针大于结束指针，则表示目标值不存在于数组中。 二分查找法的时间复杂度为 O(log n)，其中 n 是数组的大小。由于每次迭代都将搜索范围缩小一半，因此它的查找效率非常高。 需要注意的是，二分查找法要求数组是有序的。如果数组无序，需要先对其进行排序，然后再进行二分查找。 二分查找 704. 二分查找 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 解题 class Solution &#123; public int search(int[] nums, int target) &#123; // 递增的整型数组nums中查找目标值target，找到返回下标，没找到返回-1 // 1. 初始化变量 左右指针 int left = 0, right = nums.length - 1; // 2. 确定循环条件 [left, right],此处right可取，所以选择&lt;= while (left &lt;= right)&#123; // 3. 确定中值 int mid = left + (right - left) / 2; // 防止下标越界 if(nums[mid] == target)&#123; return mid; &#125;else if (nums[mid] &lt; target)&#123; // 中值小于目标值 更新左指针 left = mid + 1; // mid处已判断，无需重复处理 &#125;else&#123; // 中值大于目标值 更新右指针 right = mid - 1; &#125; &#125; // 3.1 没找到返回-1 return -1; &#125;&#125; 个人看法 做的比较多已经算是非常熟练了，主要在于确定循环条件以及更新左右指针的处理 当区间为[left, right]左闭右闭时，因为左右区间都为有效区间，所以循环时选择 &lt;= 当区间为[left, right)左闭右开或(left, right](不常见)时，因为存在无效区间，所以循环时不选择添加 = 对于左右指针更新的处理，也是去判断mid值是否已经判断过，就不多赘述了"},{"title":"前言","path":"/wiki/leetcode/index.html","content":"此前已经一刷算法，但是有一段时间没有用了，所以觉得开启二刷，记录一下 2023 年 9 月 3 日数组"},{"title":"有序数组的平方","path":"/wiki/leetcode/有序数组的平方.html","content":"有序数组的平方 977. 有序数组的平方 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 1： 输入：nums = [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100] 示例 2： 输入：nums = [-7,-3,2,3,11]输出：[4,9,9,49,121] 提示： 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 已按 非递减顺序 排序 进阶： 请你设计时间复杂度为 O(n) 的算法解决本问题 解题 class Solution &#123; public int[] sortedSquares(int[] nums) &#123; // 非递减排序的整数数组nums， 各个数据分别平方组成新递增数组 // 明确一个观点， 对于一个非递减的整数数组，它的最小值在哪不确定，因为可能存在负数，但是它的最大值一定出现在头或尾 // 我们可以设置双指针指向头尾两侧，循环比较大小，选择大的一方平方插入新数组的最尾部并更新对应指针位置 // 1. 初始化数据 头尾指针 int head = 0, tail = nums.length - 1; int[] res = new int[nums.length]; int resIndex = res.length - 1; // 2. 确定循环条件 判断头尾是否可以取等? 因为我们是从两端依次向中间靠拢， // 总会出现 head++ == tail 或者 tail-- == head的情况，而此时则是结束的时候 while (head &lt;= tail)&#123; int max = nums[head] * nums[head] &gt;= nums[tail] * nums[tail] ?(int) Math.pow(nums[head++], 2) : (int) Math.pow(nums[tail--], 2); res[resIndex--] = max; &#125; // 3. 返回结果 return res; &#125;&#125; 个人看法 比较简单的一题，确定最大值依次由高向低靠拢即可。 唯一的难点是对于循环条件的判断，需要辨别究竟能不能取等。"},{"title":"关于数组","path":"/wiki/leetcode/关于数组.html","content":"什么是数组 数组是非常基础的数据结构 数组（array）是一种最简单的复合数据类型，它是有序数据的集合，数组中的每个元素具有相同的数据类型，可以用一个统一的数组名和不同的下标来确定数组中唯一的元素。根据数组的维度，可以将其分为一维数组、二维数组和多维数组等。 数组是一个存于连续内存空间中的相同类型数据的集合。 数组可以方便的通过下标索引的方式获取到对应下标的数据 算法通关数组 需要注意的是 数组的下标都是从0开始 数组内存空间的地址是连续的 数组的优点 相比其它类型的数据结构，数组有以下优点： 数组允许随机访问数组元素，每个存储在数组中的元素可以通过直接访问其索引来使用 数组对存储友好。这意味着在某些情况下，由于数组的线性存储方式，代码的执行顺序会大大提高 数组的缺点 声明数组时，需要指定数组的长度。初始声明数组的长度过长或过短，在移动数组元素时都会有导致效率变低 插入和删除元素之后保持数组的连续性代价是昂贵的，因为有可能需要重新排列所有数组元素。 参考资料：代码随想录 (programmercarl.com)"},{"title":"长度最小的子数组","path":"/wiki/leetcode/长度最小的子数组.html","content":"长度最小的子数组 209. 长度最小的子数组 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度**。**如果不存在符合条件的子数组，返回 0 。 示例 1： 输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2： 输入：target = 4, nums = [1,4,4]输出：1 示例 3： 输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0 提示： 1 &lt;= target &lt;= 109 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105 进阶： 如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。 解法 class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; // 找出数组中和 &gt;= target 的长度最小的 连续的 子数组，返回长度，如果不存在返回0 // 我这里只想到应该是O(n)的解法，使用滑动窗口，最差的情况应该是遍历完集合，后续尝试看看能不能写出O(nlog(n))的解法 // 1. 初始化变量 左右窗口指针,返回结果(结果设置最大整数方便后续判断)，窗口值 int left = 0, right = 0, res = Integer.MAX_VALUE, sum = 0; // 2. 确定循环条件 这里选择右指针小于数组长度时循环，也就是直到右指针走出数组循环结束 while (right &lt; nums.length )&#123; sum += nums[right++]; while(sum &gt;= target )&#123; // 当窗口值大于等于target时，收集结果值，并且收缩窗口，窗口右滑，因为可能删去一个还是大于，所以用while保证判断结束后一定小于target res = res &lt; right - left ? res : right - left; sum -= nums[left++]; &#125; &#125; // 3. 返回结果 return res == Integer.MAX_VALUE ? 0 : res; &#125;&#125; 个人看法 一道中等难度的题目，个人认为主要在于res的选值如果赋予0为初始值的话后续结果不好判断 再就是收集结果的时候对于if和while的选择很关键。"},{"title":"移除元素","path":"/wiki/leetcode/移除元素.html","content":"移除元素 27. 移除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 示例 1： 输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2： 输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 50 0 &lt;= val &lt;= 100 解题 class Solution &#123; public int removeElement(int[] nums, int val) &#123; // 原地移除数组中数值等于val的元素，返回移除后新数组的新长度，O(1)的额外空间, // 快慢指针 快指针自增遍历，当且仅当遇到！=val的元素时更新慢指针前进 // 1. 初始化变量 int fast = 0, slow = 0; for(;fast &lt; nums.length; fast++)&#123; if (nums[fast] != val)&#123; // 当且仅当遇到！=val的元素时更新慢指针前进 nums[slow] = nums[fast]; slow++; &#125; &#125; // 2. 返回新数组长度 return slow; &#125;&#125; 个人看法 也是比较基础的一个双指针的问题，这里使用的是快慢指针，因为我们需要原地更新数组。 快指针去寻找符合条件的数据传递给慢指针更新数组即可。"},{"title":"测试","path":"/wiki/stellar/index.html","content":"支持多彩标记，包括：默认 红 橙 黄 绿 青 蓝 紫 浅 深 警告 错误 一共 12 种颜色。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 &#123;% note 这&amp;nbsp;是标题 这是正文 哈哈。 %&#125; 这&nbsp;是标题这是正文 哈哈。 我是一个标题 我是一个h3标题 我是一个h1标题"},{"title":"我说一句话","path":"/wiki/stellar/我说一句话.html","content":"公道话"},{"title":"我试试","path":"/wiki/stellar/测试.html","content":"有没有问题"}]