[{"title":"使用腾讯云Cos实现上传下载","path":"/post/e2534ec2/","content":"本文中出现的所有xiaomo.txcos 均可替换成任意自己填入 使用腾讯云cos实现上传下载 导入依赖 &lt;dependency&gt; &lt;groupId&gt;com.qcloud&lt;/groupId&gt; &lt;artifactId&gt;cos_api&lt;/artifactId&gt; &lt;version&gt;5.6.167&lt;/version&gt;&lt;/dependency&gt; 设置上传文件大小 servlet: multipart: max-request-size: 1024MB max-file-size: 1024MB 配置文件，通过配置文件填入对应数值。 xiaomo: txcos: tmpSecretId: # 你的secretId tmpSecretKey: # 你的secretKey bucketName: # 你的bucketName region: # 你仓库的地址 /** * @program: xiaomo-take-out * @description: 腾讯云Cos * @author: Mr.Xuan * @create: 2023-09-08 10:13 */@Component@Slf4j@Data@ConfigurationProperties(prefix = &quot;xiaomo.txcos&quot;)public class TencentCosProperties &#123; private String tmpSecretId; private String tmpSecretKey; private String bucketName; private String region; &#125; 通过IOC初始化Bean /** * @program: xiaomo-take-out * @description: * @author: Mr.Xuan * @create: 2023-09-08 10:46 */@Configuration@Slf4jpublic class CosConfiguration &#123; @Bean @ConditionalOnMissingBean public TencentCosUtil tencentCosUtil(TencentCosProperties tencentCosProperties) &#123; log.info(&quot;开始创建腾讯云文件上传对象&#123;&#125;&quot;, tencentCosProperties); TencentCosUtil tencentCosUtil = new TencentCosUtil( tencentCosProperties.getTmpSecretId(), tencentCosProperties.getTmpSecretKey(), tencentCosProperties.getBucketName(), tencentCosProperties.getRegion()); return tencentCosUtil; &#125;&#125; 导入上传工具类 /** * @program: xiaomo-take-out * @description: cos工具类 * @author: Mr.Xuan * @create: 2023-09-08 11:47 */@Data@AllArgsConstructor@Slf4jpublic class TencentCosUtil &#123; private String tmpSecretId; private String tmpSecretKey; private String bucketName; private String region; public String upload(MultipartFile file) &#123; // 创建COSClient实例 ClientConfig clientConfig = new ClientConfig(new Region(region)); clientConfig.setHttpProtocol(HttpProtocol.https); COSClient cosClient = new COSClient(new BasicCOSCredentials(tmpSecretId, tmpSecretKey), clientConfig); try &#123; // 获取上传文件的输入流 InputStream inputStream = file.getInputStream(); // 对象键(Key)是对象在存储桶中的唯一标识。 String substring = Objects.requireNonNull(file.getOriginalFilename()) .substring(file.getOriginalFilename().lastIndexOf(&quot;.&quot;)); String key = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;) + substring; // 对上传文件分组 String dateUrl = new DateTime().toString(&quot;yyyy/MM/dd&quot;); key = dateUrl + &quot;/&quot; + key; ObjectMetadata objectMetadata = new ObjectMetadata(); PutObjectRequest putObjectRequest = new PutObjectRequest(bucketName, key, inputStream, objectMetadata); PutObjectResult putObjectResult = cosClient.putObject(putObjectRequest); System.out.println(JSON.toJSONString(putObjectResult)); // 返回上传文件路径 StringBuilder stringBuilder = new StringBuilder(&quot;https://&quot;); stringBuilder .append(bucketName) .append(&quot;.cos.&quot;) .append(region) .append(&quot;.myqcloud.com/&quot;) .append(key); return stringBuilder.toString(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 最后到需要使用的地方自动装配工具类使用即可 这里以Impl为例 /** * @program: xiaomo-take-out * @description: * @author: Mr.Xuan * @create: 2023-09-08 11:38 */@Servicepublic class CommonServiceImpl implements CommonService&#123; @Resource private TencentCosUtil tencentCosUtil; /** * 文件上传 * * @param file * @return */ @Override public Result&lt;String&gt; upload(MultipartFile file) &#123; String upload = tencentCosUtil.upload(file); return Result.success(upload); &#125;&#125;","tags":["java","腾讯云","cos"],"categories":["java"]},{"title":"公共字段自动填充","path":"/post/781a6a1a/","content":"使用Mp实现公共字段自动填充 需要实现自动填充的字段上添加@TableFile标签，指定自动填充策略。 实现MetaObjectHandler接口 .../** 创建时间 */@TableField(fill = FieldFill.INSERT)private LocalDateTime createTime;/** 更新时间 */@TableField(fill = FieldFill.INSERT_UPDATE)private LocalDateTime updateTime;/** 创建人 */@TableField(fill = FieldFill.INSERT)private Long createUser;/** 修改人 */@TableField(fill = FieldFill.INSERT_UPDATE)private Long updateUser;... @Component@Slf4jpublic class MpHandler implements MetaObjectHandler &#123; /** * 插入元对象字段填充（用于插入时对公共字段的填充） * * @param metaObject 元对象 */ @Override public void insertFill(MetaObject metaObject) &#123; log.info(&quot;开始插入填充&quot;); metaObject.setValue(&quot;createUser&quot;, BaseContext.getCurrentId()); metaObject.setValue(&quot;createTime&quot;, LocalDateTime.now()); metaObject.setValue(&quot;updateUser&quot;, BaseContext.getCurrentId()); metaObject.setValue(&quot;updateTime&quot;, LocalDateTime.now()); &#125; /** * 更新元对象字段填充（用于更新时对公共字段的填充） * * @param metaObject 元对象 */ @Override public void updateFill(MetaObject metaObject) &#123; log.info(&quot;开始更新填充&quot;); metaObject.setValue(&quot;updateUser&quot;, BaseContext.getCurrentId()); metaObject.setValue(&quot;updateTime&quot;, LocalDateTime.now()); &#125;&#125; 此处BaseContext是由ThreadLocal获取。 /** * 字段填充策略枚举类 * * &lt;p&gt; * 判断注入的 insert 和 update 的 sql 脚本是否在对应情况下忽略掉字段的 if 标签生成 * &lt;if test=&quot;...&quot;&gt;......&lt;/if&gt; * 判断优先级比 &#123;@link FieldStrategy&#125; 高 * &lt;/p&gt; * * @author hubin * @since 2017-06-27 */public enum FieldFill &#123; /** * 默认不处理 */ DEFAULT, /** * 插入时填充字段 */ INSERT, /** * 更新时填充字段 */ UPDATE, /** * 插入和更新时填充字段 */ INSERT_UPDATE&#125;","tags":["java","学习分享"],"categories":["java"]},{"title":"Hexo添加字数统计","path":"/post/5904fa7e/","content":"本篇文章使用的是hexo-stellar主题 footer.ejs 首先找到node_modules/hexo-theme-stellar/layout/_partial/main/footer.ejs文件 末尾可直接复制整个footer.ejs文件 找到该代码所处区域 // footer el += &#x27;&lt;div class=&quot;text&quot;&gt;&#x27;; if (content) &#123; if ((typeof content == &#x27;string&#x27;) &amp;&amp; content.constructor == String) &#123; el += markdown(content); &#125; else if ((typeof content == &#x27;object&#x27;) &amp;&amp; content.constructor == Array) &#123; content.forEach((item, i) =&gt; &#123; el += markdown(item); &#125;); &#125; &#125; 在其尾部添加代码 if (theme.footer.up_time) &#123; el += &#x27;&lt;div&gt;&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;&#x27;; if (theme.footer.busuanzi.enable) &#123; el += &#x27;，&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;总访问量: &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;&#x27;; el += &#x27;，&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;访客数: &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人&lt;/span&gt;&#x27;; &#125; el += &#x27;&lt;/div&gt;&#x27; &#125; 最后在最底部添加代码 &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;script&gt; function createtime() &#123; var now = new Date(); var grt= new Date(&quot;09/01/2023 00:00:00&quot;); now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125; document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已运行 &quot;+dnum+&quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; &#125;; setInterval(&quot;createtime()&quot;,250);&lt;/script&gt; 最终代码 &lt;%const content = theme.footer.content;function layoutDiv() &#123; var el = &#x27;&#x27;; el += &#x27;&lt;footer class=&quot;page-footer reveal fs12&quot;&gt;&#x27;; el += &#x27;&lt;hr&gt;&#x27;; // sitemap if (theme.footer.sitemap &amp;&amp; Object.keys(theme.footer.sitemap).length &gt; 0) &#123; el += &#x27;&lt;div class=&quot;sitemap&quot;&gt;&#x27;; for (let group of Object.keys(theme.footer.sitemap)) &#123; let items = theme.footer.sitemap[group]; if (items == undefined || items.length == 0) &#123; continue; &#125; el += &#x27;&lt;div class=&quot;sitemap-group&quot;&gt;&#x27;; el += &#x27;&lt;span class=&quot;fs14&quot;&gt;&#x27; + group + &#x27;&lt;/span&gt;&#x27;; items.forEach((item, i) =&gt; &#123; el += &#x27;&lt;a href=&quot;&#x27; + url_for(md_link(item)) + &#x27;&quot;&gt;&#x27;; el += __(md_text(item)); el += &#x27;&lt;/a&gt;&#x27;; &#125;); el += &#x27;&lt;/div&gt;&#x27;; &#125; el += &#x27;&lt;/div&gt;&#x27;; &#125; // footer el += &#x27;&lt;div class=&quot;text&quot;&gt;&#x27;; if (content) &#123; if ((typeof content == &#x27;string&#x27;) &amp;&amp; content.constructor == String) &#123; el += markdown(content); &#125; else if ((typeof content == &#x27;object&#x27;) &amp;&amp; content.constructor == Array) &#123; content.forEach((item, i) =&gt; &#123; el += markdown(item); &#125;); &#125; &#125; if (theme.footer.up_time) &#123; el += &#x27;&lt;div&gt;&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;&#x27;; if (theme.footer.busuanzi.enable) &#123; el += &#x27;，&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;总访问量: &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;&#x27;; el += &#x27;，&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;访客数: &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人&lt;/span&gt;&#x27;; &#125; el += &#x27;&lt;/div&gt;&#x27; &#125; el += &#x27;&lt;/div&gt;&lt;/footer&gt;&#x27;; return el;&#125;%&gt;&lt;%- layoutDiv() %&gt;&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;script&gt; function createtime() &#123; var now = new Date(); var grt= new Date(&quot;09/01/2023 00:00:00&quot;); now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125; document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已运行 &quot;+dnum+&quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; &#125;; setInterval(&quot;createtime()&quot;,250);&lt;/script&gt; _config.yml 在主题目录（不是根目录） node_modules/hexo-theme-stellar/_config.yml添加如下配置即可 ######## Footer ########footer: ... up_time: enable: true busuanzi: enable: true","tags":["hexo"],"categories":["hexo"]},{"title":"数据库表自增问题","path":"/post/4fc13300/","content":"数据库表自增问题 前言：因为在使用mp时没有在配置文件中设置自增策略，也没有使用@TableId注解去修饰id字段，导致数据库中的id在添加时使用mp默认的雪花算法，但这并不是我期望在本表中使用的，所以需要修改 首先我赶紧在id字段上添加上@TableId(type = IdType.AUTO) 好消息是id变成+1的自增了 坏消息是仍然保持了最迟一次生成的雪花值在+1自增，即使这个雪花值已经被删除。 MySQL 是一个开源的关系型数据库管理系统，广泛应用于各种企业和互联网应用中。在 MySQL 数据库中，自增键是一种非常常用的类型，能够简化开发者的开发工作。但有时候我们需要能够动态修改自增值。下面介绍一下如何使用 MySQL 实现动态修改自增值的方法。 ALTER TABLE tableName AUTO_INCREMENT = value; 以上代码可以改变指定表的 AUTO_INCREMENT 值，设置自增键的下一个值为 value。首先需要了解的是，MySQL 中自增键是用于提供唯一值的一种类型，即每个自增键值都必须是唯一的。我们可以通过以下步骤实现动态修改自增值： 查看数据库中的所有表： SHOW TABLES; 确定需要修改自增值的表。 查看表的结构信息： DESCRIBE tableName; 确定需要修改自增值的字段和表名。 使用ALTER TABLE命令修改自增值： ALTER TABLE tableName AUTO_INCREMENT = value; 将自增键的下一个值设置为指定的value。 通过以上步骤，就可以在MySQL数据库中实现动态修改自增值。","tags":["mysql","问题处理"],"categories":["mysql"]},{"title":"Hexo文章图片显示","path":"/post/528f971c/","content":"配置 直接进入到你hexo的目录，右键打开git bash命令行，执行npm install hexo-asset-image –save 接着node_modules -&gt; hexo-asset-image -&gt; index.js 第58行找到，或者直接全局搜索也行 修改为 image-20230905132247109 然后在hexo目录的_config.yml配置文件中设置 image-20230905132432534 每次生成new 一篇文章的时候会自动再同目录下生成相同名的文件夹，该文件夹下存放你的图片地址 如果使用typora软件的话，进行如下配置，在插入图片时会自动插入到同名文件夹下 image-20230905132639300","tags":["hexo"],"categories":["hexo"]},{"title":"Knife4j","path":"/post/3ba05f4e/","content":"Knife4j 是日常开发中很常用的框架，基于此框架，后端可以和前端开发人员进行高效沟通。 详细使用可以参考官方文档Knife4j · 集Swagger2及OpenAPI3为一体的增强解决方案. | Knife4j (xiaominfo.com) 快速入门 Swagger&amp;&amp;knife4j 导入依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-openapi2-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;4.3.0&lt;/version&gt;&lt;/dependency&gt; 开启增强 knife4j: enable: true 配置类 package com.ezhixuan.knife4jquickstart.config;import com.github.xiaoymin.knife4j.spring.annotations.EnableKnife4j;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;/** * @program: knife4j-quickstart * @description: knife4j配置类 * @author: Mr.Xuan * @create: 2023-09-05 09:29 **/@Slf4j@EnableKnife4j@Configurationpublic class Knife4jConfig &#123; /** * 通过knife4j生成接口文档 * @return */ @Bean(value = &quot;docket&quot;) public Docket docket() &#123; log.info(&quot;正在生成接口文档&quot;); ApiInfo apiInfo = new ApiInfoBuilder() .title(&quot;xxx项目接口文档&quot;) .version(&quot;1.0&quot;) .description(&quot;xxx项目接口文档&quot;) .build(); Docket docket = new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.ezhixuan.knife4jquickstart.controller&quot;)) .paths(PathSelectors.any()) .build(); return docket; &#125;&#125; controller package com.ezhixuan.knife4jquickstart.controller;import com.ezhixuan.knife4jquickstart.pojo.entity.User;import io.swagger.annotations.Api;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiOperation;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.*;/** * @program: knife4j-quickstart * @description: controller-demo * @author: Mr.Xuan * @create: 2023-09-05 09:31 **/@Api(tags = &quot;你好&quot;)@RestController@RequestMapping(&quot;/hello&quot;)public class HelloController &#123; @ApiOperation(value = &quot;向客人问好&quot;) @ApiImplicitParam(name = &quot;name&quot;, value = &quot;用户名&quot;, required = true, paramType = &quot;String&quot;) @GetMapping(&quot;/sayHi&quot;) public ResponseEntity&lt;String&gt; sayHi(@RequestParam(&quot;name&quot;)String name)&#123; return ResponseEntity.ok(&quot;Hi:&quot;+name); &#125; @PostMapping(&quot;/login&quot;) @ApiOperation(value = &quot;登录&quot;) public ResponseEntity&lt;String&gt; login(@RequestBody User user) &#123; return ResponseEntity.ok(&quot;login&quot;); &#125;&#125; pojo package com.ezhixuan.knife4jquickstart.pojo.entity;import io.swagger.annotations.ApiModelProperty;import lombok.Data;/** * @program: knife4j-quickstart * @description: 用户信息 * @author: Mr.Xuan * @create: 2023-09-05 09:33 **/@Datapublic class User &#123; @ApiModelProperty(value = &quot;用户名&quot;, required = true, example = &quot;张三&quot;) private String userName; @ApiModelProperty(value = &quot;密码&quot;, required = true, example = &quot;123456&quot;) private String password;&#125; image-20230905112951285 image-20230905113002420 image-20230905113013447 常用注解 注解 作用 使用位置 @Api 表示对类的说明常用参数 类上面 @ApiOperation 说明方法的用途、作用 方法上面 @ApiModel 表示一个返回响应数据的信息 响应类 @ApiModelProperty 描述响应类的属性 属性 @ApiImplicitParams 参数注解 方法上 @Api 标识一个java类型是文档类，用在controller类的类名上 value: 字符串类型，对controller类的作用进行描述 tags: 字符串数组，同样对controller类的作用进行描述 示例代码： @Api(tags = &quot;你好&quot;)@RestController@RequestMapping(&quot;/hello&quot;)public class HelloController &#123;&#125; @ApiOperation 作用在接口类的方法上，控制方法的相关描述 value：字符串，方法的功能描述 tags：字符串数组，标签组，同样可以描述方法的作用； response：ClassType，显示指出返回的对象类型；在响应示例中会显示出改对象的字段以及示例、描述 code：响应代码，默认200，一般不改； 示例代码: @ApiOperation(value = &quot;向客人问好&quot;) @ApiImplicitParam(name = &quot;name&quot;, value = &quot;用户名&quot;, required = true, paramType = &quot;String&quot;) @GetMapping(&quot;/sayHi&quot;) public ResponseEntity&lt;String&gt; sayHi(@RequestParam(&quot;name&quot;)String name)&#123;&#125; @ApiModel 表示一个实体类/模型文档，用在类名上 value: 字符串类型，设置模型别名 description: 字符串，对模型进行描述 示例代码: @Data@ApiModel(value = &quot;用户登录信息&quot;, description = &quot;判断用户登录状况&quot;)public class User &#123;&#125; @ApiModelProperty 作用在属性上，添加属性描述 value：字符串，字段描述； required：boolean；指定参数是否必须，默认false； example：字符串，参数值的示例 示例代码: @ApiModelProperty(value = &quot;用户名&quot;, required = true, example = &quot;张三&quot;) private String userName; @ApiImplicitParams （@ApiImplicitParam 对单个参数）用在请求的方法上，包含一组参数说明 name：参数名 value：参数的说明、描述 required：参数是否必须必填 paramType：参数放在哪个地方 · query --&gt; 请求参数的获取：@RequestParam · header --&gt; 请求参数的获取：@RequestHeader · path（用于restful接口）–&gt; 请求参数的获取：@PathVariable · body（请求体）–&gt; @RequestBody User user · form（普通表单提交） dataType：参数类型，默认String，其它值dataType=“Integer” dataTypeClass: 类属性，填写dataType的类，不填也没关系但是控制台会给一个警告提示。 defaultValue：参数的默认值 示例代码： @ApiOperation(value = &quot;向客人问好&quot;) @ApiImplicitParams(&#123; @ApiImplicitParam(name = &quot;name&quot;, value = &quot;用户名&quot;, required = true, dataType = &quot;String&quot;), @ApiImplicitParam(...) &#125; ) @GetMapping(&quot;/sayHi&quot;) public ResponseEntity&lt;String&gt; sayHi(@RequestParam(&quot;name&quot;)String name)&#123;&#125;@ApiOperation(value = &quot;向客人问好&quot;) @ApiImplicitParam(name = &quot;name&quot;, value = &quot;用户名&quot;, required = true, dataType = &quot;String&quot;) @GetMapping(&quot;/sayHi&quot;) public ResponseEntity&lt;String&gt; sayHi(@RequestParam(&quot;name&quot;)String name)&#123;&#125; 补充 Unable to interpret the implicit parameter configuration with dataType: Integer, dataTypeClass: class java.lang.Void image-20230906145315400 启动时发现说dataType与dataTypeClass不符。 是在配置 @ApiImplicitParam(name = &quot;id&quot;, value = &quot;员工id&quot;, required = true, dataType = &quot;Integer&quot;, dataTypeClass = Integer.class) 时漏填或者填错dataTypeClass，修改一致即可。","tags":["java","knife4j"],"categories":["技术分享"]},{"title":"Xxl-Job","path":"/post/586965a7/","content":"xxl-job XXL-JOB是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。 源码地址：xxl-job: 一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。 文档地址：分布式任务调度平台XXL-JOB (xuxueli.com) 分布式任务调度 为什么使用xxl-job xxl-job是一款分布式任务调度的开源框架 与Springboot提供的@scheduled定时任务相比 @Scheduled存在以下问题 定时任务失败无法重试 在处理集群任务时会出现重复执行的问题 cron表达式定义在代码之中，不方便修改 当任务量过大时，无法有效分片执行 使用xxl-job来解决这些问题 什么是分布式任务调度 当前软件的架构已经向分布式架构转变，将单体项目拆分成若干服务，服务之间通过网络交互来完成业务处理。在分布式架构下，一个服务往往会部署多个实例来运行业务，在这种分布式系统环境下运行任务调度，称为分布式调度 ​\t1、并行任务调度 并行任务调度实现靠多线程，如果有大量任务需要调度，此时光靠多线程就会有瓶颈了，因为一台计算机CPU的处理能力是有限的。 如果将任务调度程序分布式部署，每个结点还可以部署为集群，这样就可以让多台计算机共同去完成任务调度，我们可以将任务分割为若干个分片，由不同的实例并行执行，来提高任务调度的处理效率。 ​\t2、高可用 若某一个实例宕机，不影响其他实例来执行任务。 ​\t3、弹性扩容 当集群中增加实例就可以提高并执行任务的处理效率。 ​\t4、任务管理与监测 对系统中存在的所有定时任务进行统一的管理及监测。让开发人员及运维人员能够时刻了解任务执行情况，从而做出快速的应急处理响应。 分布式任务调度面临的问题： 当任务调度以集群方式部署，同一个任务调度可能会执行多次，例如：电商系统定期发放优惠券，就可能重复发放优惠券，对公司造成损失，信用卡还款提醒就会重复执行多次，给用户造成烦恼，所以我们需要控制相同的任务在多个运行实例上只执行一次。常见解决方案： 分布式锁，多个实例在任务执行前首先需要获取锁，如果获取失败那么就证明有其他服务已经在运行，如果获取成功那么证明没有服务在运行定时任务，那么就可以执行。 ZooKeeper选举，利用ZooKeeper对Leader实例执行定时任务，执行定时任务的时候判断自己是否是Leader，如果不是则不执行，如果是则执行业务逻辑，这样也能达到目的。 特性 简单灵活 提供Web页面对任务进行管理，管理系统支持用户管理、权限控制； 支持容器部署； 支持通过通用HTTP提供跨平台任务调度； 丰富的任务管理功能 支持页面对任务CRUD操作； 支持在页面编写脚本任务、命令行任务、Java代码任务并执行； 支持任务级联编排，父任务执行结束后触发子任务执行； 支持设置指定任务执行节点路由策略，包括轮询、随机、广播、故障转移、忙碌转移等； 支持Cron方式、任务依赖、调度中心API接口方式触发任务执行 高性能 任务调度流程全异步化设计实现，如异步调度、异步运行、异步回调等，有效对密集调度进行流量削峰； 高可用 任务调度中心、任务执行节点均 集群部署，支持动态扩展、故障转移 支持任务配置路由故障转移策略，执行器节点不可用是自动转移到其他节点执行 支持任务超时控制、失败重试配置 支持任务处理阻塞策略：调度当任务执行节点忙碌时来不及执行任务的处理策略，包括：串行、抛弃、覆盖策略 易于监控运维 支持设置任务失败邮件告警，预留接口支持短信、钉钉告警； 支持实时查看任务执行运行数据统计图表、任务进度监控数据、任务完整执行日志； 部署xxl-job 调度中心环境要求 Maven3+ Jdk1.8+ Mysql5.7+ 初始化调度数据库 请下载项目源码并解压，获取 “调度数据库初始化SQL脚本” 并执行即可。 位置：/xxl-job/doc/db/tables_xxl_job.sql 共8张表 - xxl_job_lock：任务调度锁表；- xxl_job_group：执行器信息表，维护任务执行器信息；- xxl_job_info：调度扩展信息表： 用于保存XXL-JOB调度任务的扩展信息，如任务分组、任务名、机器地址、执行器、执行入参和报警邮件等等；- xxl_job_log：调度日志表： 用于保存XXL-JOB任务调度的历史信息，如调度结果、执行结果、调度入参、调度机器和执行器等等；- xxl_job_logglue：任务GLUE日志：用于保存GLUE更新历史，用于支持GLUE的版本回溯功能；- xxl_job_registry：执行器注册表，维护在线的执行器和调度中心机器地址信息；- xxl_job_user：系统用户表； 调度中心支持集群部署，集群情况下各节点务必连接同一个mysql实例; 如果mysql做主从,调度中心集群节点务必强制走主库; 部署调度中心 调度中心项目：xxl-job-admin 作用：统一管理任务调度平台上调度任务，负责触发调度执行，并且提供任务管理平台。 步骤一：调度中心配置 调度中心配置文件地址：/xxl-job/xxl-job-admin/src/main/resources/application.properties 数据库的连接信息修改为自己的数据库 ### webserver.port=8888server.servlet.context-path=/xxl-job-admin### actuatormanagement.server.servlet.context-path=/actuatormanagement.health.mail.enabled=false### resourcesspring.mvc.servlet.load-on-startup=0spring.mvc.static-path-pattern=/static/**spring.resources.static-locations=classpath:/static/### freemarkerspring.freemarker.templateLoaderPath=classpath:/templates/spring.freemarker.suffix=.ftlspring.freemarker.charset=UTF-8spring.freemarker.request-context-attribute=requestspring.freemarker.settings.number_format=0.############# mybatismybatis.mapper-locations=classpath:/mybatis-mapper/*Mapper.xml#mybatis.type-aliases-package=com.xxl.job.admin.core.model### xxl-job, datasourcespring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?Unicode=true&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver### datasource-poolspring.datasource.type=com.zaxxer.hikari.HikariDataSourcespring.datasource.hikari.minimum-idle=10spring.datasource.hikari.maximum-pool-size=30spring.datasource.hikari.auto-commit=truespring.datasource.hikari.idle-timeout=30000spring.datasource.hikari.pool-name=HikariCPspring.datasource.hikari.max-lifetime=900000spring.datasource.hikari.connection-timeout=10000spring.datasource.hikari.connection-test-query=SELECT 1### xxl-job, emailspring.mail.host=smtp.qq.comspring.mail.port=25spring.mail.username=xxx@qq.comspring.mail.password=xxxspring.mail.properties.mail.smtp.auth=truespring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=truespring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory### xxl-job, access tokenxxl.job.accessToken=### xxl-job, i18n (default is zh_CN, and you can choose &quot;zh_CN&quot;, &quot;zh_TC&quot; and &quot;en&quot;)xxl.job.i18n=zh_CN## xxl-job, triggerpool max sizexxl.job.triggerpool.fast.max=200xxl.job.triggerpool.slow.max=100### xxl-job, log retention daysxxl.job.logretentiondays=30 启动调度中心， localho:8080/xxl-job-amdin 默认登录账号 “admin/123456” docker安装xxl-job 1.创建mysql容器，初始化xxl-job的SQL脚本 docker run -p 3306:3306 --name mysql57 \\-v /opt/mysql/conf:/etc/mysql \\-v /opt/mysql/logs:/var/log/mysql \\-v /opt/mysql/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=root \\-d mysql:5.7 2.拉取镜像 docker pull xuxueli/xxl-job-admin:2.3.0 3.创建容器 docker run -e PARAMS=&quot;--spring.datasource.url=jdbc:mysql://192.168.88.130:3306/xxl_job?Unicode=true&amp;characterEncoding=UTF-8 \\--spring.datasource.username=root \\--spring.datasource.password=123456&quot; \\-p 8888:8080 -v /tmp:/data/applogs \\--name xxl-job-admin --restart=always -d xuxueli/xxl-job-admin:2.3.0 任务调度中心访问地址 默认账号 admin 密码 123456 image-20230816161833815 Springboot集成xxl-job 导入依赖，与使用版本保持一致 &lt;!--xxl-job--&gt;&lt;dependency&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt; application.yml配置 server: port: 8881xxl: job: admin: addresses: http://192.168.200.130:8888/xxl-job-admin executor: appname: xxl-job-executor-sample port: 9999 新建配置类 package com.heima.xxljob.config;import com.xxl.job.core.executor.impl.XxlJobSpringExecutor;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * xxl-job config * * @author xuxueli 2017-04-28 */@Configurationpublic class XxlJobConfig &#123; private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class); @Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;) private String adminAddresses; @Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;) private String appname; @Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;) private int port; @Bean public XxlJobSpringExecutor xxlJobExecutor() &#123; logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;); XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor(); xxlJobSpringExecutor.setAdminAddresses(adminAddresses); xxlJobSpringExecutor.setAppname(appname); xxlJobSpringExecutor.setPort(port); return xxlJobSpringExecutor; &#125;&#125; 任务代码，重要注解:@XxlJob(“JobHandler”) package com.zyxstu.service.impl;import com.xxl.job.core.handler.annotation.XxlJob;import org.springframework.stereotype.Component;@Componentpublic class HelloJob &#123; @XxlJob(&quot;xuanTest&quot;) public void helloJob()&#123; System.out.println(&quot;简单任务执行中。。。&quot;); &#125;&#125; 测试-单节点 启动微服务 在xxl-job的调度中心中启动任务 image-20230816170502010 image-20230816170518069 任务详解-执行器 执行器：任务的绑定的执行器，任务触发调度时将会自动发现注册成功的执行器, 实现任务自动发现功能; 另一方面也可以方便的进行任务分组。每个任务必须绑定一个执行器 image-20210729232926534 image-20210729232825564 以下是执行器的属性说明： 属性名称 说明 AppName 是每个执行器集群的唯一标示AppName, 执行器会周期性以AppName为对象进行自动注册。可通过该配置自动发现注册成功的执行器, 供任务调度时使用; 名称 执行器的名称, 因为AppName限制字母数字等组成,可读性不强, 名称为了提高执行器的可读性; 排序 执行器的排序, 系统中需要执行器的地方,如任务新增, 将会按照该排序读取可用的执行器列表; 注册方式 调度中心获取执行器地址的方式； 机器地址 注册方式为&quot;手动录入&quot;时有效，支持人工维护执行器的地址信息； 自动注册和手动注册的区别和配置 image-20210729233016355 任务详解-基础配置 image-20230816170151366 基础配置 执行器：每个任务必须绑定一个执行器, 方便给任务进行分组 任务描述：任务的描述信息，便于任务管理； 负责人：任务的负责人； 报警邮件：任务调度失败时邮件通知的邮箱地址，支持配置多邮箱地址，配置多个邮箱地址时用逗号分隔 image-20210729234009010 调度配置 调度类型： 无：该类型不会主动触发调度； CRON：该类型将会通过CRON，触发任务调度； 固定速度：该类型将会以固定速度，触发任务调度；按照固定的间隔时间，周期性触发； image-20210729234114283 任务配置 运行模式： ​ BEAN模式：任务以JobHandler方式维护在执行器端；需要结合 “JobHandler” 属性匹配执行器中任务； JobHandler：运行模式为 “BEAN模式” 时生效，对应执行器中新开发的JobHandler类“@JobHandler”注解自定义的value值； 执行参数：任务执行所需的参数； image-20210729234219162 阻塞处理策略 阻塞处理策略：调度过于密集执行器来不及处理时的处理策略； 单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO(First Input First Output)队列并以串行方式运行； 丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败； 覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务； image-20210729234256062 路由策略 当执行器集群部署时，提供丰富的路由策略，包括； FIRST（第一个）：固定选择第一个机器； LAST（最后一个）：固定选择最后一个机器； ROUND（轮询） RANDOM（随机）：随机选择在线的机器； CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。 LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举； LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举； FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度； BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度； SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务； image-20210729234409132","tags":["java","学习","开源框架"]},{"title":"“Hexo”","path":"/post/54193/","content":"什么是 Hexo？ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装 详细参考文档 | Hexo 在安装完前置条件，nodejs、git后 $ npm install -g hexo-cli 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 补充（npm无法安装或速度过慢的问题） 方法一：修改配置文件 这种方法是通过修改npm的全局配置文件，将默认的镜像源改为淘宝镜像。具体步骤如下： 打开终端，输入以下命令，设置淘宝镜像源： npm config set registry https://registry.npm.taobao.org 输入以下命令，查看是否设置成功： npm config get registry 如果返回https://registry.npm.taobao.org/，说明配置的是淘宝镜像。 现在你就可以正常使用npm安装包了，例如： npm install express 这样就会从淘宝镜像下载express包，速度会比官方快很多。 如果你想恢复成原来的官方镜像源，只需要输入以下命令： npm config set registry https://registry.npmjs.org 方法二：通过安装cnpm 这种方法是通过安装一个名为cnpm的工具，它是一个和npm兼容的命令行工具，但是默认使用淘宝镜像源。具体步骤如下： 打开终端，输入以下命令，安装cnpm： npm install -g cnpm --registry=https://registry.npm.taobao.org 输入以下命令，查看是否安装成功： cnpm -v 如果返回cnpm的版本号，说明安装成功。 现在你就可以使用cnpm代替npm安装包了，例如： cnpm install express 这样也会从淘宝镜像下载express包。 如果你想卸载cnpm，只需要输入以下命令： cnpm install express $ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install #启动服务hexo s#停止服务ctrl + C#推送至github组合命令hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 启动对应服务，打开对应网址 安装主题 这里选择的是简洁的stellar 安装与更新 安装方法 在终端中输入： $ npm i hexo-theme-stellar 在 blog/_config.yml 文件中找到并修改： theme: stellar 可以重新启动服务查看效果 image-20230901214253946 绑定github 首先需要拥有github账号并且创建一个仓库 配置对应账户邮箱的ssh密钥 $ ssh-keygen -t rsa -C &quot;你的邮箱&quot; 输入之后一直回车直到生成结束。 image-20230901221254003 到达对应地址的id_rsa.pub文件中获取，一般是在c盘的用户你的用户文件夹的.ssh中 在GitHub setting中新建密钥并添加。 到gitbash中输入 $ git config --global user.name &quot;你的名字&quot;$ git config --global user.email &quot;你的邮箱&quot; 到主题根目录中找到_config.yml文件 在底部添加如下配置 # Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git branch: main repo: git@github.com:Ezhixuan/xuanBlog.git 在gitbash中输入以下命令安装上传插件并上传 $ cnpm install hexo-deployer-git --save$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 至此绑定成功 备份数据 由于某些原因，我们可能会需要修改配置文件等未被上传的文件，但恰巧文件丢失，github上收录的又是编译后的文件，所以对数据进行备份是有必要的。 这里选择在gitee上建立一个私有仓库来存储源码 如果使用gitee记得添加ssh #git初始化git init#创建hexo分支，用来存放源码git checkout -b hexo#git 文件添加git add .#git 提交git commit -m &quot;init&quot;#添加远程仓库git remote add origin &quot;仓库地址&quot;#push到hexo分支git push origin hexo 修改日常 依次执行 $ git add .$ git commit -m &#x27;...&#x27;$ git push origin hexo 如何恢复 当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： $ git clone -b hexo &quot;仓库地址&quot;# 在本地新拷贝的YOURNAME.github.io文件夹下通过Git bash依次执行下列指令：$ npm install hexo$ npm install$ npm install hexo-deployer-git（记得，不需要hexo init这条指令）。 部署上线 因为笔者之前已经部署上线，暂时不多赘述，后续有空会进行补充，可以自行搜索查看一些文档视频等自行部署。","tags":["hexo","学习"],"categories":["he"]},{"path":"/about/index.html","content":"种植一棵树，最好的时间是二十年前，其次是现在。Ezhixuan目前大四在读小透明，欢迎来到我的小破站，记录一些学习、生活经历。希望能够结识有趣的、志同道合的朋友。关于友链动态GitHub 关于博客 本身不善言辞，偶尔有感而发会记录下来。 学习上经常记一些笔记，但是存放位置相对零散。 一些奇奇怪怪的原因，不好意思把自己的文章放在大平台上。 戳戳戳这里添加我的联系方式微信QQ微信推荐或者添加我的WX:qq或者添加我的QQ:"},{"path":"/timeline/index.html","content":"种植一棵树，最好的时间是二十年前，其次是现在。Ezhixuan目前大四在读小透明，欢迎来到我的小破站，记录一些学习、生活经历。希望能够结识有趣的、志同道合的朋友。关于友链动态GitHub 2023 年 9 月 1 日建立小破站2023 年 9 月 3 日完善一些小功能，添加建站计时，添加分组分页，添加关于自己等2023 年 9 月 4 日添加评论组件giscus更换评论组件由giscus -&gt; waline"},{"path":"/notes/index.html","content":"记录一下"},{"path":"/friends/rss/index.html","content":""},{"path":"/friends/index.html","content":"种植一棵树，最好的时间是二十年前，其次是现在。Ezhixuan目前大四在读小透明，欢迎来到我的小破站，记录一些学习、生活经历。希望能够结识有趣的、志同道合的朋友。关于友链动态GitHub 我在等你"},{"title":"前言","path":"/wiki/leetcode/index.html","content":"此前已经一刷算法，但是有一段时间没有用了，所以觉得开启二刷，记录一下 2023 年 9 月 3 日数组"},{"title":"前言","path":"/wiki/xiaomo/index.html","content":"比较早的一个练手项目，最近准备把之前的一些项目依次整理复习一下 因为一些不可抗拒的原因，加上当时的编写方式不够成熟，所以这里只挑选一些相对有用的功能记录或重写 但是回顾之后，目前看来感觉都是比较简单正常的业务方法。 我这里就简单概括一下先，看看后续有没有时间再来优化补全。 使用redis缓存数据，cache注解简化操作，mybatisPlus简化单表查询操作、公共字段自动填充，提供阿里云短信服务发送短信验证码登录，提供密码登录，使用ThreadLocal存储用户登录信息，全局异常处理。"},{"title":"测试","path":"/wiki/stellar/index.html","content":"支持多彩标记，包括：默认 红 橙 黄 绿 青 蓝 紫 浅 深 警告 错误 一共 12 种颜色。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 &#123;% note 这&amp;nbsp;是标题 这是正文 哈哈。 %&#125; 这&nbsp;是标题这是正文 哈哈。 我是一个标题 我是一个h3标题 我是一个h1标题"},{"title":"工程初始化","path":"/wiki/xiaomo/初始化.html","content":"工程初始化 导入sql文件"},{"title":"我试试","path":"/wiki/stellar/测试.html","content":"有没有问题"},{"title":"我说一句话","path":"/wiki/stellar/我说一句话.html","content":"公道话"},{"title":"N皇后","path":"/wiki/leetcode/数组/N皇后.html","content":"题目 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。 n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 img 输入：n = 4输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]解释：如上图所示，4 皇后问题存在两个不同的解法。 输入：n = 1输出：[[&quot;Q&quot;]] 思路 首先编写大体框架 class Solution &#123; //主程序 public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; backTracking(); return res; &#125;\t//递归主体\tpublic void backTracking()&#123; //当到达最底行时对结果集进行添加 if(row == n)&#123; res.add(); return; &#125; //回溯主体 //每次向下都需要从头开始判断，所以col = 0 for(int col = 0; col &lt; n; col++)&#123; &#125; &#125;&#125; 初始化 大体框架出来后可以判断出我们至少需要定义结果集res,行数row ,以及用于收集路径且最终被结果集收集的paths。 根据题目可以知道这个paths是由若干个**.组成的并且由Q**替换 所以我们还需要初始化这个paths class Solution &#123; //定义全局的结果集res List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); //主程序 public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; //定义paths并初始化 char[][] paths = new char[n][n]; for(char[] path : paths)&#123; Arrays.fill(path,&#x27;.&#x27;); &#125; backTracking(n, 0, paths); return res; &#125;\t//递归主体\tpublic void backTracking(int n, int row, char[][] paths)&#123; //当到达最底行时对结果集进行添加 if(row == n)&#123; res.add(); return; &#125; //回溯主体 //每次向下都需要从头开始判断，所以col = 0 for(int col = 0; col &lt; n; col++)&#123; &#125; &#125;&#125; 现在关注回溯主体的编写 根据题意，我们在n皇后放下Queen时需要符合规则才放下，所以很容易想到添加时进行合法性判断,以及需要将paths有char转换为list添加进结果集 编写boolean方法isLegal判断是否合法 编写List方法arrayToList进行转换 class Solution &#123; //定义全局的结果集res List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); //主程序 public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; //定义paths并初始化 char[][] paths = new char[n][n]; for(char[] path : paths)&#123; Arrays.fill(path,&#x27;.&#x27;); &#125; backTracking(n, 0, paths); return res; &#125;\t//递归主体\tpublic void backTracking(int n, int row, char[][] paths)&#123; //当到达最底行时对结果集进行添加 if(row == n)&#123; res.add(arrayToList(paths)); return; &#125; //回溯主体 //每次向下都需要从头开始判断，所以col = 0 for(int col = 0; col &lt; n; col++)&#123; if(isLegal(row, col, paths, n))&#123; //当合法时修改Q递归并回溯 paths[row][col] = &#x27;Q&#x27;; backTracking(n, row + 1, paths); paths[row][col] = &#x27;.&#x27;; &#125; &#125; &#125; //char数组转换为List集合 public List arrayToList(char[][] paths)&#123; &#125; //判断是否合法 public boolean isLegal(int row, int col, char[][] paths, int n)&#123; &#125;&#125; 编写数组转换方法 //char数组转换为List集合public List arrayToList(char[][] paths)&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(char[] path : paths)&#123; list.add(String.copyValueOf(path)); &#125; return list;&#125; 编写合法性判断 n皇后需要满足 不同行 不同列 不同对角线 //判断是否合法 //只需要判断之前的值不需要判断之后的值，因为添加值是从前往后添加的 //不能同行 col-- //补充：因为每次添加后会进入下一列，且后续会进行回溯操作，所以不会出现同行情况 //不能同列 row-- //不能同对角线 row-- &amp;&amp; col-- //补充：此时判断为45°对角线，此外还存在135°对角线 //所以还需要判断 row-- &amp;&amp; col++ 的情况 public boolean isLegal(int row, int col, char[][] paths, int n)&#123; //判断是否同列 for(int i = 0; i &lt; n; i++)&#123; if(paths[i][col] == &#x27;Q&#x27;) return false; &#125; //判断45°对角线 for(int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--)&#123; if(paths[i][j] == &#x27;Q&#x27;) return false; &#125; //判断135°对角线 for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt;= n - 1; i--, j++)&#123; if(paths[i][j] == &#x27;Q&#x27;) return false; &#125; return true; &#125;&#125; 以上，得出最后结果 class Solution &#123; //定义全局的结果集res List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); //主程序 public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; //定义paths并初始化 char[][] paths = new char[n][n]; for(char[] path : paths)&#123; Arrays.fill(path,&#x27;.&#x27;); &#125; backTracking(n, 0, paths); return res; &#125;\t//递归主体\tpublic void backTracking(int n, int row, char[][] paths)&#123; //当到达最底行时对结果集进行添加 if(row == n)&#123; res.add(arrayToList(paths)); return; &#125; //回溯主体 //每次向下都需要从头开始判断，所以col = 0 for(int col = 0; col &lt; n; col++)&#123; if(isLegal(row, col, paths, n))&#123; //当合法时修改Q递归并回溯 paths[row][col] = &#x27;Q&#x27;; backTracking(n, row + 1, paths); paths[row][col] = &#x27;.&#x27;; &#125; &#125; &#125; //char数组转换为List集合 public List arrayToList(char[][] paths)&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(char[] path : paths)&#123; list.add(String.copyValueOf(path)); &#125; return list; &#125; //判断是否合法 //只需要判断之前的值不需要判断之后的值，因为添加值是从前往后添加的 //不能同行 col-- //补充：因为每次添加后会进入下一列，且后续会进行回溯操作，所以不会出现同行情况 //不能同列 row-- //不能同对角线 row-- &amp;&amp; col-- //补充：此时判断为45°对角线，此外还存在135°对角线 //所以还需要判断 row-- &amp;&amp; col++ 的情况 public boolean isLegal(int row, int col, char[][] paths, int n)&#123; //判断是否同列 for(int i = 0; i &lt; n; i++)&#123; if(paths[i][col] == &#x27;Q&#x27;) return false; &#125; //判断45°对角线 for(int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--)&#123; if(paths[i][j] == &#x27;Q&#x27;) return false; &#125; //判断135°对角线 for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt;= n - 1; i--, j++)&#123; if(paths[i][j] == &#x27;Q&#x27;) return false; &#125; return true; &#125;&#125;"},{"title":"二分查找","path":"/wiki/leetcode/数组/二分查找.html","content":"关于二分查找 二分查找法（Binary Search）是一种在有序数组中查找目标元素的高效算法。它的基本思想是通过比较目标值和数组中间元素的大小关系，将搜索范围缩小一半，直到找到目标值或确定目标值不存在。 以下是二分查找法的基本步骤： 确定搜索范围：在开始查找之前，确定要在哪个有序数组中进行查找。通常，这个数组会首先进行排序。 初始化指针：设置两个指针，一个指向搜索范围的起始位置（通常为数组的第一个元素），另一个指向搜索范围的结束位置（通常为数组的最后一个元素）。 迭代查找：在每一次迭代中，计算中间元素的索引，即指针的中间位置。然后，将目标值与中间元素进行比较。 如果目标值等于中间元素，则找到目标值，返回其索引。 如果目标值小于中间元素，则目标值可能在中间元素的左侧，将结束指针移动到中间元素的前一个位置。 如果目标值大于中间元素，则目标值可能在中间元素的右侧，将起始指针移动到中间元素的后一个位置。 更新搜索范围：根据比较的结果，更新搜索范围，将搜索范围缩小一半。 重复迭代：重复执行步骤 3 和步骤 4，直到找到目标值或确定目标值不存在。如果起始指针大于结束指针，则表示目标值不存在于数组中。 二分查找法的时间复杂度为 O(log n)，其中 n 是数组的大小。由于每次迭代都将搜索范围缩小一半，因此它的查找效率非常高。 需要注意的是，二分查找法要求数组是有序的。如果数组无序，需要先对其进行排序，然后再进行二分查找。 二分查找 704. 二分查找 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 解题 class Solution &#123; public int search(int[] nums, int target) &#123; // 递增的整型数组nums中查找目标值target，找到返回下标，没找到返回-1 // 1. 初始化变量 左右指针 int left = 0, right = nums.length - 1; // 2. 确定循环条件 [left, right],此处right可取，所以选择&lt;= while (left &lt;= right)&#123; // 3. 确定中值 int mid = left + (right - left) / 2; // 防止下标越界 if(nums[mid] == target)&#123; return mid; &#125;else if (nums[mid] &lt; target)&#123; // 中值小于目标值 更新左指针 left = mid + 1; // mid处已判断，无需重复处理 &#125;else&#123; // 中值大于目标值 更新右指针 right = mid - 1; &#125; &#125; // 3.1 没找到返回-1 return -1; &#125;&#125; 个人看法 做的比较多已经算是非常熟练了，主要在于确定循环条件以及更新左右指针的处理 当区间为[left, right]左闭右闭时，因为左右区间都为有效区间，所以循环时选择 &lt;= 当区间为[left, right)左闭右开或(left, right](不常见)时，因为存在无效区间，所以循环时不选择添加 = 对于左右指针更新的处理，也是去判断mid值是否已经判断过，就不多赘述了"},{"title":"有序数组的平方","path":"/wiki/leetcode/数组/有序数组的平方.html","content":"有序数组的平方 977. 有序数组的平方 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 1： 输入：nums = [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100] 示例 2： 输入：nums = [-7,-3,2,3,11]输出：[4,9,9,49,121] 提示： 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 已按 非递减顺序 排序 进阶： 请你设计时间复杂度为 O(n) 的算法解决本问题 解题 class Solution &#123; public int[] sortedSquares(int[] nums) &#123; // 非递减排序的整数数组nums， 各个数据分别平方组成新递增数组 // 明确一个观点， 对于一个非递减的整数数组，它的最小值在哪不确定，因为可能存在负数，但是它的最大值一定出现在头或尾 // 我们可以设置双指针指向头尾两侧，循环比较大小，选择大的一方平方插入新数组的最尾部并更新对应指针位置 // 1. 初始化数据 头尾指针 int head = 0, tail = nums.length - 1; int[] res = new int[nums.length]; int resIndex = res.length - 1; // 2. 确定循环条件 判断头尾是否可以取等? 因为我们是从两端依次向中间靠拢， // 总会出现 head++ == tail 或者 tail-- == head的情况，而此时则是结束的时候 while (head &lt;= tail)&#123; int max = nums[head] * nums[head] &gt;= nums[tail] * nums[tail] ?(int) Math.pow(nums[head++], 2) : (int) Math.pow(nums[tail--], 2); res[resIndex--] = max; &#125; // 3. 返回结果 return res; &#125;&#125; 个人看法 比较简单的一题，确定最大值依次由高向低靠拢即可。 唯一的难点是对于循环条件的判断，需要辨别究竟能不能取等。"},{"title":"关于数组","path":"/wiki/leetcode/数组/关于数组.html","content":"什么是数组 数组是非常基础的数据结构 数组（array）是一种最简单的复合数据类型，它是有序数据的集合，数组中的每个元素具有相同的数据类型，可以用一个统一的数组名和不同的下标来确定数组中唯一的元素。根据数组的维度，可以将其分为一维数组、二维数组和多维数组等。 数组是一个存于连续内存空间中的相同类型数据的集合。 数组可以方便的通过下标索引的方式获取到对应下标的数据 算法通关数组 需要注意的是 数组的下标都是从0开始 数组内存空间的地址是连续的 数组的优点 相比其它类型的数据结构，数组有以下优点： 数组允许随机访问数组元素，每个存储在数组中的元素可以通过直接访问其索引来使用 数组对存储友好。这意味着在某些情况下，由于数组的线性存储方式，代码的执行顺序会大大提高 数组的缺点 声明数组时，需要指定数组的长度。初始声明数组的长度过长或过短，在移动数组元素时都会有导致效率变低 插入和删除元素之后保持数组的连续性代价是昂贵的，因为有可能需要重新排列所有数组元素。 参考资料：代码随想录 (programmercarl.com)"},{"title":"移除元素","path":"/wiki/leetcode/数组/移除元素.html","content":"移除元素 27. 移除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 示例 1： 输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2： 输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 50 0 &lt;= val &lt;= 100 解题 class Solution &#123; public int removeElement(int[] nums, int val) &#123; // 原地移除数组中数值等于val的元素，返回移除后新数组的新长度，O(1)的额外空间, // 快慢指针 快指针自增遍历，当且仅当遇到！=val的元素时更新慢指针前进 // 1. 初始化变量 int fast = 0, slow = 0; for(;fast &lt; nums.length; fast++)&#123; if (nums[fast] != val)&#123; // 当且仅当遇到！=val的元素时更新慢指针前进 nums[slow] = nums[fast]; slow++; &#125; &#125; // 2. 返回新数组长度 return slow; &#125;&#125; 个人看法 也是比较基础的一个双指针的问题，这里使用的是快慢指针，因为我们需要原地更新数组。 快指针去寻找符合条件的数据传递给慢指针更新数组即可。"},{"title":"螺旋矩阵II","path":"/wiki/leetcode/数组/螺旋矩阵II.html","content":"螺旋矩阵 59. 螺旋矩阵 II 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 示例 1： img 输入：n = 3输出：[[1,2,3],[8,9,4],[7,6,5]] 示例 2： 输入：n = 1输出：[[1]] 提示： 1 &lt;= n &lt;= 20 解题 class Solution &#123; public int[][] generateMatrix(int n) &#123; // 正整数n 生成 1 -&gt; n * n 的元素按顺时针螺旋排序构成 n * n 的正方形矩阵 // 1. 初始化变量 记录下标位置,起始点 结果数组, 循环圈数 int x = 0, y = 0, index = 1, startX = 0, startY = 0; int res[][] = new int[n][n]; int loop = 0; // 2. 确定循环条件 while (loop++ &lt; n / 2 ) &#123; // 3.1 从左 -&gt; 右 for(y = startY; y &lt; n - loop; y ++)&#123; res[startX][y] = index++; &#125; // 3.2 从上 -&gt; 下 for(x = startX; x &lt; n - loop; x ++)&#123; res[x][y] = index++; &#125; // 3.3 从右 -&gt; 左 for(; y &gt; startY; y --)&#123; res[x][y] = index++; &#125; // 3.4 从下 -&gt; 上 for(; x &gt; startX; x--)&#123; res[x][y] = index++; &#125; startX++; startY++; &#125; // 4. 奇数特殊处理中心 if (n % 2 == 1)&#123; res[startX][startY] = index; &#125; return res; &#125;&#125; image-20230904130209025 个人看法 一道中等难度的题目，对于圈数的认知选择非常关键，是否有将单独点排除出圈单独处理，是在我看来本题的难点。 正确的圈数认知能够帮助我们确定循环条件以及步数。 不建议像我一样选择x，y作为坐标变量名思维惯性可能会套入坐标系导致做题时误导成横纵坐标 解题思路 关于起始点与终止点 按顺序依次处理的时候，需要明确上下左右的起始点和终点在哪 举个例子 img 就该图而言，向左起点如果是1，终点应该是2，而不是3 否则对于向下来说，起点是4，终点是5， 对于向右来说，起点是6，终点是7， 对于向上来说，起点是8，终点也是8。 这样看来，我们四次的步长向左是3步，向下和向右是2步，向上是1步，这样是不好编写的。 再看这个有n=4构成的正方形矩阵 1 2 3 4 12 13 14 5 11 16 15 6 10 9 8 7 第一次循环的步数推得为3步。第二次循环的步数推得为1步 起始步长为n-1步即3步，第二次步长为n-2步即1步 可以看出 n-1中 1 为第一次循环， n-2 中2为第二次循环 所以可以推断出对于步数的处理应该是 n - loop 圈数判断 我们需要大致正确的找到循环圈数的规律。 n = 1 -&gt; 1 圈数为1 n = 2 -&gt; 1 2 4 3 圈数为1 n = 3 -&gt; 1 2 3 8 9 4 7 6 5 圈数为2 n = 4 -&gt; 1 2 3 4 12 13 14 5 11 16 15 6 10 9 8 7 圈数为2 n = 5 -&gt; 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 圈数为3 n = 6 推断 为3 n = 7 推断 为 4 n = 8 推断为 4 可得12-1 34-2 56-3 78-4 不难推断循环旋转圈数应该是 (n + 1)/2 向下取整 但是如果选择以该圈数作为循环其实是有问题的，因为我们一次循环会经历上下左右的处理，但是在n为奇数时我们会发现在中间是只有一个小块而不是一圈，如果将此作为一圈得出的结果显然是违背题意的。 所以我们忽略只有单块的层级可以得出以下结论 1-0 23-1 45 -2 67-3 89-4 由此推断出循环的圈数应该是 n/2 向下取整 综上所述，我们可以知道。 对于正整数n 生成 1 -&gt; n * n 的元素按顺时针螺旋排序构成 n * n 的正方形矩阵 需要进行 n / 2 次循环 每次循环的步数为 n - loop"},{"title":"长度最小的子数组","path":"/wiki/leetcode/数组/长度最小的子数组.html","content":"长度最小的子数组 209. 长度最小的子数组 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度**。**如果不存在符合条件的子数组，返回 0 。 示例 1： 输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2： 输入：target = 4, nums = [1,4,4]输出：1 示例 3： 输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0 提示： 1 &lt;= target &lt;= 109 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105 进阶： 如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。 解法 class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; // 找出数组中和 &gt;= target 的长度最小的 连续的 子数组，返回长度，如果不存在返回0 // 我这里只想到应该是O(n)的解法，使用滑动窗口，最差的情况应该是遍历完集合，后续尝试看看能不能写出O(nlog(n))的解法 // 1. 初始化变量 左右窗口指针,返回结果(结果设置最大整数方便后续判断)，窗口值 int left = 0, right = 0, res = Integer.MAX_VALUE, sum = 0; // 2. 确定循环条件 这里选择右指针小于数组长度时循环，也就是直到右指针走出数组循环结束 while (right &lt; nums.length )&#123; sum += nums[right++]; while(sum &gt;= target )&#123; // 当窗口值大于等于target时，收集结果值，并且收缩窗口，窗口右滑，因为可能删去一个还是大于，所以用while保证判断结束后一定小于target res = res &lt; right - left ? res : right - left; sum -= nums[left++]; &#125; &#125; // 3. 返回结果 return res == Integer.MAX_VALUE ? 0 : res; &#125;&#125; 个人看法 一道中等难度的题目，个人认为主要在于res的选值如果赋予0为初始值的话后续结果不好判断 再就是收集结果的时候对于if和while的选择很关键。"},{"title":"两两交换链表中的节点","path":"/wiki/leetcode/链表/两两交换链表中的节点 .html","content":"两两交换链表中的节点 24. 两两交换链表中的节点 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 示例 1： img 输入：head = [1,2,3,4]输出：[2,1,4,3] 示例 2： 输入：head = []输出：[] 示例 3： 输入：head = [1]输出：[1] 提示： 链表中节点的数目在范围 [0, 100] 内 0 &lt;= Node.val &lt;= 100 解题思路 根据三个示例可以分析出一些问题， img 示例一我们可以看出，在正常交换的情况下，结点的数量应该需要保证是偶数个，否则1-》2-》3-》4 交换过后应该是 2-》3-》4-》1显然不符合示例。所以1和2交换过后是3和4交换。 再到返回结果来说，我们需要返回的是头结点，但是显然在交换过程中指针是在不断变化的，所以我们需要确定一个不变的指针去记录头结点的情况，自然能够想到定义一个dummy节点，dummy的next指向头结点，我们在最后返回结果的时候，只需要返回dummy.next即可。 回到交换，因为是两两交换，拿1和2举例子，我们只需要确定curr = 1，curr.next != null ，就可以进行交换了，所以可以确定的一个条件是 curr.next != null。 再到交换的过程，拿示例1举例子，假如我们先将2指向1，那就会失去2与3的链接，1就无法知道自己要指向哪，所以优先将1.next -&gt; 2.next ，再将 2.next -&gt; 1 这样才不会出现断联的现象。 但是仔细思考会出现一个问题，此时dummy.next 指向的是 1，但是2指向后却没有续联，dummy.next指向的仍然是1，所以我们或许还需要一个参数prev来保证每(两两)个之间的续联。 示例二我们可以看出当head节点为空时，直接返回，所以curr ！= null 示例三我们可以看出当head.next 为空，没必要继续判断，即 curr.next != null。 解题 class Solution &#123; public ListNode swapPairs(ListNode head) &#123; // 提供一个链表，两两交换相邻节点，最后返回头结点 // 1. 初始化变量 dummy节点，curr节点，prev节点 ListNode dummy = new ListNode(); dummy.next = head; ListNode curr = head; ListNode prev = dummy; // 2. 确定循环条件 while (curr != null &amp;&amp; curr.next != null)&#123; // 3. 执行交换 ListNode temp = curr.next; curr.next = temp.next; temp.next = curr; prev.next = temp; // 4. 向前推进 prev = curr; curr = curr.next; &#125; // 4. 返回结果 return dummy.next; &#125;&#125; 个人看法 第一次把解题思路打出来，可能比较乱，但是应该是比较方便理解，也更有利于我自己后续复习使用。我个人认为把解题思路打出来或者写出来是一个非常不错的方法，因为思绪是比较零散跳动的，有时候突然想到一个点没有记录下来后续可能就忘了。 回想起之前刷题的时候，各种捋思路，感觉非常通顺，但是实现的时候到处都是问题，每次编写完自己也没个底，但刷题就是这样的，没有谁能百分百编写出来就通过，主要在于锻炼自己的思维，继续加油吧。 回到本题，这题的解法还是比较多的，因为是循环做同一件事，所以也可以使用递归解决，不过个人看来在大多数对链表进行删除，添加，交换的情况，使用虚拟头结点的方式都是不错的解法。"},{"title":"关于链表","path":"/wiki/leetcode/链表/关于链表.html","content":"关于链表 链表（Linked List）是一种常用的数据结构，用于存储和组织一系列的元素。它由一组节点（Node）组成，每个节点包含两部分：数据部分（存储元素的值）和指针部分（指向下一个节点的指针）。节点之间通过指针连接，形成一个链式结构。 每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。 链表的入口节点称为链表的头结点也就是head。 如图所示： 链表1 链表的特点 相比于数组，链表的一个主要特点是插入和删除元素的操作效率较高，而访问元素的效率较低。这是因为链表的插入和删除只需修改节点指针的指向，而不需要像数组那样移动大量元素。然而，由于链表中的节点并非连续存储，而是通过指针相连，所以在查找某个元素时需要从链表头开始逐个遍历节点，因此访问元素的效率较低。 链表在许多算法和数据结构中有广泛应用，例如堆栈（Stack）、队列（Queue）等。在实际编程中，链表可以使用面向对象的方式进行实现。每个节点可以定义为一个类，其中包含数据部分和指向下一个节点的指针，通过节点之间的链接，可以构建出一个完整的链表结构。 链表的类型 单链表 双链表 循环链表 双链表 单链表中的指针域只能指向节点的下一个节点。 双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。 双链表 既可以向前查询也可以向后查询。 如图所示： 链表2 #循环链表 循环链表（Circular Linked List）。循环链表与普通链表类似，不同之处在于循环链表的最后一个节点指向第一个节点，形成一个循环的环状结构。 在循环链表中，每个节点仍然包含数据部分和指向下一个节点的指针。与单向链表类似，循环链表的节点可以通过指针相互连接。不同之处是，循环链表的最后一个节点的指针指向链表的头节点，而头节点的指针依然指向下一个节点。 循环链表的一个优点是可以方便地遍历整个链表，只需从头节点开始，一直遍历到头节点为止。另外，循环链表也可以在实际应用中用于解决一些特定的问题，比如循环队列等。 循环链表可以用来解决约瑟夫环问题。 链表4 链表的存储方式 了解完链表的类型，再来说一说链表在内存中的存储方式。 数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。 链表是通过指针域的指针链接在内存中各个节点。 所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。 如图所示： 链表3 这个链表起始节点为2， 终止节点为7， 各个节点分布在内存的不同地址空间上，通过指针串联在一起。 链表的定义 单链表 class ListNode&#123;\tint val; ListNode next;\tpublic ListNode()&#123;&#125;\tpublic ListNode(int val)&#123; this.val = val;\t&#125;\tpublic ListNode(int val, ListNode next)&#123; this.val = val; this.next = next;\t&#125;&#125; 双链表 class ListNode&#123; int val; ListNode prev; ListNode next; public ListNode(int val)&#123; this.val = val; this.prev = null; this.next = null; &#125;&#125;class DoublyLinkedList&#123; ListNode head; public DoublyLinkedList()&#123; this.head = null; &#125; public void insert(int val)&#123; ListNode newNode = new ListNode(val); if(head == null)&#123; head = newNode; &#125;else&#123; ListNode currentNode = head; while(currentNode.next != null)&#123; currentNode = currentNode.next; &#125; currentNode.next = newNode; newNode.prev = currentNode; &#125; &#125;&#125; 循环链表 class ListNode &#123; int val; ListNode next; public ListNode(int val) &#123; this.val = val; this.next = null; &#125;&#125;class CircularLinkedList &#123; ListNode head; public CircularLinkedList() &#123; this.head = null; &#125; public void insert(int val) &#123; ListNode newNode = new ListNode(data); if (head == null) &#123; head = newNode; newNode.next = head; &#125; else &#123; ListNode currentNode = head; while (currentNode.next != head) &#123; currentNode = currentNode.next; &#125; currentNode.next = newNode; newNode.next = head; &#125; &#125;&#125; 链表操作 删除节点 只需要将该节点上一个写点的next指针指向该写点的下一个节点就可以了。 在java语音中有垃圾回收机制，会自动处理。 添加节点 选择在某一节点处添加指针，将该节点的next节点指向添加节点，将添加节点的指针指向该节点的下一节点。 性能分析 再把链表的特性和数组的特性进行一个对比，如图所示： 链表-链表与数据性能对比 数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。 链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。 参考资料：代码随想录 (programmercarl.com)"},{"title":"删除链表的倒数第 N 个结点","path":"/wiki/leetcode/链表/删除链表的倒数第n个节点.html","content":"删除链表的倒数第 N 个结点 19. 删除链表的倒数第 N 个结点 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例 1： img 输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5] 示例 2： 输入：head = [1], n = 1输出：[] 示例 3： 输入：head = [1,2], n = 1输出：[1] 提示： 链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz **进阶：**你能尝试使用一趟扫描实现吗？ 解题思路 要求解倒数第n个节点，我首先想到的是采用递归，当 curr.next == null 时返回，并在返回后进行 n–, 当n == 0 时，表示到达了倒数第n + 1 个节点，也就是倒数第n个节点的前一个节点，此时要进行删除就很简单了。 我很快就写出了初版代码 class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; // 给定一个链表，删除倒数第n个节点，最后返回头结点 // 1. 终止判断，到达末尾节点 if(head.next == null) return head; head.next = removeNthFromEnd(head.next, n); n--; if (n == 0 &amp;&amp; head.next != null)&#123; // 到达需要被删除的节点的前一个节点 // 2. 删除 head.next = head.next.next; &#125; // 3. 返回 return head; &#125;&#125; 很显然这是有问题的 假设n=2，则每次递归时n都是2，不管怎么减，返回后到达新的区域n仍是当前区域的2，我们减的是上一个区域的n。 确定问题后就好办了。我们只需要另设一个方法返回int值，当到达末尾时返回1，直到count值==n值的时候，就到达倒数第n + 1 个节点。 此外，为了应对[]这种特殊情况，因为当head == null 时，我们无法到达head.next 所以在选择curr节点的时候，选择dummy结点进行判断，这样当进入remove方法时就会直接被终止条件剔除。从而正常通过。 解题 - 递归 class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; // 给定一个链表，删除倒数第n个节点，最后返回头结点 ListNode dummy = new ListNode(); dummy.next = head; remove(dummy, n); return dummy.next; &#125; public int remove(ListNode curr, int n)&#123; // 1. 终止判断，到达末尾节点 if(curr.next == null) return 1; int count = remove(curr.next, n); if (n == count)&#123; // 到达需要被删除的节点的前一个节点 // 2. 删除 curr.next = curr.next.next; &#125; // 3. 返回 return count + 1; &#125;&#125; 快慢指针解法 仔细想来，在数组中我们层用过一个解法可以使得两点之间可以有一定距离的，就是双指针法，双指针法常用于滑动窗口，快慢指针，二分等问题，这里使用的是快慢指针。 根据题意说明，需要删除倒数第n个节点，我们只需要定义快慢指针，在初始化时，快指针比慢指针多走n步，然后一起向前遍历，当快指针到达终点时，慢指针恰好到达倒数第n+1个指针，然后我们直接操作慢指针即可。 下面是代码实现 解题 - 快慢指针 class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; // 给定一个链表，删除倒数第n个节点，最后返回头结点 // 使用快慢指针 // 1. 初始化变量 快慢指针,dummy指针 ListNode dummy = new ListNode(); dummy.next = head; ListNode fast = dummy; ListNode slow = dummy; // 2.初始化快指针 while(n-- != 0)&#123; fast = fast.next; &#125; // 3. 向前推进 while (fast.next != null)&#123; fast = fast.next; slow = slow.next; &#125; // 4. 执行删除 slow.next = slow.next.next; // 5. 返回 return dummy.next; &#125;&#125; 个人看法 依旧是离不开dummy指针，dummy指针在处理链表时真的很好用。题目本身难度并不大，细心细心再细心。"},{"title":"反转链表","path":"/wiki/leetcode/链表/反转链表.html","content":"反转链表 206. 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： img 输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 示例 2： img 输入：head = [1,2]输出：[2,1] 示例 3： 输入：head = []输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 &lt;= Node.val &lt;= 5000 解题 递归 class Solution &#123; public ListNode reverseList(ListNode head) &#123; // 给定单链表的头结点，反转链表 if (head == null) return null; // 边界判定 if(head.next == null)&#123; // 当结点的下一个节点为空时，表示到达最底部 return head; &#125; ListNode temp = reverseList(head.next); // 头结点 head.next.next = head; head.next = null; return temp; &#125;&#125; 双指针 class Solution &#123; public ListNode reverseList(ListNode head) &#123; // 1. 初始化变量 前指针，当前指针，临时指针 ListNode prev = null; ListNode curr = head; ListNode temp = null; while(curr != null)&#123; temp = curr.next; curr.next = prev; prev = curr; curr = temp; &#125; return prev; &#125;&#125; 个人看法 比较经典的链表题，第一反应就是递归，但是一开始选择了使用返回的头结点去处理导致后续无法拿到头结点，卡了一会才解决。"},{"title":"移除链表元素","path":"/wiki/leetcode/链表/移除链表元素.html","content":"移除链表元素 203. 移除链表元素 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 示例 1： img 输入：head = [1,2,6,3,4,5,6], val = 6输出：[1,2,3,4,5] 示例 2： 输入：head = [], val = 1输出：[] 示例 3： 输入：head = [7,7,7,7], val = 7输出：[] 提示： 列表中的节点数目在范围 [0, 104] 内 1 &lt;= Node.val &lt;= 50 0 &lt;= val &lt;= 50 解题 /** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; if (head == null) &#123; return head; &#125; // 1. 初始化变量，虚拟节点 ListNode dummy = new ListNode(-1, head); ListNode prev = dummy; ListNode curr = head; // 2. 遍历链表 while(curr != null)&#123; // 判断当前节点的值是否是目标值呢 if (curr.val == val)&#123; prev.next = curr.next; &#125;else &#123; prev = curr; &#125; curr = curr.next; &#125; // 3. 返回结果 return dummy.next; &#125;&#125; 个人看法 使用虚拟节点占位能够有效方便的去处理链表的添加删除问题。"},{"title":"设计链表","path":"/wiki/leetcode/链表/设计链表.html","content":"设计链表 707. 设计链表 你可以选择使用单链表或者双链表，设计并实现自己的链表。 单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。 如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。 实现 MyLinkedList 类： MyLinkedList() 初始化 MyLinkedList 对象。 int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。 void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。 void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。 void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。 void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。 示例： 输入[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;][[], [1], [3], [1, 2], [1], [1], [1]]输出[null, null, null, null, 2, null, 3]解释MyLinkedList myLinkedList = new MyLinkedList();myLinkedList.addAtHead(1);myLinkedList.addAtTail(3);myLinkedList.addAtIndex(1, 2); // 链表变为 1-&gt;2-&gt;3myLinkedList.get(1); // 返回 2myLinkedList.deleteAtIndex(1); // 现在，链表变为 1-&gt;3myLinkedList.get(1); // 返回 3 提示： 0 &lt;= index, val &lt;= 1000 请不要使用内置的 LinkedList 库。 调用 get、addAtHead、addAtTail、addAtIndex 和 deleteAtIndex 的次数不超过 2000 。 解题 class ListNode&#123; int val; ListNode next; public ListNode()&#123;&#125; public ListNode(int val)&#123; this.val = val; this.next = null; &#125;&#125;class MyLinkedList &#123; ListNode dummy; int size; public MyLinkedList() &#123; size = 0; // 在链表中，对于新增和删除操作，一般需要找到被操作节点的前一个节点 // 初始化时选择将头结点初始成一个dummy节点，后续操作index + 1 dummy = new ListNode(-1); &#125; public int get(int index) &#123; // 对于获取，我们需要取得index后一位 // 1. 数据校验 if (index &lt; 0 || index &gt;= size)&#123; return -1; &#125; ListNode curr = dummy; for(int i = 0; i &lt; index; i++)&#123; curr = curr.next; &#125; return curr.next.val; &#125; public void addAtHead(int val) &#123; // 添加到头部 也就是index = 0 的位置 addAtIndex(0, val); &#125; public void addAtTail(int val) &#123; // 添加到尾部 也就是index = size 的位置 addAtIndex(size, val); &#125; public void addAtIndex(int index, int val) &#123; // 指定位置添加 // 1. 数据校验 if (index &lt; 0)&#123; index = 0; &#125; if (index &gt; size)&#123; return; &#125; // 2. 长度 + 1 size++; // 3. 找对应位置 ListNode prev = dummy; for(int i = 0; i &lt; index; i++)&#123; prev = prev.next; &#125; // 4. 执行添加 ListNode newNode = new ListNode(val); newNode.next = prev.next; prev.next = newNode; &#125; public void deleteAtIndex(int index) &#123; // 删除指定位置 // 1. 数据校验 if (index &lt; 0 || index &gt;= size)&#123; return; &#125; // 2. 长度 - 1 size--; if (index == 0)&#123; dummy = dummy.next; return; &#125; // 3. 找对应位置 ListNode prev = dummy; for (int i = 0; i &lt; index; i++)&#123; prev = prev.next; &#125; prev.next = prev.next.next; &#125;&#125; image-20230905201426319 个人看法 主要难点在于对MyLinkedList的初始化，我们在设置MyLinkedList时选择定义了一个ListNode类型的dummy作为虚拟节点，这样方便我们在后续的增删链表会更加方便，相应的在get的处理上就需要多取一个结点，只要搞定这点，其他都是基础的链表处理。双链表的思路基本大差不差，处理好前后指针的关系即可。 解题思路 在选择使用单链表解题后，基本是按照通过定位被操作节点的上一节点，来对被操作节点进行处理。"},{"title":"修改分类","path":"/wiki/xiaomo/后台管理端/修改分类-04.html","content":"修改分类 接口地址:/admin/category 请求方式:PUT 请求数据类型:application/json 响应数据类型:*/* 接口描述: 请求示例: &#123; &quot;id&quot;: 0, &quot;name&quot;: &quot;&quot;, &quot;sort&quot;: 0, &quot;type&quot;: 0&#125; 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema categoryDTO categoryDTO body true 分类DTO 分类DTO id 主键 false integer(int64) name 分类名称 false string sort 排序 false integer(int32) type 类型 1 菜品分类 2 套餐分类 false integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«string» 201 Created 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &quot;&quot;,\t&quot;msg&quot;: &quot;&quot;&#125; controller /** * 修改分类 * @param categoryDTO * @return */ @PutMapping @ApiOperation(&quot;修改分类&quot;) public Result&lt;String&gt; update(@RequestBody CategoryDTO categoryDTO)&#123; log.info(&quot;修改分类：&#123;&#125;&quot;, categoryDTO); return categoryService.update(categoryDTO); &#125; Impl /** * 修改分类 * * @param categoryDTO * @return */ @Override public Result&lt;String&gt; update(CategoryDTO categoryDTO) &#123; // 1. 校验参数 if (!categoryDTO.check()) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 初始化参数 Category category = new Category(); BeanUtils.copyProperties(categoryDTO, category); category.setUpdateTime(LocalDateTime.now()); category.setUpdateUser(BaseContext.getCurrentId()); // 3. 修改 updateById(category); return Result.success(); &#125;"},{"title":"编辑员工信息","path":"/wiki/xiaomo/后台管理端/修改员工信息.html","content":"编辑员工信息 接口地址:/admin/employee 请求方式:PUT 请求数据类型:application/json 响应数据类型:*/* 接口描述: 请求示例: &#123; &quot;id&quot;: 0, &quot;idNumber&quot;: &quot;&quot;, &quot;name&quot;: &quot;&quot;, &quot;phone&quot;: &quot;&quot;, &quot;sex&quot;: &quot;&quot;, &quot;username&quot;: &quot;&quot;&#125; 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema employeeDTO employeeDTO body true 员工注册信息 员工注册信息 id 员工id false integer(int64) idNumber 身份证号 true string name 姓名 true string phone 手机号 true string sex 性别 true string username 用户名 true string 响应状态: 状态码 说明 schema 200 OK Result«string» 201 Created 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &quot;&quot;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @ApiOperation(&quot;编辑员工信息&quot;) @PutMapping() public Result&lt;String&gt; updateEmpInfo(@RequestBody EmployeeDTO employeeDTO)&#123; return employeeService.updateEmpInfo(employeeDTO); &#125; Impl /** * 编辑员工信息 * * @param employeeDTO * @return */@Overridepublic Result&lt;String&gt; updateEmpInfo(EmployeeDTO employeeDTO) &#123; // 1. 数据校验 boolean check = employeeDTO.check(); if (!check)&#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 初始化 Employee employee = new Employee(); BeanUtils.copyProperties(employeeDTO, employee); // 3. 更新数据 updateById(employee); // 4. 返回结果 return Result.success();&#125; 一些问题 在代码编写时我发现这样一段代码是可以复用的，因为我们在检查时总是需要去这样使用。 // 1. 数据校验 if (employeeDTO == null || StringUtils.isBlank(employeeDTO.getName()) || StringUtils.isBlank(employeeDTO.getUsername()) || StringUtils.isBlank(employeeDTO.getSex()) || StringUtils.isBlank(employeeDTO.getPhone()) || StringUtils.isBlank(employeeDTO.getIdNumber())) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; 所以修改为 @Data@ApiModel(value = &quot;员工注册信息&quot;)public class EmployeeDTO implements Serializable &#123; @ApiModelProperty(value = &quot;员工id&quot;) private Long id; @ApiModelProperty(value = &quot;用户名&quot; , required = true) private String username; @ApiModelProperty(value = &quot;姓名&quot; , required = true) private String name; @ApiModelProperty(value = &quot;手机号&quot; , required = true) private String phone; @ApiModelProperty(value = &quot;性别&quot; , required = true) private String sex; @ApiModelProperty(value = &quot;身份证号&quot; , required = true) private String idNumber; public boolean check()&#123; if (this == null || StringUtils.isBlank(this.getName()) || StringUtils.isBlank(this.getUsername()) || StringUtils.isBlank(this.getSex()) || StringUtils.isBlank(this.getPhone()) || StringUtils.isBlank(this.getIdNumber())) &#123; return false; &#125; return true; &#125;&#125; // 1. 数据校验 boolean check = employeeDTO.check(); if (!check)&#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125;"},{"title":"修改员工密码","path":"/wiki/xiaomo/后台管理端/修改员工密码.html","content":"修改员工密码 接口地址:/admin/employee/editPassword 请求方式:PUT 请求数据类型:application/json 响应数据类型:*/* 接口描述: 请求示例: &#123; &quot;newPassword&quot;: &quot;&quot;, &quot;oldPassword&quot;: &quot;&quot;&#125; 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema employeePasswordDTO employeePasswordDTO body true 修改密码 修改密码 newPassword 新密码 false string oldPassword 旧密码 false string 响应状态: 状态码 说明 schema 200 OK Result«string» 201 Created 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &quot;&quot;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @ApiOperation(&quot;修改员工密码&quot;) @PutMapping(&quot;/editPassword&quot;) public Result&lt;String&gt; editPassword(@RequestBody EmployeePasswordDTO employeePasswordDTO)&#123; return employeeService.editPassword(employeePasswordDTO); &#125; Impl /** * 修改员工密码 * * @param employeePasswordDTO * @return */@Overridepublic Result&lt;String&gt; editPassword(EmployeePasswordDTO employeePasswordDTO) &#123; // 1. 参数校验 if (employeePasswordDTO == null || StringUtils.isBlank(employeePasswordDTO.getOldPassword()) || StringUtils.isBlank(employeePasswordDTO.getNewPassword())) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 验证旧密码是否正确 Employee employee = getById(BaseContext.getCurrentId()); if (! employee.getPassword().equals(DigestUtils.md5DigestAsHex((employeePasswordDTO.getOldPassword() + employee.getSalt()).getBytes())))&#123; // 旧密码错了 throw new PasswordErrorException(MessageConstant.PASSWORD_ERROR); &#125; // 3. 保存新密码 String password = DigestUtils.md5DigestAsHex((employeePasswordDTO.getNewPassword() + employee.getSalt()).getBytes()); update().eq(&quot;id&quot;, employee.getId()).set(&quot;password&quot;, password).update(); // Xuan TODO 修改完密码后是否应该将当前用户登录信息清除，重新登录 // 4. 返回结果 return Result.success();&#125;"},{"title":"修改员工账号状态","path":"/wiki/xiaomo/后台管理端/修改员工账号状态.html","content":"修改员工账号状态 接口地址:/admin/employee/status/&#123;status&#125; 请求方式:POST 请求数据类型:application/json 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema id 用户id query true integer(int64) status 账号状态 path true integer(int32) 响应状态: 状态码 说明 schema 200 OK Result 201 Created 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data object msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &#123;&#125;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @ApiOperation(&quot;修改员工账号状态&quot;) @ApiImplicitParams(&#123; @ApiImplicitParam(name = &quot;status&quot;, value = &quot;账号状态&quot;, required = true, dataType = &quot;Integer&quot;), @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户id&quot;, required = true, dataType = &quot;Long&quot;) &#125;) @PostMapping(&quot;/status/&#123;status&#125;&quot;) public Result updateStatus(@PathVariable Integer status, Long id) &#123; return employeeService.updateStatus(status, id); &#125; Impl /** * 修改员工状态 * * @param status * @param id * @return */ @Override public Result updateStatus(Integer status, Long id) &#123; // 1. 数据校验 if (status == null || id == null) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; if (StatusConstant.ENABLE.equals(status) || StatusConstant.DISABLE.equals(status))&#123; // 二者满足其一即可 // 2. 修改员工状态 update().eq(&quot;id&quot;,id).set(&quot;status&quot;, status).update(); // 3. 返回结果 return Result.success(); &#125; throw new BaseException(MessageConstant.STATUS_DATA_ERROR); &#125;"},{"title":"分类分页查询","path":"/wiki/xiaomo/后台管理端/分类分页查询-02.html","content":"分类分页查询 接口地址:/admin/category/page 请求方式:GET 请求数据类型:application/x-www-form-urlencoded 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema name 分类名称 query false string page 页码 query false integer(int32) pageSize 每页记录数 query false integer(int32) type 分类类型 1菜品分类 2套餐分类 query false integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«PageResult» 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data PageResult PageResult records array object total integer(int64) msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &#123; &quot;records&quot;: [], &quot;total&quot;: 0\t&#125;,\t&quot;msg&quot;: &quot;&quot;&#125; controller /** * 分类分页查询 * @param categoryPageQueryDTO * @return */ @GetMapping(&quot;/page&quot;) @ApiOperation(&quot;分类分页查询&quot;) public Result&lt;PageResult&gt; page(CategoryPageQueryDTO categoryPageQueryDTO)&#123; log.info(&quot;分页查询：&#123;&#125;&quot;, categoryPageQueryDTO); return categoryService.pageQuery(categoryPageQueryDTO); &#125; Impl /** * 分类分页查询 * * @param categoryPageQueryDTO * @return */ @Override public Result&lt;PageResult&gt; pageQuery(CategoryPageQueryDTO categoryPageQueryDTO) &#123; // 1. 校验参数 if (categoryPageQueryDTO == null || categoryPageQueryDTO.getPage() &lt;= 0 || categoryPageQueryDTO.getPageSize() &lt;= 0) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 构建分页查询 Page&lt;Category&gt; categoryPage = new Page&lt;&gt;(categoryPageQueryDTO.getPage(), categoryPageQueryDTO.getPageSize()); LambdaQueryWrapper&lt;Category&gt; categoryLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); if (categoryPageQueryDTO.getType() != null) &#123; categoryLambdaQueryWrapper.eq(Category::getType, categoryPageQueryDTO.getType()); &#125; if (StringUtils.isNotBlank(categoryPageQueryDTO.getName())) &#123; categoryLambdaQueryWrapper.like(Category::getName, categoryPageQueryDTO.getName()); &#125; categoryLambdaQueryWrapper.orderByDesc(Category::getSort); page(categoryPage, categoryLambdaQueryWrapper); // 3. 返回 PageResult pageResult = new PageResult(categoryPage.getTotal(), categoryPage.getRecords()); return Result.success(pageResult); &#125;"},{"title":"启用禁用分类","path":"/wiki/xiaomo/后台管理端/启用、禁用分类-05.html","content":"启用禁用分类 接口地址:/admin/category/status/&#123;status&#125; 请求方式:POST 请求数据类型:application/json 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema id 分类id query true integer(int64) status 分类状态 path true integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«string» 201 Created 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &quot;&quot;,\t&quot;msg&quot;: &quot;&quot;&#125; controller /** * 启用、禁用分类 * @param status * @param id * @return */ @PostMapping(&quot;/status/&#123;status&#125;&quot;) @ApiOperation(&quot;启用禁用分类&quot;) @ApiImplicitParams(&#123; @ApiImplicitParam(name = &quot;status&quot;, value = &quot;分类状态&quot;, required = true, dataType = &quot;Integer&quot;, dataTypeClass = Integer.class), @ApiImplicitParam(name = &quot;id&quot;, value = &quot;分类id&quot;, required = true, dataType = &quot;Long&quot;, dataTypeClass = Long.class) &#125;) public Result&lt;String&gt; startOrStop(@PathVariable(&quot;status&quot;) Integer status, Long id)&#123; log.info(&quot;启用禁用分类：&#123;&#125;，&#123;&#125;&quot;, status, id); return categoryService.startOrStop(status,id); &#125; Impl /** * 启用或禁用分类 * * @param status * @param id * @return */ @Override public Result&lt;String&gt; startOrStop(Integer status, Long id) &#123; // 1. 校验参数 if (status == null || id == null) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 修改 Category category = Category.builder() .id(id) .updateTime(LocalDateTime.now()) .updateUser(BaseContext.getCurrentId()) .status(status) .build(); updateById(category); // 3. 返回 return Result.success(); &#125;"},{"title":"删除分类","path":"/wiki/xiaomo/后台管理端/删除分类-03.html","content":"删除分类 接口地址:/admin/category 请求方式:DELETE 请求数据类型:application/x-www-form-urlencoded 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema id 分类id query true integer(int64) 响应状态: 状态码 说明 schema 200 OK Result«string» 204 No Content 401 Unauthorized 403 Forbidden 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &quot;&quot;,\t&quot;msg&quot;: &quot;&quot;&#125; controller /** * 删除分类 * @param id * @return */ @DeleteMapping @ApiOperation(&quot;删除分类&quot;) @ApiImplicitParam(name = &quot;id&quot;, value = &quot;分类id&quot;, required = true, dataType = &quot;Long&quot;, dataTypeClass = Long.class) public Result&lt;String&gt; deleteById(Long id)&#123; log.info(&quot;删除分类：&#123;&#125;&quot;, id); return categoryService.deleteById(id); &#125; Impl /** * 删除分类 * * @param id * @return */ @Override public Result&lt;String&gt; deleteById(Long id) &#123; // 1. 校验参数 if (id == null) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 判断是否存在绑定关系 // 2.1 口味 LambdaQueryWrapper&lt;Dish&gt; dishLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); dishLambdaQueryWrapper.eq(Dish::getCategoryId, id); int countDish = dishService.count(dishLambdaQueryWrapper); if (countDish &gt; 0) &#123; throw new BaseException(MessageConstant.CATEGORY_BIND_ALREADY); &#125; // 2.2 套餐 LambdaQueryWrapper&lt;Setmeal&gt; setmealLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId, id); int countSetmeal = setmealService.count(setmealLambdaQueryWrapper); if (countSetmeal &gt; 0) &#123; throw new BaseException(MessageConstant.CATEGORY_BIND_ALREADY); &#125; // 3. 删除 removeById(id); // 4. 返回 return Result.success(); &#125;"},{"title":"员工信息分页","path":"/wiki/xiaomo/后台管理端/员工信息分页.html","content":"员工信息分页查询 接口地址:/admin/employee/page 请求方式:GET 请求数据类型:application/x-www-form-urlencoded 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema name query false string page query false integer(int32) pageSize query false integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«PageResult» 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data PageResult PageResult records array object total integer(int64) msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &#123; &quot;records&quot;: [], &quot;total&quot;: 0\t&#125;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @ApiOperation(&quot;员工信息分页查询&quot;) @GetMapping(&quot;/page&quot;) public Result&lt;PageResult&gt; pageQuery(EmployeePageQueryDTO pageQueryDTO)&#123; return employeeService.pageQuery(pageQueryDTO); &#125; Impl /** * 员工信息分页查询 * * @param pageQueryDTO * @return Result&lt;PageResult&gt; */ @Override public Result&lt;PageResult&gt; pageQuery(EmployeePageQueryDTO pageQueryDTO) &#123; // 1. 数据校验 if (pageQueryDTO == null || pageQueryDTO.getPage() &lt;= 0 || pageQueryDTO.getPageSize() &lt;= 0)&#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 构建分页查询 Page&lt;Employee&gt; employeePage = new Page&lt;&gt;(pageQueryDTO.getPage(), pageQueryDTO.getPageSize()); LambdaQueryWrapper&lt;Employee&gt; employeeLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); if (StringUtils.isNotBlank(pageQueryDTO.getName()))&#123; employeeLambdaQueryWrapper.eq(Employee::getName, pageQueryDTO.getName()); &#125; employeeLambdaQueryWrapper.orderByDesc(Employee::getUpdateTime); page(employeePage, employeeLambdaQueryWrapper); // 3. 构建返回参数 List&lt;Employee&gt; records = employeePage.getRecords(); long total = employeePage.getTotal(); PageResult pageResult = new PageResult(); pageResult.setTotal(total); pageResult.setRecords(records); // 4. 返回数据 return Result.success(pageResult); &#125; 这里使用的是mp进行分页，配置分页拦截器。 /** * mybatisPlus分页拦截器 * @return */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor()&#123; MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor(); mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor()); return mybatisPlusInterceptor; &#125; 一些问题 image-20230906120644943 通过后端传输过来的数据我们可以看到这里的时间显示格式并不是我们期望的形式。这里有两种解决方法 在对应属性上添加@JsonFormat(pattern = “yyyy-MM-dd HH:mm:ss”)的形式 在WebMvcConfiguration中添加SpringMvc的消息转换器，对日期格式进行统一处理 (推荐) 方法二 @Override protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; log.info(&quot;设置消息转换器&quot;); // 创建一个消息转换器对象 MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter = new MappingJackson2HttpMessageConverter(); // 设置转换器 mappingJackson2HttpMessageConverter.setObjectMapper(new JacksonObjectMapper()); // 将转换器添加进容器中 converters.add(0, mappingJackson2HttpMessageConverter); &#125; 关于JacksonObjectMapper，主要是对LocalDate，LocalDateTime，LocalTime等类型进行序列化 /** * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象] * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON] */public class JacksonObjectMapper extends ObjectMapper &#123; public static final String DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;; //public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;; public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm&quot;; public static final String DEFAULT_TIME_FORMAT = &quot;HH:mm:ss&quot;; public JacksonObjectMapper() &#123; super(); //收到未知属性时不报异常 this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false); //反序列化时，属性不存在的兼容处理 this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); SimpleModule simpleModule = new SimpleModule() .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))) .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT))) .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT))) .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))) .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT))) .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT))); //注册功能模块 例如，可以添加自定义序列化器和反序列化器 this.registerModule(simpleModule); &#125;&#125; image-20230906120823015"},{"title":"新增分类","path":"/wiki/xiaomo/后台管理端/新增分类-01.html","content":"新增分类 接口地址:/admin/category 请求方式:POST 请求数据类型:application/json 响应数据类型:*/* 接口描述: 请求示例: &#123; &quot;id&quot;: 0, &quot;name&quot;: &quot;&quot;, &quot;sort&quot;: 0, &quot;type&quot;: 0&#125; 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema categoryDTO categoryDTO body true 分类DTO 分类DTO id 主键 false integer(int64) name 分类名称 false string sort 排序 false integer(int32) type 类型 1 菜品分类 2 套餐分类 false integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«string» 201 Created 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &quot;&quot;,\t&quot;msg&quot;: &quot;&quot;&#125; controller /** * 新增分类 * @param categoryDTO * @return */ @PostMapping @ApiOperation(&quot;新增分类&quot;) public Result&lt;String&gt; save(@RequestBody CategoryDTO categoryDTO)&#123; log.info(&quot;新增分类：&#123;&#125;&quot;, categoryDTO); return categoryService.save(categoryDTO); &#125; Impl /** * 新增分类 * * @param categoryDTO * @return */ @Override public Result&lt;String&gt; save(CategoryDTO categoryDTO) &#123; // 1. 校验参数 if (!categoryDTO.check()) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 初始化参数 // Xuan TODO 后续优化为自动填充 Category category = new Category(); BeanUtils.copyProperties(categoryDTO, category); category.setStatus(StatusConstant.ENABLE); category.setCreateTime(LocalDateTime.now()); category.setUpdateTime(LocalDateTime.now()); category.setUpdateUser(BaseContext.getCurrentId()); category.setCreateUser(BaseContext.getCurrentId()); // 3. 保存 save(category); // 4. 返回 return Result.success(); &#125;"},{"title":"新增员工","path":"/wiki/xiaomo/后台管理端/新增员工.html","content":"接口 接口路径： POST/admin/employee 请求参数 Headers： 参数名称 参数值 是否必须 示例 备注 Content-Type application/json 是 Body: 名称 类型 是否必须 默认值 备注 其他信息 id integer 非必须 员工id format: int64 idNumber string 必须 身份证 name string 必须 姓名 phone string 必须 手机号 sex string 必须 性别 username string 必须 用户名 返回数据 名称 类型 是否必须 默认值 备注 其他信息 code integer 必须 format: int32 data object 非必须 msg string 非必须 controller @ApiOperation(value = &quot;新增员工&quot;)@PostMapping()public Result&lt;String&gt; addEmp(@RequestBody EmployeeDTO employeeDTO)&#123; return employeeService.addEmp(employeeDTO);&#125; Impl 修改前/** * 新增员工 * * @param employeeDTO * @return Result&lt;String&gt; */ @Override public Result&lt;String&gt; addEmp(EmployeeDTO employeeDTO) &#123; // 1. 数据校验 if (employeeDTO == null || StringUtils.isBlank(employeeDTO.getName()) || StringUtils.isBlank(employeeDTO.getUsername()) || StringUtils.isBlank(employeeDTO.getSex()) || StringUtils.isBlank(employeeDTO.getPhone()) || StringUtils.isBlank(employeeDTO.getIdNumber())) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 初始化员工数据 Employee employee = new Employee(); BeanUtils.copyProperties(employeeDTO, employee); employee.setStatus(StatusConstant.ENABLE); employee.setSalt(RandomStringGenerator.generateRandomString(4)); employee.setPassword( DigestUtils.md5DigestAsHex( (PasswordConstant.DEFAULT_PASSWORD + employee.getSalt()).getBytes())); employee.setCreateTime(LocalDate.now()); employee.setUpdateTime(LocalDate.now()); employee.setCreateUser(BaseContext.getCurrentId()); employee.setUpdateUser(BaseContext.getCurrentId()); // 3.新增 INSERT INTO employee ( name, username, password, phone, sex, id_number, status, // create_time, update_time, create_user, update_user, salt ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, // ?, ?, ?, ? ) save(employee); return Result.success(); &#125; /** * 新增员工 * * @param employeeDTO * @return Result&lt;String&gt; */ @Override public Result&lt;String&gt; addEmp(EmployeeDTO employeeDTO) &#123; // 1. 数据校验 if (employeeDTO == null || StringUtils.isBlank(employeeDTO.getName()) || StringUtils.isBlank(employeeDTO.getUsername()) || StringUtils.isBlank(employeeDTO.getSex()) || StringUtils.isBlank(employeeDTO.getPhone()) || StringUtils.isBlank(employeeDTO.getIdNumber())) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 1.1 手机号正则验证 boolean validate = MobileNumberValidator.validate(employeeDTO.getPhone()); if (!validate)&#123; throw new BaseException(&quot;手机号不正确&quot;); &#125; // 1.2 用户名长度验证 if (employeeDTO.getUsername().length() &lt; 3 || employeeDTO.getUsername().length() &gt; 20)&#123; throw new BaseException(&quot;用户名长度不正确&quot;); &#125; // 2. 初始化员工数据 Employee employee = new Employee(); BeanUtils.copyProperties(employeeDTO, employee); employee.setStatus(StatusConstant.ENABLE); employee.setSalt(RandomStringGenerator.generateRandomString(4)); employee.setPassword( DigestUtils.md5DigestAsHex( (PasswordConstant.DEFAULT_PASSWORD + employee.getSalt()).getBytes())); employee.setCreateTime(LocalDate.now()); employee.setUpdateTime(LocalDate.now()); employee.setCreateUser(BaseContext.getCurrentId()); employee.setUpdateUser(BaseContext.getCurrentId()); // 3.新增 INSERT INTO employee ( name, username, password, phone, sex, id_number, status, // create_time, update_time, create_user, update_user, salt ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, // ?, ?, ?, ? ) save(employee); return Result.success(); &#125; 一些问题 由于username是作为unique唯一索引的，所以在添加的时候可能会出现重复的username导致数据库报错添加失败的问题。 设置全局异常处理器GlobalExceptionHandler对异常进行捕获处理 /** * 全局异常处理器，处理项目中抛出的业务异常 */@RestControllerAdvice@Slf4jpublic class GlobalExceptionHandler &#123; /** * 捕获业务异常 * @param ex * @return */ @ExceptionHandler public Result exceptionHandler(BaseException ex)&#123; log.error(&quot;异常信息：&#123;&#125;&quot;, ex.getMessage()); return Result.error(ex.getMessage()); &#125; /** * sql异常捕获 * @param ex * @return */ @ExceptionHandler public Result exceptionHandler(SQLIntegrityConstraintViolationException ex)&#123; String exMessage = ex.getMessage(); if (exMessage.contains(&quot;Duplicate entry&quot;))&#123; // 重复字段 String[] split = exMessage.split(&quot; &quot;); String msg = split[2] + MessageConstant.ALREADY_EXISTS; return Result.error(msg); &#125;else &#123; return Result.error(MessageConstant.UNKNOWN_ERROR); &#125; &#125;&#125; 这样在我们重复添加的时候前端就能接收到对应的错误信息 image-20230906154533870 在进行前后端联调测试时发现一个bug image-20230906150017125 后台查询回显的数据在前端无法正常保存？ 实际原因是这一条数据是我根据knife4j生成的文档填写数据直接进行添加的，跳过了前端的验证，但是在后台的新增员工又仅是判断了数据不为空，所以导致发生这种情况，所以我决定需要对新增员工模块的代码进行完善。 测试用例 &#123; &quot;idNumber&quot;: &quot;111222333444555&quot;, &quot;name&quot;: &quot;lisi&quot;, &quot;phone&quot;: &quot;12333330987&quot;, &quot;sex&quot;: &quot;男&quot;, &quot;username&quot;: &quot;李四&quot;&#125; 结果 &#123; &quot;code&quot;: 0, &quot;msg&quot;: &quot;手机号不正确&quot;, &quot;data&quot;: null&#125;"},{"title":"根据员工Id查询","path":"/wiki/xiaomo/后台管理端/根据员工id查询.html","content":"根据id获取员工信息 接口地址:/admin/employee/&#123;id&#125; 请求方式:GET 请求数据类型:application/x-www-form-urlencoded 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema id 员工id path true integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«员工信息传递» 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data 员工信息传递 员工信息传递 id 员工id integer(int64) idNumber 身份证号 string name 员工姓名 string password 密码 string phone 手机号 string sex 性别 string username 用户名 string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &#123; &quot;id&quot;: 0, &quot;idNumber&quot;: &quot;&quot;, &quot;name&quot;: &quot;&quot;, &quot;password&quot;: &quot;&quot;, &quot;phone&quot;: &quot;&quot;, &quot;sex&quot;: &quot;&quot;, &quot;username&quot;: &quot;&quot;\t&#125;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @ApiOperation(&quot;根据id获取员工信息&quot;) @ApiImplicitParam(name = &quot;id&quot;, value = &quot;员工id&quot;, required = true, dataType = &quot;Integer&quot;) @GetMapping(&quot;/&#123;id&#125;&quot;) public Result&lt;EmployeeInfoVO&gt; getEmpById(@PathVariable Integer id) &#123; return employeeService.getEmpById(id); &#125; Impl /** * 根据id获取员工信息 * * @param id * @return */ @Override public Result&lt;EmployeeInfoVO&gt; getEmpById(Integer id) &#123; // 1. 数据校验 if (id == null)&#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 查询数据 Employee employee = getById(id); if (employee == null)&#123; throw new AccountNotFoundException(MessageConstant.ACCOUNT_NOT_FOUND); &#125; // 3. 拷贝返回数值 EmployeeInfoVO employeeInfoVO = new EmployeeInfoVO(); BeanUtils.copyProperties(employee, employeeInfoVO); // 4. 返回数据 return Result.success(employeeInfoVO); &#125; 一些问题 在进行前后端联调测试时发现一个bug image-20230906150017125 后台查询回显的数据在前端无法正常保存？ 实际原因是这一条数据是我根据knife4j生成的文档填写数据直接进行添加的，跳过了前端的验证，但是在后台的新增员工又仅是判断了数据不为空，所以导致发生这种情况，所以我决定需要对新增员工模块的代码进行完善。"},{"title":"启用禁用分类","path":"/wiki/xiaomo/后台管理端/根据类型查询分类-06.html","content":"启用禁用分类 接口地址:/admin/category/status/&#123;status&#125; 请求方式:POST 请求数据类型:application/json 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema id 分类id query true integer(int64) status 分类状态 path true integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«string» 201 Created 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &quot;&quot;,\t&quot;msg&quot;: &quot;&quot;&#125; controller /** * 启用、禁用分类 * @param status * @param id * @return */ @PostMapping(&quot;/status/&#123;status&#125;&quot;) @ApiOperation(&quot;启用禁用分类&quot;) @ApiImplicitParams(&#123; @ApiImplicitParam(name = &quot;status&quot;, value = &quot;分类状态&quot;, required = true, dataType = &quot;Integer&quot;, dataTypeClass = Integer.class), @ApiImplicitParam(name = &quot;id&quot;, value = &quot;分类id&quot;, required = true, dataType = &quot;Long&quot;, dataTypeClass = Long.class) &#125;) public Result&lt;String&gt; startOrStop(@PathVariable(&quot;status&quot;) Integer status, Long id)&#123; log.info(&quot;启用禁用分类：&#123;&#125;，&#123;&#125;&quot;, status, id); return categoryService.startOrStop(status,id); &#125; Impl /** * 启用或禁用分类 * * @param status * @param id * @return */ @Override public Result&lt;String&gt; startOrStop(Integer status, Long id) &#123; // 1. 校验参数 if (status == null || id == null) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 修改 Category category = Category.builder() .id(id) .updateTime(LocalDateTime.now()) .updateUser(BaseContext.getCurrentId()) .status(status) .build(); updateById(category); // 3. 返回 return Result.success(); &#125;"},{"title":"员工登录模块","path":"/wiki/xiaomo/后台管理端/登录模块.html","content":"接口 接口路径： POST/admin/employee/login 请求参数 Headers： 参数名称 参数值 是否必须 示例 备注 Content-Type application/json 是 Body: 名称 类型 是否必须 默认值 备注 其他信息 password string 必须 密码 username string 必须 用户名 返回数据 名称 类型 是否必须 默认值 备注 其他信息 code integer 必须 format: int32 data object 非必须 员工登录返回的数据格式 备注: 员工登录返回的数据格式 id integer 非必须 主键值 format: int64 name string 非必须 姓名 token string 非必须 jwt令牌 userName string 非必须 用户名 msg string 非必须 controller @PostMapping(&quot;/login&quot;) @ApiOperation(value = &quot;登入&quot;) public Result&lt;EmployeeLoginVO&gt; login(@RequestBody EmployeeLoginDTO employeeLoginDTO) &#123; log.info(&quot;员工登录：&#123;&#125;&quot;, employeeLoginDTO); return employeeService.login(employeeLoginDTO); &#125; impl /** * 员工登录 * * @param employeeLoginDTO * @return Result&lt;EmployeeLoginVO&gt; */ @Override public Result&lt;EmployeeLoginVO&gt; login(EmployeeLoginDTO employeeLoginDTO) &#123; // 1. 检查变量是否有效 if (employeeLoginDTO == null || StringUtils.isBlank(employeeLoginDTO.getUsername()) || StringUtils.isBlank(employeeLoginDTO.getPassword())) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 根据用户名查询数据是否存在 LambdaQueryWrapper&lt;Employee&gt; employeeLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); employeeLambdaQueryWrapper.eq(Employee::getUsername, employeeLoginDTO.getUsername()); Employee employee = getOne(employeeLambdaQueryWrapper); // 3. 判断用户数据是否存在 if (employee == null) &#123; throw new AccountNotFoundException(MessageConstant.ACCOUNT_NOT_FOUND); &#125; // 4. 比对密码是否一致 String password = DigestUtils.md5DigestAsHex( (employeeLoginDTO.getPassword() + employee.getSalt()).getBytes()); if (!password.equals(employee.getPassword())) &#123; throw new PasswordErrorException(MessageConstant.PASSWORD_ERROR); &#125; // 5. 判断账号状态 if (employee.getStatus().equals(StatusConstant.DISABLE)) &#123; throw new AccountLockedException(MessageConstant.ACCOUNT_LOCKED); &#125; // 6. 登录成功后，生成jwt令牌 Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(); claims.put(JwtClaimsConstant.EMP_ID, employee.getId()); String token = JwtUtil.createJWT(jwtProperties.getAdminSecretKey(), jwtProperties.getAdminTtl(), claims); EmployeeLoginVO employeeLoginVO = EmployeeLoginVO.builder() .id(employee.getId()) .userName(employee.getUsername()) .name(employee.getName()) .token(token) .build(); return Result.success(employeeLoginVO); &#125;"}]