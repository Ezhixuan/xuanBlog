[{"title":"优雅的非空判断","path":"/post/df2d6cfb/","content":"如何优雅的非空判断 在编写代码的过程中，经常会遇到对于传输过来的数据有特殊要求，有一个错误总会在意料之外出现,那就是空指针异常。空指针的出现也很简单,得到了一个null对象,并调用它的某些方法,出现空指针异常。 对于简单的对象，我们可以使用 ！= null 再去使用，或者调用一些Api去校验，形如 // 1. 校验参数if (dishPageQueryDTO == null || dishPageQueryDTO.getPage() &lt;= 0 || dishPageQueryDTO.getPageSize() &lt;= 0) &#123; throw new NullDataException(MessageConstant.NULL_DATA);&#125; // 1.校验数据boolean check = dishDTO.check();if (!check) &#123; throw new NullDataException(MessageConstant.NULL_DATA);&#125; if (ObjectUtils.isEmpty(o))&#123; return null;&#125; 对于少量的参数这样不仅直观并且也能根据特定需求进行特殊判断，但是如果遇到参数过多的情况，就会导致核心业务代码还未开始编辑就产出大量的判断代码，甚至判断的代码量超过该业务的代码，并且我们在某个业务的代码无法在其他模块复用，因此，需要考虑如何优雅的进行非空判断。 hibernate-validator hibernate-validator提供多种特殊判断以及数值空值形如@Email,@Max,@Size… 更多的使用可以参考官方文档Hibernate Validator 6.2.5.Final - Jakarta Bean Validation Reference Implementation: Reference Guide (jboss.org) 本篇主要介绍非空判断的使用 导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.2.5.Final&lt;/version&gt;&lt;/dependency&gt; 关于非空注解 关于非空判断常用的注解有@NotNull, @NotBlank, @NotEmpty 对于这三个注解，官方给出的解释为 #### @NotBlankChecks that the annotated character sequence is not null and the trimmed length is greater than 0. The difference to is that this constraint can only be applied on character sequences and that trailing white-spaces are ignored.`@NotEmpty`- Supported data types `CharSequence`- Hibernate metadata impact None#### @NotEmptyChecks whether the annotated element is not null nor empty- Supported data types `CharSequence`, , and arrays`Collection``Map`- Hibernate metadata impact None#### @NotNullChecks that the annotated value is not `null`- Supported data types Any type- Hibernate metadata impact Column(s) are not nullable 总结来说@NotNull适用于任何类型的非空判断，但是存在限制，即只能检查非空，因此引出@NotBlank和@NotEmpty，其中@NotBlank适用于字符串类型，它可以判断去空后size是否大于0，@NotEmpty在@NotBlank的基础上又增强拓展了对于集合等类型的判断。 @NotNull：用于验证字段或方法参数不为 null。它可以应用于任意类型的字段，包括基本类型和引用类型。 @NotNullprivate String name; @NotBlank：用于验证字符串字段或方法参数不为 null 且长度大于 0，且字符串不能仅由空格组成。它只适用于字符串类型的字段。 @NotBlankprivate String title; @NotEmpty：用于验证字段或方法参数不为 null 且不为空，即长度大于 0。它适用于字符串、集合、Map 和数组类型的字段。 @NotEmptyprivate List&lt;String&gt; tags; 需要注意的是，@NotBlank 和 @NotEmpty 注解都是对 @NotNull 注解的补充，所以如果应用 @NotBlank 或 @NotEmpty 注解时，该字段或方法参数会自动被认为不为 null。此外，它们都可以与其他的约束注解一起使用。 关于@Valid和@Validated 适用范围 @Valid 注解是 Java 标准库中的注解（javax.validation.Valid），而 @Validated 注解是 Spring 框架提供的注解（org.springframework.validation.annotation.Validated）。因此，如果在非 Spring 环境中使用验证框架，应该使用 @Valid 注解；如果在 Spring 环境中使用验证框架，则可以使用 @Validated 注解。 使用限制 @Validated 注解在 Spring 环境中的使用存在一些限制，它只能应用于类级别的验证（Class-level validation）和方法级别的验证（Method-level validation）。而 @Valid 注解可以应用于类的字段级别、方法的参数级别、方法的返回值级别等。 分组校验 @Validated 注解支持分组校验（Group Validation）功能，可以根据不同的场景对验证规则进行分组。通过在验证注解上使用分组接口进行声明，可以指定只验证特定分组的约束条件。这对于复杂的验证场景非常有用。而 @Valid 注解在验证过程中不支持分组校验。 实际使用 这里以我的实际使用举例，如有错误，欢迎指出 @Data@AllArgsConstructor@NoArgsConstructor@ApiModel(&quot;友链添加DTO&quot;)public class LinkDTO &#123; @NotNull(message = &quot;友链id不能为空&quot;, groups = Update.class) private Long id; @NotBlank(message = &quot;友链名称不能为空&quot;, groups = &#123;Insert.class,Update.class&#125;) private String name; @NotBlank(message = &quot;友链logo不能为空&quot;, groups = &#123;Insert.class,Update.class&#125;) private String logo; @NotBlank(message = &quot;友链描述不能为空&quot;, groups = &#123;Insert.class,Update.class&#125;) private String description; @NotBlank(message = &quot;友链地址不能为空&quot;, groups = &#123;Insert.class,Update.class&#125;) private String address; @NotBlank(message = &quot;友链状态不能为空&quot;, groups = &#123;Insert.class,Update.class&#125;) private String status;&#125; 如上述代码所示，一般简单使用可以忽略groups参数，只填写message即可，默认会是Default.class groups个人理解为使用的分组，对于不同的分组，后续可以进行不同的操作 @Log(businessName = &quot;添加友链&quot;)@PostMapping@ApiOperation(&quot;添加友链&quot;)public ResponseResult&lt;String&gt; insertLinkSys(@RequestBody @Validated(Insert.class) LinkDTO linkDto) &#123; return linkService.insertLinkSys(linkDto);&#125; 在controller层我们在需要约束的传参前添加@Valid或@Validated注解，否则验证不会生效，在传参中我配置了分组，所以这里使用@Validated并进行分组校验，可以只对处于Insert.class分组的参数进行校验。如果没有进行分组则可以直接使用@Valid 请求参数，这里基本放空 &#123; &quot;address&quot;: &quot;&quot;, &quot;description&quot;: &quot;&quot;, &quot;id&quot;: &quot;&quot;, &quot;logo&quot;: &quot;&quot;, &quot;name&quot;: &quot;&quot;, &quot;status&quot;: &quot;&quot;&#125; 响应 &#123; &quot;code&quot;: 500, &quot;message&quot;: &quot;Validation failed for argument [0] in public com.ezhixuan.xuan_framework.domain.vo.ResponseResult&lt;java.lang.String&gt; com.ezhixuan.xuan_admin.controller.LinkController.insertLinkSys(com.ezhixuan.xuan_framework.domain.dto.link.LinkDTO) with 5 errors: [Field error in object &#x27;linkDTO&#x27; on field &#x27;name&#x27;: rejected value []; codes [NotBlank.linkDTO.name,NotBlank.name,NotBlank.java.lang.String,NotBlank]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [linkDTO.name,name]; arguments []; default message [name]]; default message [友链名称不能为空]] [Field error in object &#x27;linkDTO&#x27; on field &#x27;logo&#x27;: rejected value []; codes [NotBlank.linkDTO.logo,NotBlank.logo,NotBlank.java.lang.String,NotBlank]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [linkDTO.logo,logo]; arguments []; default message [logo]]; default message [友链logo不能为空]] [Field error in object &#x27;linkDTO&#x27; on field &#x27;description&#x27;: rejected value []; codes [NotBlank.linkDTO.description,NotBlank.description,NotBlank.java.lang.String,NotBlank]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [linkDTO.description,description]; arguments []; default message [description]]; default message [友链描述不能为空]] [Field error in object &#x27;linkDTO&#x27; on field &#x27;address&#x27;: rejected value []; codes [NotBlank.linkDTO.address,NotBlank.address,NotBlank.java.lang.String,NotBlank]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [linkDTO.address,address]; arguments []; default message [address]]; default message [友链地址不能为空]] [Field error in object &#x27;linkDTO&#x27; on field &#x27;status&#x27;: rejected value []; codes [NotBlank.linkDTO.status,NotBlank.status,NotBlank.java.lang.String,NotBlank]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [linkDTO.status,status]; arguments []; default message [status]]; default message [友链状态不能为空]] &quot;&#125; 可以看到响应message中成功响应判断，并且只有分组为Insert.class的被处理，分组为Update.class的id虽然也是空但是友链id不能为空并没有出现在响应消息中。 拓展 - 分组 分组的情况有多种，我使用的是自定义接口并继承Default即可，注意继承的类即可，不多赘述。 package com.ezhixuan.xuan_framework.handler.validated;import javax.validation.groups.Default;/** * @author ezhixuan */public interface Insert extends Default &#123;&#125; 拓展 - 异常处理 对于上文提到的返回消息并不符合自己项目的响应格式，所以需要自定义异常处理器。 使用@ExceptionHandler(MethodArgumentNotValidException.class)捕获异常 image-20231010023753723 image-20231010023310934 image-20231010023547920 image-20231010023926959 由此可以得知ex.getBindingResult().getAllErrors()可以获得Message // 获取异常信息 List&lt;ObjectError&gt; allErrors = ex.getBindingResult().getAllErrors(); ArrayList&lt;String&gt; errorsMessage = new ArrayList&lt;&gt;(allErrors.size()); allErrors.forEach(error -&gt; errorsMessage.add(error.getDefaultMessage())); 但其实没必要将所有问题一股脑反馈给用户，只需反应一条，逐步解决，循循渐进即可。 最终 @RestControllerAdvice@Slf4jpublic class GlobalExceptionHandler &#123; @ExceptionHandler(MethodArgumentNotValidException.class) public ResponseResult exceptionHandler(MethodArgumentNotValidException ex) &#123; log.error(&quot;异常信息：&#123;&#125;&quot;, ex); // 获取异常信息 List&lt;ObjectError&gt; allErrors = ex.getBindingResult().getAllErrors(); return ResponseResult.errorResult(500, allErrors.get(0).getDefaultMessage()); &#125;&#125; &#123; &quot;code&quot;: 500, &quot;message&quot;: &quot;友链logo不能为空&quot;&#125; 拓展 - 常用命令 @Null 限制必须为null@NotNull 限制必须不能为null@AssertFalse 限制必须为false@AssertTrue 限制必须为true@DecimalMax(value) 限制必须为一个不超过指定大小值的数字@DecimalMin(value) 限制必须为一个不低于指定大小值的数字@Digits(integert,fraction) 限制必须为一个小数,且整数部分位数不能超过integer,小数部分位数不能超过fraction@Futrue 限制必须为一个将来的日期@Past 限制必须为一个过去的日期@Max(value) 限制必须为一个不超过指定大小值的数字@Min(value) 限制必须为一个不低于指定大小值的数字@Pattern(value) 限制必须符合指定的正则表达式@Size(max,min) 限制字符长度必须处在max和min的值之间@NotEmpty 验证注解的元素值不为null且不为空(字符串长度不为0,集合大小不为0)@NotBlank 验证注解的元素值不为空(不为null,且去除首位空格后长度不为0),不同于@NotEmpty,@NotBlank只适用于字符串的校验且在校验时会去除字符串的空格@Email 验证值是否为邮箱,也可以通过正则表达式和flag指定自定义的email格式@Length 限制字符串参数长度@Range 限制数值类型或者字符串在指定范围@URL 对URL地址进行验证","tags":["java","学习"],"categories":["技术分享"]},{"title":"rabbitMq","path":"/post/775b8c4e/","content":"关于MQ MQ，中文是消息队列，字面上是存放消息的队列，也是时间驱动架构中的Broker。 同步调用与异步调用 同步调用 优点：时效性较强，可以立即得到结果。 缺点：耦合度高，性能和吞吐能力较低，有额外的资源消耗，有级联失败问题。 异步调用 优点：服务解耦，性能提升，吞吐量提高，服务没有强依赖，不必担心级联失败问题，流量削峰。 缺点：依赖broker的可靠性、安全性、吞吐能力，架构更复杂，业务没有明显的流程线，不好追踪管理。 使用场景 同步的使用场景在于立即需要获取返回结果并使用，是比较常用的。 异步的使用场景在于不关心返回结果，只需要通知即可。 实现框架 RabbitMQ ActiveMQ RocketMQ Kafka 开发语言 Erlang Java Java Scala&amp;Java 支持协议 AMQP，XMPP，SMTP，STOMP OpenWire，STOMP，REST，XMPP，AMQP 自定义协议 自定义协议 可用性 高 一般 高 高 单机吞吐量 一般 差 高 非常高 消息延迟 微妙级 毫秒级 毫秒级 毫秒以内 消息可靠性 高 一般 高 一般 RabbitMQ 安装 可以直接通过指令拉取 docker pull rabbitmq:3-management 也可以通过下载安装包后安装 docker load -i 包名 docker启动 docker run \\ -e RABBITMQ_DEFAULT_USER=ezhixuan \\ -e RABBITMQ_DEFAULT_PASS=123456 \\ --name mq \\ --hostname mq1 \\ -p 15672:15672 \\ -p 5672:5672 \\ -d \\ rabbitmq:3-management 导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 添加配置 spring: rabbitmq: username: # 用户名 password: # 密码 host: # 主机 port: # 端口 virtual-host: # 虚拟主机 SimpleQueue 发送模型 publisher -&gt; queue -&gt; consumer publisher @Resource private RabbitTemplate rabbitTemplate;@Testvoid rabbitPublisher() &#123; rabbitTemplate.convertAndSend(&quot;mqdemo&quot;, JSONUtil.toJsonStr(&quot;我是测试-普通信息发送&quot;));&#125; listener @Component@Slf4jpublic class RabbitMqListener &#123; @RabbitListener(queues = &quot;mqdemo&quot;) public void simpleListener(String onMessage) &#123; log.info(&quot;接收到一条消息&#123;&#125;&quot;, onMessage); &#125;&#125; WorkQueue 发送模型 publisher -&gt; queue -&gt; consumer ​ -&gt;consumer WorkQueue并不是一个新的队列，只是通过添加消费者来提高消息处理速度，来避免消息堆积。 它会将消息平均的分配给所有消费者，是因为rabbitMq的消息预取机制，消息到达队列时，消费者的通道会预先将消息抽取出，直到达到消费者允许的最大未确认消息数量。一旦未确认的消息数量达到了设置的预取值，RabbitMQ就停止传递更多消息，除非至少有一条未完成的消息得到了确认。 如果由两台性能一高一低的机器作为消费者，它们仍会通过消费预取来平分这些消息，尽管高性能的机器已经将消息处理完，也不会去拿低性能的机器的消息。 image-20230922100029004 可以消费者1很快就处理结束了，而消费者二等待了一段时间后才结束，但是它们处理的消息数量是相同的。 希望能够按能力分配我们可以到yml文件中配置消费预取限制 将prefetch改为1,即最大只能有一条未处理消息，只有处理完才能获取下一条消息，prefetch 默认是无上限。 image-20230922100949606 这样就极大优化了消息处理的效率 publisher @Testvoid workQueue() &#123; // 发送50条消息 for (int i = 0; i &lt; 50; i++) &#123; rabbitTemplate.convertAndSend(&quot;mqdemo&quot;, JSONUtil.toJsonStr(&quot;我是测试-工作队列信息发送&quot; + i)); &#125;&#125; listener @RabbitListener(queues = &quot;mqdemo&quot;)public void workQueue1(String onMessage) throws InterruptedException &#123; log.info(&quot;workQueue1接收到一条消息&#123;&#125;，&#123;&#125;&quot;, onMessage, LocalDateTime.now()); Thread.sleep(200);&#125;@RabbitListener(queues = &quot;mqdemo&quot;)public void workQueue2(String onMessage) throws InterruptedException &#123; log.error(&quot;workQueue2接收到一条消息&#123;&#125;，&#123;&#125;&quot;, onMessage, LocalDateTime.now()); Thread.sleep(2000);&#125; 发布订阅模型 发送模型 发出的消息只能被一个消费者消费，因为一旦被消费就会从队列中被删除。 发布订阅模型允许将同一消息发送给多个消费者，通过exchange实现。 exchange只负责消息路由而不负责存储，路由失败则消息丢失 Fanout Exchange 会将接收到的消息路由到每一个跟其绑定的queue config package com.ezhixuan.rabbitmqdemo.config;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.FanoutExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @program: rabbitMq-demo * @description: 将队列与交换机绑定-rabbitMq * @author: Mr.Xuan * @create: 2023-09-22 10:29 */@Configurationpublic class BindingQueue2Exchange &#123; // =================init Exchange================= @Bean public FanoutExchange ezhixuanFanoutExchange() &#123; return new FanoutExchange(&quot;ezhixuan.fanout&quot;); &#125; // ==================init Queue================= @Bean public Queue fanoutQueue1() &#123; return new Queue(&quot;fanout.queue1&quot;); &#125; @Bean public Queue fanoutQueue2() &#123; return new Queue(&quot;fanout.queue2&quot;); &#125; // ==================Binding================= @Bean public Binding bindingQueue1(Queue fanoutQueue1, FanoutExchange ezhixuanFanoutExchange) &#123; return BindingBuilder.bind(fanoutQueue1).to(ezhixuanFanoutExchange); &#125; @Bean public Binding bindingQueue2(Queue fanoutQueue2, FanoutExchange ezhixuanFanoutExchange) &#123; return BindingBuilder.bind(fanoutQueue2).to(ezhixuanFanoutExchange); &#125;&#125; publisher @Testvoid fanout() &#123; rabbitTemplate.convertAndSend(&quot;ezhixuan.fanout&quot;, &quot;&quot;, JSONUtil.toJsonStr(&quot;哈喽大家好，都看的到吗&quot;));&#125; listener @RabbitListener(queues = &quot;fanout.queue1&quot;)public void fanoutQueue1(String onMessage) throws InterruptedException &#123; log.info(&quot;fanoutQueue1接收到一条消息&#123;&#125;，&#123;&#125;&quot;, onMessage, LocalDateTime.now());&#125;@RabbitListener(queues = &quot;fanout.queue2&quot;)public void fanoutQueue2(String onMessage) throws InterruptedException &#123; log.error(&quot;fanoutQueue2接收到一条消息&#123;&#125;，&#123;&#125;&quot;, onMessage, LocalDateTime.now());&#125; image-20230922104637112 Direct Exchange Direct Exchange会将接收到的消息根据指定规则路由到指定的Queue，因此被称为路由模式 一个Queue的bindingkey是可以有多个的 publisher @Testvoid direct()&#123; rabbitTemplate.convertAndSend(&quot;ezhixuan.direct&quot;, &quot;yellow&quot;, JSONUtil.toJsonStr(&quot;yellow看到吗&quot;)); rabbitTemplate.convertAndSend(&quot;ezhixuan.direct&quot;, &quot;blue&quot;, JSONUtil.toJsonStr(&quot;blue看到吗&quot;)); rabbitTemplate.convertAndSend(&quot;ezhixuan.direct&quot;, &quot;red&quot;, JSONUtil.toJsonStr(&quot;red看到吗&quot;));&#125; listener 在fanout中使用的是通过config配置类来实现Queue的初始化以及绑定，但是这样是比较繁琐的，我们可以直接在listener注解上配置 @RabbitListener( bindings = @QueueBinding( value = @Queue(name = &quot;direct.queue1&quot;), exchange = @Exchange(name = &quot;ezhixuan.direct&quot;, type = ExchangeTypes.DIRECT), key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;)) public void directQueue1(String onMessage) &#123; log.info(&quot;directQueue1接收到一条消息&#123;&#125;，&#123;&#125;&quot;, onMessage, LocalDateTime.now()); &#125; @RabbitListener( bindings = @QueueBinding( value = @Queue(name = &quot;direct.queue2&quot;), exchange = @Exchange(name = &quot;ezhixuan.direct&quot;, type = ExchangeTypes.DIRECT), key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;)) public void directQueue2(String onMessage) &#123; log.info(&quot;directQueue2接收到一条消息&#123;&#125;，&#123;&#125;&quot;, onMessage, LocalDateTime.now()); &#125; image-20230922110851799 image-20230922110858777 Topic Exchange bindingkey必须是多个单词组成，单词之间由.连接 主要特点在于支持使用通配符 #：代表0个或者多个单词 *：代指一个单词 publisher @Testvoid topic() &#123; rabbitTemplate.convertAndSend(&quot;ezhixuan.topic&quot;, &quot;ezhixuan.wiki&quot;, JSONUtil.toJsonStr(&quot;wiki上新了&quot;)); rabbitTemplate.convertAndSend(&quot;ezhixuan.topic&quot;, &quot;ezhixuan.note&quot;, JSONUtil.toJsonStr(&quot;note上新了&quot;));&#125; listener @RabbitListener( bindings = @QueueBinding( value = @Queue(name = &quot;topic.queue1&quot;), exchange = @Exchange(name = &quot;ezhixuan.topic&quot;, type = ExchangeTypes.TOPIC), key = &quot;ezhixuan.#&quot;)) public void topicQueue1(String onMessage) &#123; log.info(&quot;topicQueue1接收到一条消息&#123;&#125;，&#123;&#125;&quot;, onMessage, LocalDateTime.now()); &#125; @RabbitListener( bindings = @QueueBinding( value = @Queue(name = &quot;topic.queue2&quot;), exchange = @Exchange(name = &quot;ezhixuan.topic&quot;, type = ExchangeTypes.TOPIC), key = &quot;ezhixuan.wiki&quot;)) public void topicQueue2(String onMessage) &#123; log.info(&quot;topicQueue2接收到一条消息&#123;&#125;，&#123;&#125;&quot;, onMessage, LocalDateTime.now()); &#125; @RabbitListener( bindings = @QueueBinding( value = @Queue(name = &quot;topic.queue3&quot;), exchange = @Exchange(name = &quot;ezhixuan.topic&quot;, type = ExchangeTypes.TOPIC), key = &quot;*.wiki&quot;)) public void topicQueue3(String onMessage) &#123; log.info(&quot;topicQueue3接收到一条消息&#123;&#125;，&#123;&#125;&quot;, onMessage, LocalDateTime.now()); &#125; image-20230922112127588 image-20230922112136108 消息转换器 image-20230922113603695 由于springamqp默认使用的是jdk的序列化器，在消息的转换上会占用更多字节，影响速度，推荐修改为json的序列化器。 我个人习惯使用hutool的对象转换即上文发送消息的JSONUtil转换也是可以实现的 image-20230922113827953 也可以通过以下方法来实现 导入依赖 &lt;!--发送消息转换器所需依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--接收消息转换器所需依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;&lt;/dependency&gt; 修改配置 可以在启动类直接配置，也可以在config创建配置。 注意这里需要导的是org.springframework.amqp.support.converter.MessageConverter的MessageConverter package com.ezhixuan.rabbitmqdemo;import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;import org.springframework.amqp.support.converter.MessageConverter;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;@SpringBootApplicationpublic class RabbitMqDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RabbitMqDemoApplication.class, args); &#125; @Bean public MessageConverter messageConverter() &#123; return new Jackson2JsonMessageConverter(); &#125;&#125; image-20231004111035847","tags":["mq","rabbitMq"]},{"title":"springSecurity","path":"/post/b04a945b/","content":"简介 springSecurity是Spring家族中的安全管理框架。相比另一个安全框架Shiro，它提供了更丰富的功能，以及更丰富的社区资源。 一般来说中大型企业都是使用SpringSecurity来做安全框架。小项目使用Shiro较多，相对来说，Shiro的上手更加简单 一般Web应用需要进行认证和授权 认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户 授权：经过认证后判断当前用户是否有权限进行某个操作 认证和授权也是springSecurity的作为安全框架的核心功能 导入springSecurity 导入起步依赖 &lt;!--springSecurity--&gt;&lt;dependency&gt;\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 当初次引入该依赖并启动后，会被强制跳转到登录验证界面，默认用户名是user,密码会在后端控制台提供。 简单使用过后，这里开始下文记录一些常规使用方法 Pom文件 技术选型如下所示 &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;SpringSecurityDemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;SpringSecurityDemo&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.10&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--springWeb--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!--springSecurity--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--redis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--json--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--jwt依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatisPlus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--springbootTest--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--fastJson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;2.0.32&lt;/version&gt; &lt;/dependency&gt; &lt;!--hutool--&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.16&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 这里使用的是springboot2.7.10，hutool是一个比较好用的工具包，本篇中仅使用于将Object转换为JSON类型的字符串，可根据自己喜好自行切换。当然也可能会有疑问说如果只是转换类型使用fastJson不是一样可以实现吗，在这里由于本人技术水平有限，使用fastJson在进行转换时报错，尽管更换新版本一样没能解决问题，判断问题在于因为返回包含request或response，没有进行忽略序列化，由于一些原因，fastJson无法对其进行正常序列化 todofastJson报错 Application.yml spring: datasource: url: jdbc:mysql://localhost:3306/security?characterEncoding=utf-8&amp;serverTimezone=UTC username: root password: zyx driver-class-name: com.mysql.cj.jdbc.Driver redis: port: 6379 host: localhostmybatis-plus: mapper-locations: classpath*:/mapper/**/*.xml configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl DB /* Navicat Premium Data Transfer Source Server : 本地 Source Server Type : MySQL Source Server Version : 80031 (8.0.31) Source Host : localhost:3306 Source Schema : security Target Server Type : MySQL Target Server Version : 80031 (8.0.31) File Encoding : 65001 Date: 26/09/2023 20:53:17*/SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for sys_menu-- ----------------------------DROP TABLE IF EXISTS `sys_menu`;CREATE TABLE `sys_menu` ( `id` bigint NOT NULL AUTO_INCREMENT, `menu_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;菜单名&#x27;, `path` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT &#x27;路由地址&#x27;, `component` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT &#x27;组件路径&#x27;, `visible` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;菜单状态（0显示 1隐藏）&#x27;, `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;菜单状态（0正常 1停用）&#x27;, `perms` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT &#x27;权限标识&#x27;, `icon` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT &#x27;#&#x27; COMMENT &#x27;菜单图标&#x27;, `create_by` bigint NULL DEFAULT NULL, `create_time` datetime NULL DEFAULT NULL, `update_by` bigint NULL DEFAULT NULL, `update_time` datetime NULL DEFAULT NULL, `del_flag` int NULL DEFAULT 0 COMMENT &#x27;是否删除（0未删除 1已删除）&#x27;, `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT &#x27;备注&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = &#x27;菜单表&#x27; ROW_FORMAT = Dynamic;-- ------------------------------ Records of sys_menu-- ----------------------------INSERT INTO `sys_menu` VALUES (1, &#x27;all&#x27;, &#x27;sys&#x27;, &#x27;sys/test/index&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, &#x27;sys:test:list&#x27;, &#x27;#&#x27;, NULL, NULL, NULL, NULL, 0, NULL);-- ------------------------------ Table structure for sys_role-- ----------------------------DROP TABLE IF EXISTS `sys_role`;CREATE TABLE `sys_role` ( `id` bigint NOT NULL AUTO_INCREMENT, `name` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL, `role_key` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT &#x27;角色权限字符串&#x27;, `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;角色状态（0正常 1停用）&#x27;, `del_flag` int NULL DEFAULT 0 COMMENT &#x27;del_flag&#x27;, `create_by` bigint NULL DEFAULT NULL, `create_time` datetime NULL DEFAULT NULL, `update_by` bigint NULL DEFAULT NULL, `update_time` datetime NULL DEFAULT NULL, `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT &#x27;备注&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = &#x27;角色表&#x27; ROW_FORMAT = Dynamic;-- ------------------------------ Records of sys_role-- ----------------------------INSERT INTO `sys_role` VALUES (1, &#x27;superManager&#x27;, &#x27;super&#x27;, &#x27;0&#x27;, 0, NULL, NULL, NULL, NULL, NULL);-- ------------------------------ Table structure for sys_role_menu-- ----------------------------DROP TABLE IF EXISTS `sys_role_menu`;CREATE TABLE `sys_role_menu` ( `role_id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;角色ID&#x27;, `menu_id` bigint NOT NULL DEFAULT 0 COMMENT &#x27;菜单id&#x27;, PRIMARY KEY (`role_id`, `menu_id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of sys_role_menu-- ----------------------------INSERT INTO `sys_role_menu` VALUES (1, 1);-- ------------------------------ Table structure for sys_user-- ----------------------------DROP TABLE IF EXISTS `sys_user`;CREATE TABLE `sys_user` ( `id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `user_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;用户名&#x27;, `nick_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;昵称&#x27;, `password` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT &#x27;NULL&#x27; COMMENT &#x27;密码&#x27;, `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;账号状态（0正常 1停用）&#x27;, `email` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT &#x27;邮箱&#x27;, `phonenumber` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT &#x27;手机号&#x27;, `sex` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT &#x27;用户性别（0男，1女，2未知）&#x27;, `avatar` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT &#x27;头像&#x27;, `user_type` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;用户类型（0管理员，1普通用户）&#x27;, `create_by` bigint NULL DEFAULT NULL COMMENT &#x27;创建人的用户id&#x27;, `create_time` datetime NULL DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `update_by` bigint NULL DEFAULT NULL COMMENT &#x27;更新人&#x27;, `update_time` datetime NULL DEFAULT NULL COMMENT &#x27;更新时间&#x27;, `del_flag` int NULL DEFAULT 0 COMMENT &#x27;删除标志（0代表未删除，1代表已删除）&#x27;, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = &#x27;用户表&#x27; ROW_FORMAT = Dynamic;-- ------------------------------ Records of sys_user-- ----------------------------INSERT INTO `sys_user` VALUES (1, &#x27;ezhixuan&#x27;, &#x27;一只轩呐&#x27;, &#x27;$2a$10$ukg69WWLQ4KwJGmePwgU6edIJG/qXDShraMp9ZBCTm8M0VcrBpc26&#x27;, &#x27;0&#x27;, NULL, NULL, NULL, NULL, &#x27;1&#x27;, NULL, NULL, NULL, NULL, 0);-- ------------------------------ Table structure for sys_user_role-- ----------------------------DROP TABLE IF EXISTS `sys_user_role`;CREATE TABLE `sys_user_role` ( `user_id` bigint NOT NULL AUTO_INCREMENT COMMENT &#x27;用户id&#x27;, `role_id` bigint NOT NULL DEFAULT 0 COMMENT &#x27;角色id&#x27;, PRIMARY KEY (`user_id`, `role_id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of sys_user_role-- ----------------------------INSERT INTO `sys_user_role` VALUES (1, 1);SET FOREIGN_KEY_CHECKS = 1; 认证 首先来看一个简单的登录验证流程 那么springSecurity的登录流程是什么样的呢 SpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。 image-20211214144425527 图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。 UsernamePasswordAuthenticationFilter:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。 **ExceptionTranslationFilter：**处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。 **FilterSecurityInterceptor：**负责权限校验的过滤器。 我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。 image-20230926212242648 认证流程详解 image-20211214151515385 概念速查: Authentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。 AuthenticationManager接口：定义了认证Authentication的方法 UserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。 UserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。 UserDetailsServiceImpl UserDetailsService是SpringSecurity提供的一个接口，用于根据用户名获取用户信息，需要自己实现loadUserByUsername方法 首先我们需要定义一个方法来实现UserDetailsService接口 package com.ezhixuan.springSecurityDemo.service.impl;import com.baomidou.mybatisplus.core.toolkit.Wrappers;import com.ezhixuan.springSecurityDemo.domain.entitiy.LoginUser;import com.ezhixuan.springSecurityDemo.domain.entitiy.User;import com.ezhixuan.springSecurityDemo.mapper.MenuMapper;import com.ezhixuan.springSecurityDemo.mapper.UserMapper;import java.util.List;import java.util.Objects;import javax.annotation.Resource;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Service;/** * @program: SpringSecurityDemo * @description: * @author: Mr.Xuan * @create: 2023-09-25 21:15 **/@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Resource private UserMapper userMapper; @Resource private MenuMapper menuMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; // 查询用户信息 User user = userMapper.selectOne(Wrappers.&lt;User&gt;lambdaQuery().eq(User::getUserName, username)); if (Objects.isNull(user))&#123; throw new RuntimeException(&quot;用户名或密码错误&quot;); &#125; // 查询用户权限 List&lt;String&gt; permissions = menuMapper.selectPermsByUserId(user.getId()); LoginUser loginUser = new LoginUser(user,permissions); return loginUser; &#125;&#125; 主要流程为： 查询用户信息 查询用户权限 封装进UserDetails实现类中返回 同时，由于该方法的返回值是UserDetails，所以我们需要自行定义一个类实现UserDetails package com.ezhixuan.springSecurityDemo.domain.entitiy;import com.fasterxml.jackson.annotation.JsonIgnore;import java.util.Collection;import java.util.List;import java.util.stream.Collectors;import lombok.Data;import lombok.NoArgsConstructor;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;/** * @program: SpringSecurityDemo * @description: * @author: Mr.Xuan * @create: 2023-09-25 21:24 **/@Data@NoArgsConstructorpublic class LoginUser implements UserDetails &#123; private User user; //存储权限信息 private List&lt;String&gt; permissions; public LoginUser(User user, List&lt;String&gt; permissions) &#123; this.user = user; this.permissions = permissions; &#125; //存储SpringSecurity所需要的权限信息的集合 @JsonIgnore private List&lt;GrantedAuthority&gt; authorities; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; if(authorities!=null)&#123; return authorities; &#125; //把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中 authorities = permissions.stream(). map(SimpleGrantedAuthority::new) .collect(Collectors.toList()); return authorities; &#125; @Override public String getPassword() &#123; return user.getPassword(); &#125; @Override public String getUsername() &#123; return user.getUserName(); &#125; @Override public boolean isAccountNonExpired() &#123; return true; &#125; @Override public boolean isAccountNonLocked() &#123; return true; &#125; @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125;&#125; 这里的注意点为： 不需要使用@AllArgsConstructor，authorities需要后续通过方法填充。 此时进行测试会出现报错 2023-09-25 21:30:36.084 ERROR 27868 --- [nio-8080-exec-6] o.a.c.c.C.[.[.[/].[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exceptionjava.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id &quot;null&quot;\tat org.springframework.security.crypto.password.DelegatingPasswordEncoder$UnmappedIdPasswordEncoder.matches(DelegatingPasswordEncoder.java:289) ~[spring-security-crypto-5.7.7.jar:5.7.7]\tat org.springframework.security.crypto.password.DelegatingPasswordEncoder.matches(DelegatingPasswordEncoder.java:237) ~[spring-security-crypto-5.7.7.jar:5.7.7]\tat org.springframework.security.authentication.dao.DaoAuthenticationProvider.additionalAuthenticationChecks(DaoAuthenticationProvider.java:77) ~[spring-security-core-5.7.7.jar:5.7.7]\tat org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider.authenticate(AbstractUserDetailsAuthenticationProvider.java 这里是密码的问题，后续修改即可，因为还没有进行相应配置修改，只需要在数据库中的密码前面加上**{noop}**即可实际项目中我们不会把密码明文存储在数据库中。 默认使用的PasswordEncoder要求数据库中的密码格式为：{id}password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。 我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。 在之前是定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。 在我现在用的2.7.10版本，这个类已经被遗弃了，直接配置一个PasswordEncoder的bean就好了, 不用继承它 /** * @program: SpringSecurityDemo * @description: * @author: Mr.Xuan * @create: 2023-09-25 23:01 */@Configuration@Slf4jpublic class SpringSecurityConfig &#123; /** * 密码加密 * * @return */ @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125;&#125; 登录接口 controller package com.ezhixuan.springSecurityDemo.controller;import com.ezhixuan.springSecurityDemo.domain.ResponseResult;import com.ezhixuan.springSecurityDemo.domain.entitiy.User;import com.ezhixuan.springSecurityDemo.service.LoginService;import javax.annotation.Resource;import org.springframework.web.bind.annotation.*;/** * @program: SpringSecurityDemo * @description: 登录控制器 * @author: Mr.Xuan * @create: 2023-09-26 08:09 **/@RestController@RequestMapping(&quot;/user&quot;)public class LoginController &#123; @Resource private LoginService loginService; @PostMapping(&quot;/login&quot;) public ResponseResult login(@RequestBody User user)&#123; return loginService.login(user); &#125; @DeleteMapping(&quot;/logout&quot;) public ResponseResult logout() &#123; return loginService.logout();&#125;&#125; Impl /** * @program: SpringSecurityDemo * @description: 用户登录 * @author: Mr.Xuan * @create: 2023-09-26 08:11 */@Servicepublic class LoginServiceImpl implements LoginService &#123; @Resource private AuthenticationManager authenticationManager; @Resource private RedisCache redisCache; /** * 用户登录 * * @return */ @Override public ResponseResult login(User user) &#123;\t// 1. 通过authenticationManager进行登录验证 UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(user.getUserName(), user.getPassword()); Authentication authenticate = authenticationManager.authenticate(token); if (Objects.isNull(authenticate)) &#123; // 2. 如果验证失败，抛出异常 throw new RuntimeException(&quot;登录失败&quot;); &#125; // 3. 如果验证成功，将用户信息存入redis中 LoginUser loginUser = (LoginUser) authenticate.getPrincipal(); String userId = loginUser.getUser().getId().toString(); String jwt = JwtUtil.createJWT(userId); redisCache.setCacheObject(&quot;login:&quot; + userId, loginUser); // 4. 将token返回给前端 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;token&quot;, jwt); return new ResponseResult(200, &quot;登录成功&quot;, map); &#125;&#125; 主要流程为： 通过authenticationManager进行登录验证 从Principal中取出用户信息 生成JWT返回给前端 这里需要使用注入authenticationManger，一样在配置类中注入Bean即可。并且需要放开login接口 springSecurity配置类 package com.ezhixuan.springSecurityDemo.config;import com.ezhixuan.springSecurityDemo.filter.JWTAuthenticationTokenFilter;import javax.annotation.Resource;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.http.SessionCreationPolicy;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.web.AuthenticationEntryPoint;import org.springframework.security.web.SecurityFilterChain;import org.springframework.security.web.access.AccessDeniedHandler;import org.springframework.security.web.authentication.AuthenticationFailureHandler;import org.springframework.security.web.authentication.AuthenticationSuccessHandler;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;import org.springframework.security.web.authentication.logout.LogoutSuccessHandler;/** * @program: SpringSecurityDemo * @description: * @author: Mr.Xuan * @create: 2023-09-25 23:01 */@Configuration@Slf4j@EnableGlobalMethodSecurity(prePostEnabled = true)public class SpringSecurityConfig &#123; @Resource private JWTAuthenticationTokenFilter jwtAuthenticationTokenFilter; @Resource private AccessDeniedHandler accessDeniedHandler; @Resource private AuthenticationEntryPoint authenticationEntryPoint; @Resource private AuthenticationSuccessHandler authenticationSuccessHandler; @Resource private AuthenticationFailureHandler authenticationFailureHandler; @Resource private LogoutSuccessHandler logoutSuccessHandler; /** * 密码加密 * * @return */ @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125; /** * 过滤器链配置 * * @param http * @return * @throws Exception */ @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception &#123; http // 关闭csrf .csrf() .disable() // 不通过Session获取SecurityContext .sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;) .anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest() .authenticated(); // 添加token校验过滤器到过滤器链中 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); // 添加自定义异常处理器 http.exceptionHandling() .accessDeniedHandler(accessDeniedHandler) .authenticationEntryPoint(authenticationEntryPoint); // 添加允许跨域 http.cors(); // 添加自定义处理器 http.formLogin().successHandler(authenticationSuccessHandler).failureHandler(authenticationFailureHandler); http.logout().logoutSuccessHandler(logoutSuccessHandler); return http.build(); &#125; /** * 获取AuthenticationManager（认证管理器），登录时认证使用 * * @param authenticationConfiguration * @return * @throws Exception */ @Bean public AuthenticationManager authenticationManager( AuthenticationConfiguration authenticationConfiguration) throws Exception &#123; return authenticationConfiguration.getAuthenticationManager(); &#125;&#125; 登出接口 controller @DeleteMapping(&quot;/logout&quot;) public ResponseResult logout() &#123; return loginService.logout();&#125; Impl package com.ezhixuan.springSecurityDemo.service.impl;import com.ezhixuan.springSecurityDemo.domain.ResponseResult;import com.ezhixuan.springSecurityDemo.domain.entitiy.LoginUser;import com.ezhixuan.springSecurityDemo.domain.entitiy.User;import com.ezhixuan.springSecurityDemo.service.LoginService;import com.ezhixuan.springSecurityDemo.utils.JwtUtil;import com.ezhixuan.springSecurityDemo.utils.RedisCache;import java.util.HashMap;import java.util.Map;import java.util.Objects;import javax.annotation.Resource;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.Authentication;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.stereotype.Service;/** * @program: SpringSecurityDemo * @description: 用户登录 * @author: Mr.Xuan * @create: 2023-09-26 08:11 */@Servicepublic class LoginServiceImpl implements LoginService &#123; @Resource private AuthenticationManager authenticationManager; @Resource private RedisCache redisCache; /** * 用户登录 * * @return */ @Override public ResponseResult login(User user) &#123; // 1. 通过authenticationManager进行登录验证 UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(user.getUserName(), user.getPassword()); Authentication authenticate = authenticationManager.authenticate(token); if (Objects.isNull(authenticate)) &#123; // 2. 如果验证失败，抛出异常 throw new RuntimeException(&quot;登录失败&quot;); &#125; // 3. 如果验证成功，将用户信息存入redis中 LoginUser loginUser = (LoginUser) authenticate.getPrincipal(); String userId = loginUser.getUser().getId().toString(); String jwt = JwtUtil.createJWT(userId); redisCache.setCacheObject(&quot;login:&quot; + userId, loginUser); // 4. 将token返回给前端 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;token&quot;, jwt); return new ResponseResult(200, &quot;登录成功&quot;, map); &#125; /** * 用户退出 * * @return */ @Override public ResponseResult logout() &#123; // 1. 从contextHolder中获取loginUser信息 Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); LoginUser loginUser = (LoginUser) authentication.getPrincipal(); // 2. 到redis中删除对应User的信息 String userId = loginUser.getUser().getId().toString(); redisCache.deleteObject(&quot;login:&quot; + userId); return new ResponseResult(200, &quot;退出成功&quot;); &#125;&#125; 主要流程为： 从contextHolder中获取loginUser信息 到redis中删除对应User的信息 JWTAuthenticationTokenFilter 这里的contextHolder本质上是一个ThreadLocal，但是我们为什么能够从里面获取用户信息呢 是因为我们自行添加了一个filter来过滤请求获取用户信息并存入SecurityContextHolder中 package com.ezhixuan.springSecurityDemo.filter;import com.ezhixuan.springSecurityDemo.domain.entitiy.LoginUser;import com.ezhixuan.springSecurityDemo.utils.JwtUtil;import com.ezhixuan.springSecurityDemo.utils.RedisCache;import io.jsonwebtoken.Claims;import java.io.IOException;import java.util.Objects;import javax.annotation.Resource;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import org.springframework.web.filter.OncePerRequestFilter;/** * @program: SpringSecurityDemo * @description: 校验JWT是否有效 * @author: Mr.Xuan * @create: 2023-09-26 09:28 */@Componentpublic class JWTAuthenticationTokenFilter extends OncePerRequestFilter &#123; @Resource private RedisCache redisCache; @Override protected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; // 1. 获取token String token = request.getHeader(&quot;token&quot;); if (!StringUtils.hasText(token)) &#123; // token 不存在 filterChain.doFilter(request, response); return; &#125; // token 存在 // 2. 解析token String userId; try &#123; Claims claims = JwtUtil.parseJWT(token); userId = claims.getSubject(); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(&quot;token非法&quot;); &#125; // 3. 从redis中获取用户信息 LoginUser loginUser = redisCache.getCacheObject(&quot;login:&quot; + userId); if (Objects.isNull(loginUser))&#123; throw new RuntimeException(&quot;用户未登录&quot;); &#125; // 4. 存入SecurityContextHolder UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, loginUser.getAuthorities()); SecurityContextHolder.getContext().setAuthentication(authenticationToken); // 5. 放行 filterChain.doFilter(request,response); &#125;&#125; 这里没有去实现filter而是继承OncePerRequestFilter，是因为实现filter可能出现的一种原因就是因为在请求执行完之后浏览器会再发一次请求.ico的请求，所以这里使用Spring实现的OncePerRequestFilter。 同时这里还需要将过滤器位置置于UsernamePasswordAuthenticationFilter之前 @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception &#123; http // 关闭csrf .csrf() .disable() // 不通过Session获取SecurityContext .sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;) .anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest() .authenticated(); ================================================== // 添加token校验过滤器到过滤器链中 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); ===================================================== // 添加自定义异常处理器 http.exceptionHandling() .accessDeniedHandler(accessDeniedHandler) .authenticationEntryPoint(authenticationEntryPoint); // 添加允许跨域 http.cors(); // 添加自定义处理器 http.formLogin().successHandler(authenticationSuccessHandler).failureHandler(authenticationFailureHandler); http.logout().logoutSuccessHandler(logoutSuccessHandler); return http.build(); &#125; 这样就能够实现如果请求没有携带Token就放行给后面的过滤器链处理，如果请求携带了Token则会解析Token信息，并将解析出的信息存入SecurityContextHolder中。 至此，认证环节基本结束。接下来则是授权的阶段 授权 例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。 总结起来就是不同的用户可以使用不同的功能。这就是权限系统要去实现的效果。 我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。 所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。 说到授权，就不得不提RBAC权限模型 RBAC权限模型 RBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。 在RBAC模型里面，有三个基础组成部分，分别是用户、角色和权限。 RBAC通过定义角色的权限，并对用户授予某个角色从而来控制用户的权限，实现用户和权限的逻辑分离（区别于ACL模型），极大方便了权限的管理。 RBAC模型中的一些名词： User（用户）：每个用户都有唯一的UID识别，并被授予不同的角色； Role（角色）：不同角色具有不同权限； Permission（权限）：访问权限； 用户-角色映射：用户和角色之间的映射关系； 角色-权限映射：角色和权限之间的映射关系。 image-20230927144114944 限制接口访问权限 要限制接口访问权限有两种方法，一种是通过配置类中去设置，这里采用更方便的注解来配置。 首先，需要开启相关配置，我们直接去配置类上方添加@EnableGlobalMethodSecurity(prePostEnabled = true)具体配置看上文认证给出的配置类，开启之后给接口上添加@PreAuthorize(&quot;hasAuthority('xxx')&quot;)注解xxx表示权限 package com.ezhixuan.springSecurityDemo.controller;import org.springframework.security.access.prepost.PreAuthorize;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @program: SpringSecurityDemo * @description: SpringSecurity控制器 * @author: Mr.Xuan * @create: 2023-09-25 17:56 **/@RestController@RequestMapping(&quot;/demo&quot;)public class SecurityController &#123; @PreAuthorize(&quot;hasAuthority(&#x27;sys:test:list&#x27;)&quot;) @GetMapping(&quot;test&quot;) public String demoTest()&#123; return &quot;hello&quot;; &#125;&#125; SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。比较常用的就是hasAuthority方法，它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。 hasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。 @PreAuthorize(&quot;hasAnyAuthority(&#x27;admin&#x27;,&#x27;test&#x27;,&#x27;system:dept:list&#x27;)&quot;)@GetMapping(&quot;test&quot;) public String demoTest()&#123; return &quot;hello&quot;; &#125; hasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。 @PreAuthorize(&quot;hasRole(&#x27;system:dept:list&#x27;)&quot;)@GetMapping(&quot;test&quot;) public String demoTest()&#123; return &quot;hello&quot;; &#125; hasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。 @PreAuthorize(&quot;hasAnyRole(&#x27;admin&#x27;,&#x27;system:dept:list&#x27;)&quot;)@GetMapping(&quot;test&quot;) public String demoTest()&#123; return &quot;hello&quot;; &#125; 而用户所有的权限在上文的UserDetailsServiceImpl中从menuMapper中获取并存入loginUser中，并且由JWTAuthenticationTokenFilter取出并授权给用户，此时拥有接口对应权限的用户才能访问对应接口。 这里贴出menuMapper的方法 package com.ezhixuan.springSecurityDemo.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.ezhixuan.springSecurityDemo.domain.entitiy.Menu;import java.util.List;public interface MenuMapper extends BaseMapper&lt;Menu&gt; &#123; List&lt;String&gt; selectPermsByUserId(Long id);&#125; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.ezhixuan.springSecurityDemo.mapper.MenuMapper&quot;&gt; &lt;select id=&quot;selectPermsByUserId&quot; resultType=&quot;java.lang.String&quot;&gt; SELECT DISTINCT m.perms FROM sys_user_role AS ur LEFT JOIN sys_role AS r ON ur.role_id = r.id LEFT JOIN sys_role_menu AS rm ON r.id = rm.role_id LEFT JOIN sys_menu AS m ON rm.menu_id = m.id WHERE ur.user_id = #&#123;userid&#125; AND r.`status` = 0 AND m.`status` = 0 &lt;/select&gt;&lt;/mapper&gt; 至此，授权环节基本结束。 自定义异常返回 由于springSecurity内部的返回并不能满足我们的Result需要，所以我们可以自定义异常返回 package com.ezhixuan.springSecurityDemo.handler;import cn.hutool.json.JSONUtil;import com.ezhixuan.springSecurityDemo.domain.ResponseResult;import com.ezhixuan.springSecurityDemo.utils.WebUtils;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.http.HttpStatus;import org.springframework.security.access.AccessDeniedException;import org.springframework.security.web.access.AccessDeniedHandler;import org.springframework.stereotype.Component;/** * @program: SpringSecurityDemo * @description: 自定义异常处理机制 * @author: Mr.Xuan * @create: 2023-09-26 15:46 */@Componentpublic class AccessDeniedHandlerImpl implements AccessDeniedHandler &#123; @Override public void handle( HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException &#123; ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), &quot;权限不足&quot;); String jsonStr = JSONUtil.toJsonStr(result); WebUtils.renderString(response, jsonStr); &#125;&#125; package com.ezhixuan.springSecurityDemo.handler;import cn.hutool.json.JSONUtil;import com.ezhixuan.springSecurityDemo.domain.ResponseResult;import com.ezhixuan.springSecurityDemo.utils.WebUtils;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.http.HttpStatus;import org.springframework.security.core.AuthenticationException;import org.springframework.security.web.AuthenticationEntryPoint;import org.springframework.stereotype.Component;/** * @program: SpringSecurityDemo * @description: 自定义异常处理机制 * @author: Mr.Xuan * @create: 2023-09-26 15:45 */@Componentpublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint &#123; @Override public void commence( HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123; ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), &quot;认证失败请重新登录&quot;); String jsonStr = JSONUtil.toJsonStr(result); // String jsonStr = JSON.toJSONString(request); fastjson由于数组中携带有Request或者Response对象，无法正常序列化 WebUtils.renderString(response, jsonStr); &#125;&#125; 在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。 如果是认证过程中出现的异常会被封装成AuthenticationException然后调用AuthenticationEntryPoint对象的方法去进行异常处理。 如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用AccessDeniedHandler对象的方法去进行异常处理。 所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。 WebUtils是对response进行处理的工具 package com.ezhixuan.springSecurityDemo.utils;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class WebUtils&#123; /** * 将字符串渲染到客户端 * * @param response 渲染对象 * @param string 待渲染的字符串 * @return null */ public static String renderString(HttpServletResponse response, String string) &#123; try &#123; response.setStatus(200); response.setContentType(&quot;application/json&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); response.getWriter().print(string); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 配置给SpringSecurity 先注入对应的处理器 @Autowiredprivate AuthenticationEntryPoint authenticationEntryPoint;@Autowiredprivate AccessDeniedHandler accessDeniedHandler; 然后我们可以使用HttpSecurity对象的方法去配置。 http.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint). accessDeniedHandler(accessDeniedHandler); 具体看上文springSecurity配置类 跨域 具体跨域问题我也记录过一篇文章 https://www.ezhixuan.xyz/post/7830183e/https://www.ezhixuan.xyz/post/7830183e/ 先对SpringBoot配置，运行跨域请求 @Configurationpublic class CorsConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; // 设置允许跨域的路径 registry.addMapping(&quot;/**&quot;) // 设置允许跨域请求的域名 .allowedOriginPatterns(&quot;*&quot;) // 是否允许cookie .allowCredentials(true) // 设置允许的请求方式 .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;) // 设置允许的header属性 .allowedHeaders(&quot;*&quot;) // 跨域允许时间 .maxAge(3600); &#125;&#125; 开启SpringSecurity的跨域访问 由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。 @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception &#123; http // 关闭csrf .csrf() .disable() // 不通过Session获取SecurityContext .sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;) .anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest() .authenticated(); // 添加token校验过滤器到过滤器链中 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); // 添加自定义异常处理器 http.exceptionHandling() .accessDeniedHandler(accessDeniedHandler) .authenticationEntryPoint(authenticationEntryPoint); =============================================== // 添加允许跨域 http.cors(); =============================================== // 添加自定义处理器 http.formLogin().successHandler(authenticationSuccessHandler).failureHandler(authenticationFailureHandler); http.logout().logoutSuccessHandler(logoutSuccessHandler); return http.build(); &#125; 自定义处理器 登录成功处理器 package com.ezhixuan.springSecurityDemo.handler;import org.springframework.security.core.Authentication;import org.springframework.security.web.authentication.AuthenticationSuccessHandler;import org.springframework.stereotype.Component;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @program: SpringSecurityDemo * @description: 登录成功处理器 * @author: Mr.Xuan * @create: 2023-09-27 15:34 */@Componentpublic class AuthenticationSuccessHandlerImpl implements AuthenticationSuccessHandler&#123; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; response.getWriter().write(&quot;登录成功&quot;); &#125;&#125; 登录失败处理器 package com.ezhixuan.springSecurityDemo.handler;import org.springframework.security.core.AuthenticationException;import org.springframework.security.web.authentication.AuthenticationFailureHandler;import org.springframework.stereotype.Component;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @program: SpringSecurityDemo * @description: 登录失败处理器 * @author: Mr.Xuan * @create: 2023-09-27 15:37 */@Componentpublic class AuthenticationFailureHandlerImpl implements AuthenticationFailureHandler&#123; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; response.getWriter().write(&quot;登录失败&quot;); &#125;&#125; 退出成功处理器 package com.ezhixuan.springSecurityDemo.handler;import org.springframework.security.core.Authentication;import org.springframework.security.web.authentication.logout.LogoutSuccessHandler;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @program: SpringSecurityDemo * @description: 退出成功处理器 * @author: Mr.Xuan * @create: 2023-09-27 15:38 */public class LogoutSuccessHandlerImpl implements LogoutSuccessHandler&#123; @Override public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; response.getWriter().write(&quot;退出成功&quot;); &#125;&#125; config @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception &#123; http // 关闭csrf .csrf() .disable() // 不通过Session获取SecurityContext .sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() .authorizeRequests() // 对于登录接口 允许匿名访问 .antMatchers(&quot;/user/login&quot;) .anonymous() // 除上面外的所有请求全部需要鉴权认证 .anyRequest() .authenticated(); // 添加token校验过滤器到过滤器链中 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); // 添加自定义异常处理器 http.exceptionHandling() .accessDeniedHandler(accessDeniedHandler) .authenticationEntryPoint(authenticationEntryPoint); // 添加允许跨域 http.cors(); ==================================== // 添加自定义处理器 http.formLogin().successHandler(authenticationSuccessHandler).failureHandler(authenticationFailureHandler); http.logout().logoutSuccessHandler(logoutSuccessHandler); ==================================== return http.build(); &#125;","tags":["java","spring","sercurity"],"categories":["java"]},{"title":"Springboot解决跨域问题","path":"/post/7830183e/","content":"什么是跨域 跨域(Cross-Origin)本质上是浏览器为了保护用户信息安全和隐私的一种保护机制，它通过限制不同源(不同域名、不同端口或不同协议的资源)的请求，来避免一些攻击。 跨域请求在以下情况下会被浏览器阻止： 域名不同：例如，从www.example.com的页面发起请求访问api.example.com的接口，这种情况被视为跨域请求。 端口不同：即使是相同的域名，如果端口不同（例如：example.com:8080和example.com:3000），也属于跨域请求。 协议不同：例如，在使用HTTPS协议的网站中，通过HTTP协议访问其他网站的资源，也会被视为跨域请求。 解决跨域问题 解决跨域问题的方法有很多，通过前端，中间件，后端都能够解决，为了解决跨域问题，通常可以通过配置服务器端的响应头信息来允许跨域请求，或者使用代理服务器来转发请求，或者在前端使用JSONP、CORS等技术手段来实现跨域请求。 常见可以使用nginx或者Getway等等方法来简单配置解决跨域。 本篇主要在于记录使用springboot如何解决跨域问题。 使用@CrossOrigin注解 配置CorsFilter过滤器 重写WebMvcConfigurer接口的addCorsMappings方法 案例 image-20230924162836136 因为现在基本都是采用前后端分离的开发模式，通常前后端的端口会有一些差异，此时会产生跨域问题，使用F12可以看到如图所示报错。 并且对于我们的案例hotArticleList方法也无法产生响应 image-20230924162931421 @CrossOrigin(不推荐) 这个方法个人不推荐，它需要在对应方法上添加@CrossOrigin注解，如果只有个别方法还好，但是方法多起来会显得十分繁琐 @CrossOrigin@ApiOperation(&quot;热门文章列表&quot;)@GetMapping(&quot;/hotArticleList&quot;)public ResponseResult hotArticleList()&#123; List&lt;HotArticleVo&gt; hotArticleVos = articleService.hotArticleList(); return ResponseResult.okResult(hotArticleVos);&#125; 添加注解后实测问题解决。 CorsFilter import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;/** * @program: xuanBlog * @description: Cors过滤器 * @author: Mr.Xuan */@Configurationpublic class CorsFilterConfig &#123; @Bean(name = &quot;corsFilter&quot;) public CorsFilter corsFilter() &#123; // 添加CORS配置信息 CorsConfiguration corsConfiguration = new CorsConfiguration(); // addAllowedOrigin：允许哪些地址跨域访问，这里设置为全部 corsConfiguration.addAllowedOriginPattern(&quot;*&quot;); // setAllowCredentials：是否允许携带cookie跨域 corsConfiguration.setAllowCredentials(true); // addAllowedHeader：允许跨域的请求头 corsConfiguration.addAllowedHeader(&quot;*&quot;); // addAllowedMethod：允许跨域的请求方式 corsConfiguration.addAllowedMethod(&quot;*&quot;); // urlBasedCorsConfigurationSource：基于路径的跨域配置 UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource(); // registerCorsConfiguration：注册跨域配置 urlBasedCorsConfigurationSource.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration); return new CorsFilter(urlBasedCorsConfigurationSource); &#125;&#125; 可能出现的问题 2023-09-24 16:39:48.756 ERROR 4700 --- [nio-7777-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exceptionjava.lang.IllegalArgumentException: When allowCredentials is true, allowedOrigins cannot contain the special value &quot;*&quot; since that cannot be set on the &quot;Access-Control-Allow-Origin&quot; response header. To allow credentials to a set of origins, list them explicitly or consider using &quot;allowedOriginPatterns&quot; instead. 当allowCredentials为true时，allowingOrigins不能包含特殊值“ *”，因为无法在“ Access-Control-Allow-Origin”响应标头上设置。要允许凭据具有一组来源，请明确列出它们或考虑改用“ allowedOriginPatterns”。 将addAllowedOrigin更换为addAllowedOriginPattern即可 addCorsMappings import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;/** * @program: xuanBlog * @description: WebMvc * @author: Mr.Xuan */@Configurationpublic class WebConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; // 设置允许跨域的路径 registry.addMapping(&quot;/**&quot;) // 设置允许跨域请求的域名 .allowedOriginPatterns(&quot;*&quot;) // 是否允许cookie .allowCredentials(true) // 设置允许的请求方式 .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;) // 设置允许的header属性 .allowedHeaders(&quot;*&quot;) // 跨域允许时间 .maxAge(3600); &#125;&#125; 总体和使用CorsFilter基本一致不做过多解释。不过在实际使用中因为WebMvcConfigurer使用频率较高所以这种方法会比较方便。 image-20230924165309391 至此，以上是springboot解决跨域的3种方法，如果有疑问或错误欢迎指出。","tags":["spring","跨域"],"categories":["技术分享"]},{"title":"SpringDataRedis","path":"/post/c4e4d16f/","content":"redis-java Redis 的 Java 客户端很多，常用的几种： Jedis Lettuce Spring Data Redis Spring 对 Redis 客户端进行了整合，提供了 Spring Data Redis，在Spring Boot项目中还提供了对应的Starter，即 spring-boot-starter-data-redis。 Spring Data Redis使用方式 Spring Data Redis 是 Spring 的一部分，提供了在 Spring 应用中通过简单的配置就可以访问 Redis 服务，对 Redis 底层开发包进行了高度封装。在 Spring 项目中，可以使用Spring Data Redis来简化 Redis 操作。 Spring Boot提供了对应的Starter，maven坐标： &lt;dependency&gt;\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; Spring Data Redis中提供了一个高度封装的类：RedisTemplate，对相关api进行了归类封装,将同一类型操作封装为operation接口，具体分类如下： ValueOperations：string数据操作 SetOperations：set类型数据操作 ZSetOperations：zset类型数据操作 HashOperations：hash类型的数据操作 ListOperations：list类型的数据操作 导入Spring Data Redis的maven坐标 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 配置Redis数据源 在application.yml中添加 spring: redis: database: # 使用的数据库 host: # redis地址 port: # redis端口 password: # 你的密码 没设密码可以不用填 解释说明： database:指定使用Redis的哪个数据库，Redis服务启动后默认有16个数据库，编号分别是从0到15。 可以通过修改Redis配置文件来指定数据库的数量。 编写配置类，创建RedisTemplate对象 package com.redisquickstart.config;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.JsonTypeInfo;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;import com.fasterxml.jackson.datatype.jdk8.Jdk8Module;import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;import com.fasterxml.jackson.module.paramnames.ParameterNamesModule;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;/** * @program: seckill-demo * @description: redisTemplate * @author: Mr.Xuan * @create: 2023-09-18 16:31 **/@Configuration@Slf4jpublic class RedisTemplateConfiguration &#123; @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; log.info(&quot;redisTemplate init&quot;); RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(factory); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); // 日期序列化处理 objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); objectMapper.registerModule(new Jdk8Module()) .registerModule(new JavaTimeModule()) .registerModule(new ParameterNamesModule()); // 存储java的类型，方便反序列化,没有这行，将存储为纯json字符串 objectMapper.activateDefaultTyping( LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.WRAPPER_ARRAY); jackson2JsonRedisSerializer.setObjectMapper(objectMapper); StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); // key采用String的序列化方式 redisTemplate.setKeySerializer(stringRedisSerializer); // hash key 采用String的序列化方式 redisTemplate.setHashKeySerializer(stringRedisSerializer); // value序列化方式采用jackson redisTemplate.setValueSerializer(jackson2JsonRedisSerializer); // hash的value序列化方式采用jackson redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer); redisTemplate.afterPropertiesSet(); log.info(&quot;redisTemplate init success&quot;); return redisTemplate; &#125;&#125; 解释说明： 当前配置类不是必须的，因为 Spring Boot 框架会自动装配 RedisTemplate 对象，但是默认的key序列化器为 JdkSerializationRedisSerializer，导致我们存到Redis中后的数据和原始数据有差别，故设置为 StringRedisSerializer序列化器。 通过RedisTemplate对象操作Redis 在test下新建测试类 package com.sky.test;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.*;@SpringBootTestpublic class SpringDataRedisTest &#123; @Autowired private RedisTemplate redisTemplate; @Test public void testRedisTemplate()&#123; System.out.println(redisTemplate); //string数据操作 ValueOperations valueOperations = redisTemplate.opsForValue(); //hash类型的数据操作 HashOperations hashOperations = redisTemplate.opsForHash(); //list类型的数据操作 ListOperations listOperations = redisTemplate.opsForList(); //set类型数据操作 SetOperations setOperations = redisTemplate.opsForSet(); //zset类型数据操作 ZSetOperations zSetOperations = redisTemplate.opsForZSet(); &#125;&#125; 测试： image-20230910162223863 说明RedisTemplate对象注入成功，并且通过该RedisTemplate对象获取操作5种数据类型相关对象。 上述环境搭建完毕后，接下来，我们就来具体对常见5种数据类型进行操作。 操作常见类型数据 操作字符串类型数据 /** * 操作字符串类型的数据 */ @Test public void testString()&#123; // set get setex setnx redisTemplate.opsForValue().set(&quot;name&quot;,&quot;小明&quot;); String city = (String) redisTemplate.opsForValue().get(&quot;name&quot;); System.out.println(city); redisTemplate.opsForValue().set(&quot;code&quot;,&quot;1234&quot;,3, TimeUnit.MINUTES); redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;,&quot;1&quot;); redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;,&quot;2&quot;); &#125; 操作哈希类型数据 /** * 操作哈希类型的数据 */ @Test public void testHash()&#123; //hset hget hdel hkeys hvals HashOperations hashOperations = redisTemplate.opsForHash(); hashOperations.put(&quot;100&quot;,&quot;name&quot;,&quot;tom&quot;); hashOperations.put(&quot;100&quot;,&quot;age&quot;,&quot;20&quot;); String name = (String) hashOperations.get(&quot;100&quot;, &quot;name&quot;); System.out.println(name); Set keys = hashOperations.keys(&quot;100&quot;); System.out.println(keys); List values = hashOperations.values(&quot;100&quot;); System.out.println(values); hashOperations.delete(&quot;100&quot;,&quot;age&quot;); &#125; 操作列表类型数据 /** * 操作列表类型的数据 */ @Test public void testList()&#123; //lpush lrange rpop llen ListOperations listOperations = redisTemplate.opsForList(); listOperations.leftPushAll(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); listOperations.leftPush(&quot;mylist&quot;,&quot;d&quot;); List mylist = listOperations.range(&quot;mylist&quot;, 0, -1); System.out.println(mylist); listOperations.rightPop(&quot;mylist&quot;); Long size = listOperations.size(&quot;mylist&quot;); System.out.println(size); &#125; 操作集合类型数据 /** * 操作集合类型的数据 */ @Test public void testSet()&#123; //sadd smembers scard sinter sunion srem SetOperations setOperations = redisTemplate.opsForSet(); setOperations.add(&quot;set1&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;); setOperations.add(&quot;set2&quot;,&quot;a&quot;,&quot;b&quot;,&quot;x&quot;,&quot;y&quot;); Set members = setOperations.members(&quot;set1&quot;); System.out.println(members); Long size = setOperations.size(&quot;set1&quot;); System.out.println(size); Set intersect = setOperations.intersect(&quot;set1&quot;, &quot;set2&quot;); System.out.println(intersect); Set union = setOperations.union(&quot;set1&quot;, &quot;set2&quot;); System.out.println(union); setOperations.remove(&quot;set1&quot;,&quot;a&quot;,&quot;b&quot;); &#125; 操作有序集合类型数据 /** * 操作有序集合类型的数据 */ @Test public void testZset()&#123; //zadd zrange zincrby zrem ZSetOperations zSetOperations = redisTemplate.opsForZSet(); zSetOperations.add(&quot;zset1&quot;,&quot;a&quot;,10); zSetOperations.add(&quot;zset1&quot;,&quot;b&quot;,12); zSetOperations.add(&quot;zset1&quot;,&quot;c&quot;,9); Set zset1 = zSetOperations.range(&quot;zset1&quot;, 0, -1); System.out.println(zset1); zSetOperations.incrementScore(&quot;zset1&quot;,&quot;c&quot;,10); zSetOperations.remove(&quot;zset1&quot;,&quot;a&quot;,&quot;b&quot;); &#125; 通用命令操作 /** * 通用命令操作 */ @Test public void testCommon()&#123; //keys exists type del Set keys = redisTemplate.keys(&quot;*&quot;); System.out.println(keys); Boolean name = redisTemplate.hasKey(&quot;name&quot;); Boolean set1 = redisTemplate.hasKey(&quot;set1&quot;); for (Object key : keys) &#123; DataType type = redisTemplate.type(key); System.out.println(type.name()); &#125; redisTemplate.delete(&quot;mylist&quot;); &#125;","tags":["java","redis","spring"],"categories":["技术分享"]},{"title":"Redis","path":"/post/bae4ff13/","content":"什么是redis redis是一款基于内存存储的开源NoSQL数据库，存储形式是基于key-value来进行存储的，提供了5种基本类型例如String，List，set，Zset，hash，一般可以用于作为业务与数据库之间的缓存中间件，或者作为数据库，实现消息队列，排行榜，好友关注，地理信息存储。因为redis是单线程的，每个命令都具备原子性，所以避免多线程之间的资源竞争和线程切换导致的资源消耗，同时因为基于内存存储，并且通过IO的多路复用，实现了低延迟速度快的特点。虽然基于内存，但是提供了数据持久化的解决方案，并且提供了主从复制和哨兵机制来实现redis的高可用，同时可以通过部署分片集群来支持海量数据的存储。 redis安装 windows 实际上并不推荐在windows上安装redis，Redis官方也没有提供Windows版本的安装包。 不过可以网上下载一下平时使用也能满足大部分需要。 linux 安装Redis依赖 redis是基于C语言编写的，所以需要先安装redis所需要的gcc依赖 yum install -y gcc tcl 到redis官网下载最新版的安装包Download | Redis 将安装包上传至linux虚拟机 到达上传目录 解压缩： tar -xzf redis-7.2.1.tar.gz 解压后进入redis目录 cd redis-7.2.1 运行编译命令： make &amp;&amp; make install 我们使用 cd /usr/local/bin [root@localhost local]# ll /usr/local/bin总用量 41668-rwxr-xr-x. 1 root root 6900720 9月 9 23:48 redis-benchmarklrwxrwxrwx. 1 root root 12 9月 9 23:48 redis-check-aof -&gt; redis-serverlrwxrwxrwx. 1 root root 12 9月 9 23:48 redis-check-rdb -&gt; redis-server-rwxr-xr-x. 1 root root 7619712 9月 9 23:48 redis-clilrwxrwxrwx. 1 root root 12 9月 9 23:48 redis-sentinel -&gt; redis-server-rwxr-xr-x. 1 root root 15411608 9月 9 23:48 redis-server 看到如下目录即是安装成功 该目录以及默认配置到环境变量，因此可以在任意目录下运行这些命令。其中： redis-cli：是redis提供的命令行客户端 redis-server：是redis的服务端启动脚本 redis-sentinel：是redis的哨兵启动脚本 redis启动 安装完成后，在任意目录输入redis-server命令即可启动Redis： redis-server image-20230909235730879 这种启动属于前台启动，会阻塞整个会话窗口，窗口关闭或者按下CTRL + C则Redis停止。不推荐使用。 指定配置启动 如果要让Redis以后台方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（/usr/local/redis/redis-7.2.1），名字叫redis.conf： 我们先将这个配置文件备份一份： cp redis.conf redis.conf.bck 然后修改redis.conf文件中的一些配置： # 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0bind 0.0.0.0# 守护进程，修改为yes后即可后台运行daemonize yes # 密码，设置后访问Redis必须输入密码requirepass 123321 Redis的其它常见配置： # 监听的端口port 6379# 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录dir .# 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15databases 1# 设置redis能够使用的最大内存maxmemory 512mb# 日志文件，默认为空，不记录日志，可以指定日志文件名logfile &quot;redis.log&quot; 启动Redis： # 进入redis安装目录 cd /usr/local/redis/redis-7.2.1# 启动redis-server redis.conf 停止服务： # 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，# 因为之前配置了密码，因此需要通过 -u 来指定密码redis-cli -u 你的密码 shutdown 1.3.3.开机自启 我们也可以通过配置来实现开机自启。 首先，新建一个系统服务文件： vi /etc/systemd/system/redis.service 内容如下： [Unit]Description=redis-serverAfter=network.target[Service]Type=forkingExecStart=/usr/local/bin/redis-server /usr/local/redis/redis-7.2.1/redis.confPrivateTmp=true[Install]WantedBy=multi-user.target 然后重载系统服务： systemctl daemon-reload 现在，我们可以用下面这组命令来操作redis了： # 启动systemctl start redis# 停止systemctl stop redis# 重启systemctl restart redis# 查看状态systemctl status redis 执行下面的命令，可以让redis开机自启： systemctl enable redis redis的基本数据类型 String Redis 字符串存储字节序列，包括文本、序列化对象和二进制数组。 因此，字符串是可以关联的最简单的值类型 一个 Redis 键。 默认情况下，单个 Redis 字符串的最大大小为 512 MB。 大多数字符串操作都是 O（1），这意味着它们非常高效。 但是，请注意 SUBSTR、GETRANGE 和 SETRANGE 命令，它们可以是 O（n）。 hash Redis hash是结构化为字段值对集合的记录类型，Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。 大多数 Redis 哈希命令都是 O（1）。 一些命令（如 HKEYS、HVALS 和 HGETALL）是 O（n），其中 n 是字段值对的数量。 list Redis中的List其实就是链表（Redis用双端链表实现List）。 列表对于许多任务很有用，这是两个非常有代表性的用例 如下： 记住用户发布到社交网络中的最新更新。 进程之间的通信，使用使用者-生产者模式，其中生产者将项目推送到列表中，使用者（通常是工作人员）使用这些项目并执行操作。Redis 具有特殊的列表命令，使此用例更加可靠和高效。 访问其头部或尾部的列表操作是 O（1），这意味着它们非常高效。 但是，操作列表中元素的命令通常是 O（n）。 这些示例包括 LINDEX、LINSERT 和 LSET。 运行这些命令时要小心，主要是在对大型列表进行操作时。 set Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。 Redis 集是唯一字符串（成员）的无序集合。 您可以使用 Redis 集有效地： 跟踪唯一项目（例如，跟踪访问给定博客文章的所有唯一 IP 地址）。 表示关系（例如，具有给定角色的所有用户的集合）。 执行常见的集合操作，例如交集、并集和差分。 大多数集合操作（包括添加、删除和检查项是否为集合成员）都是 O（1）。 这意味着它们非常高效。 但是，对于具有数十万或更多成员的大型集，在运行 SMEMBERS 命令时应格外小心。 此命令为 O（n），并在单个响应中返回整个集合。 作为替代方法，请考虑 SSCAN，它允许您以迭代方式检索集合的所有成员。 sortedSet Redis 排序集是按关联分数排序的唯一字符串（成员）的集合。 当多个字符串具有相同的分数时，字符串将按字典顺序排序。 排序集的一些用例包括： 排行榜。例如，您可以使用排序集轻松维护大型在线游戏中最高分的有序列表。 速率限制器。特别是，您可以使用排序集来构建滑动窗口速率限制器，以防止过多的 API 请求。 大多数排序集合运算是 O（log（n）），其中 n 是成员数。 在运行具有较大返回值（例如，数万或更多）的 ZRANGE 命令时要小心。 此命令的时间复杂度为 O（log（n） + m），其中 m 是返回的结果数。 redis常用命令 通用命令 通用指令是部分数据类型的，都可以使用的指令，常见的有： KEYS：查看符合模板的所有key DEL：删除一个指定的key EXISTS：判断key是否存在 EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除 TTL：查看一个KEY的剩余有效期 String String的常见命令有： # SET：添加或者修改已经存在的一个String类型的键值对set key value # GET：根据key获取String类型的valueget key image-20230910094421648 # MSET：批量添加多个String类型的键值对mset key value [key value ... key value]# MGET：根据多个key获取多个String类型的valuemget key key ... key image-20230910095004564 # INCR/DECR：让一个整型的key自增1/自减1incr/decr key# INCRBY/DECRBY:让一个整型的key自增/自减并指定步长，例如：incrby age:ezhixuan 2 让age值自增2incrby/decrby key increment/decrement# INCRBYFLOAT：让一个浮点类型的数字自增并指定步长incrbyfloat key increment image-20230910095620287 对于incr/decr在实际使用中直接使用incrby指定步长即可，增加填写正数，减少填写负数 若key不存在时会先初始化为0再进行操作 若key的存储值不能被解释为数字，则返回错误 # SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行setnx key value image-20230910100324015 # SETEX：添加一个String类型的键值对，并且指定有效期setex key seconds value# TTL：查看一个KEY的剩余有效期ttl key image-20230910100641315 Hash Hash的常见命令有： # HSET 添加或者修改hash类型key的field的值hset key field value [field value ... field value]# HGETALL：获取一个hash类型的key中的所有的field和valuehgetall key# HGET：获取一个hash类型key的field的valuehget key field# HKEYS：获取一个hash类型的key中的所有的fieldhkeys key# HVALS: 获取一个hash类型的key中所有的field的valuehvals key# HMGET：批量获取多个hash类型key的field的值hmget key field [field ... field] image-20230910102106812 image-20230910102505152 # HINCRBY:让一个hash类型key的字段值自增并指定步长 wagehincrby key field increment image-20230910102816901 若key不存在时会先初始化为0再进行操作 若key的存储值不能被解释为数字，则返回错误 # HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行hsetnx key field value image-20230910103001935 List List的常见命令有： # LPUSH(RPUSH):向列表左(右)侧插入一个或多个元素lpush(rpush) key value image-20230910103617539 此时列表里应该是有 2 3 9 8 # LLEN: 返回列表长度llen key# LRANGE:返回一段角标范围内的所有元素lrange key start stop# LINDEX:返回列表中对应下标的元素lindex key index image-20230910104219300 image-20230910104231479 image-20230910104322343 # LPOP(RPOP)：移除并返回列表左(右)侧的第一个元素，没有则返回nillpop(rpop) key# BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nilblpop(brpop) key timeout image-20230910104554375 image-20230910104723789 此时会发生阻塞，等待100秒，在这100秒内，我另起一个控制台添加元素，则会被监听到并移除 image-20230910104847624 image-20230910104855681 Set Set的常见命令有： # SADD:向set中添加一个或多个元素sadd key member [member ... member]# SISMEMBER:判断一个元素是否存在于set中sismember key member# SMEMBERS:获取set中的所有元素smembers key# SCARD: 获取set中的元素个数scard key image-20230910111015754 # SRANDMEMBER:随机获取set中指定个数的元素(超过大小返回全部)srandmember key [count]# SPOP:与SRANDMEMBER类似，差别在于SPOP获取并移除指定个数的元素spop key [count]# SREM:移除set中的指定元素srem key member [member ... member] image-20230910111103188 image-20230910111141708 image-20230910111259652 # SINTER: 求多个集合的交集sinter key key [key]# SUNION: 求多个集合的并集sunion key key [key]# SDIFF: 求多个集合的差集sdiff key key [key] image-20230910111542814 sortedSet SortedSet的常见命令有： # ZADD:添加一个或多个元素到sorted set ，如果已经存在则更新其score值zadd key score member [score member ... score member]# ZSCORE:获取sorted set中的指定元素的score值zscore key member# ZCARD:获取sorted set中的元素个数zcard key# ZRANK(ZREVRANK):升序(降序)获取sorted set 中的指定元素的排名zrank key member# ZCOUNT:统计score值在给定范围内的所有元素的个数zcount key min max# ZRANGE(ZREVRANGE):按照score排序后，升序(降序)获取指定排名范围内的元素zrange key min max# ZRANGEBYSCORE(ZREVRANGEBYSCORE):按照score排序后，升序(降序)获取指定score范围内的元素zrangebyscore key min max image-20230910151725241 image-20230910151738447 image-20230910151746275 # ZINCRBY:让sorted set中的指定元素自增，步长为指定的increment值zincrby key increment member# ZREM:删除sorted set中的一个或多个指定元素zrem key member [member ... member] image-20230910152127127 image-20230910152237788 所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如： 升序获取sorted set 中的指定元素的排名：ZRANK key member 降序获取sorted set 中的指定元素的排名：ZREVRANK key memeber 其他数据类型 bitmap Redis的Bitmap是一种位图数据结构，用于在Redis中高效地存储和处理位操作。它以比特（bit）为单位进行存储和操作，可以用来表示某个特定事件的存在与否，比如用户签到、用户在线状态等。 Bitmap在Redis中以字符串形式存储，每个字节可以存储8个位（8个比特），即一个字节可以表示8个事件的状态。Bitmap可以动态地自动扩展以适应需要存储的位数。 Redis提供了一系列的位操作命令来操作Bitmap，包括设置指定位置的位值、获取指定位置的位值、统计指定范围内的位值为1的个数、对两个Bitmap进行逻辑运算等。 以下是一些常用的Bitmap命令和示例： SETBIT key offset value：设置指定位置的位值为1或0。 SETBIT mybitmap 0 1 GETBIT key offset：获取指定位置的位值。 GETBIT mybitmap 0 BITCOUNT key [start end]：统计指定范围内的位值为1的个数。 BITCOUNT mybitmap 0 9 BITOP operation destkey key [key ...]：对一个或多个Bitmap执行逻辑运算，并将结果存储到destkey中。操作可以是AND、OR、XOR、NOT等。 BITOP AND resultbitmap mybitmap1 mybitmap2 Bitmap在存储和处理大规模位数据时非常高效，它占用的内存空间相对较小，并且各种位操作可以在常数时间内完成。因此，它可以用于各种场景，如数据统计、布隆过滤器、用户在线状态跟踪等。 Geo(Geospatial) GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。此数据结构可用于查找给定半径或边界框内的邻近点。","tags":["java","redis"],"categories":["技术分享"]},{"title":"使用腾讯云Cos实现上传下载","path":"/post/e2534ec2/","content":"本文中出现的所有xiaomo.txcos 均可替换成任意自己填入 使用腾讯云cos实现上传下载 导入依赖 &lt;dependency&gt; &lt;groupId&gt;com.qcloud&lt;/groupId&gt; &lt;artifactId&gt;cos_api&lt;/artifactId&gt; &lt;version&gt;5.6.167&lt;/version&gt;&lt;/dependency&gt; 设置上传文件大小 servlet: multipart: max-request-size: 1024MB max-file-size: 1024MB 配置文件，通过配置文件填入对应数值。 xiaomo: txcos: tmpSecretId: # 你的secretId tmpSecretKey: # 你的secretKey bucketName: # 你的bucketName region: # 你仓库的地址 /** * @program: xiaomo-take-out * @description: 腾讯云Cos * @author: Mr.Xuan * @create: 2023-09-08 10:13 */@Component@Slf4j@Data@ConfigurationProperties(prefix = &quot;xiaomo.txcos&quot;)public class TencentCosProperties &#123; private String tmpSecretId; private String tmpSecretKey; private String bucketName; private String region; &#125; 通过IOC初始化Bean /** * @program: xiaomo-take-out * @description: * @author: Mr.Xuan * @create: 2023-09-08 10:46 */@Configuration@Slf4jpublic class CosConfiguration &#123; @Bean @ConditionalOnMissingBean public TencentCosUtil tencentCosUtil(TencentCosProperties tencentCosProperties) &#123; log.info(&quot;开始创建腾讯云文件上传对象&#123;&#125;&quot;, tencentCosProperties); TencentCosUtil tencentCosUtil = new TencentCosUtil( tencentCosProperties.getTmpSecretId(), tencentCosProperties.getTmpSecretKey(), tencentCosProperties.getBucketName(), tencentCosProperties.getRegion()); return tencentCosUtil; &#125;&#125; 导入上传工具类 /** * @program: xiaomo-take-out * @description: cos工具类 * @author: Mr.Xuan * @create: 2023-09-08 11:47 */@Data@AllArgsConstructor@Slf4jpublic class TencentCosUtil &#123; private String tmpSecretId; private String tmpSecretKey; private String bucketName; private String region; public String upload(MultipartFile file) &#123; // 创建COSClient实例 ClientConfig clientConfig = new ClientConfig(new Region(region)); clientConfig.setHttpProtocol(HttpProtocol.https); COSClient cosClient = new COSClient(new BasicCOSCredentials(tmpSecretId, tmpSecretKey), clientConfig); try &#123; // 获取上传文件的输入流 InputStream inputStream = file.getInputStream(); // 对象键(Key)是对象在存储桶中的唯一标识。 String substring = Objects.requireNonNull(file.getOriginalFilename()) .substring(file.getOriginalFilename().lastIndexOf(&quot;.&quot;)); String key = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;) + substring; // 对上传文件分组 String dateUrl = new DateTime().toString(&quot;yyyy/MM/dd&quot;); key = dateUrl + &quot;/&quot; + key; ObjectMetadata objectMetadata = new ObjectMetadata(); PutObjectRequest putObjectRequest = new PutObjectRequest(bucketName, key, inputStream, objectMetadata); PutObjectResult putObjectResult = cosClient.putObject(putObjectRequest); System.out.println(JSON.toJSONString(putObjectResult)); // 返回上传文件路径 StringBuilder stringBuilder = new StringBuilder(&quot;https://&quot;); stringBuilder .append(bucketName) .append(&quot;.cos.&quot;) .append(region) .append(&quot;.myqcloud.com/&quot;) .append(key); return stringBuilder.toString(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 最后到需要使用的地方自动装配工具类使用即可 这里以Impl为例 /** * @program: xiaomo-take-out * @description: * @author: Mr.Xuan * @create: 2023-09-08 11:38 */@Servicepublic class CommonServiceImpl implements CommonService&#123; @Resource private TencentCosUtil tencentCosUtil; /** * 文件上传 * * @param file * @return */ @Override public Result&lt;String&gt; upload(MultipartFile file) &#123; String upload = tencentCosUtil.upload(file); return Result.success(upload); &#125;&#125;","tags":["java","腾讯云","cos"],"categories":["java"]},{"title":"公共字段自动填充","path":"/post/781a6a1a/","content":"使用Mp实现公共字段自动填充 需要实现自动填充的字段上添加@TableFile标签，指定自动填充策略。 实现MetaObjectHandler接口 .../** 创建时间 */@TableField(fill = FieldFill.INSERT)private LocalDateTime createTime;/** 更新时间 */@TableField(fill = FieldFill.INSERT_UPDATE)private LocalDateTime updateTime;/** 创建人 */@TableField(fill = FieldFill.INSERT)private Long createUser;/** 修改人 */@TableField(fill = FieldFill.INSERT_UPDATE)private Long updateUser;... package com.xiaomo.handler;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;import com.xiaomo.context.BaseContext;import java.time.LocalDateTime;import lombok.extern.slf4j.Slf4j;import org.apache.ibatis.reflection.MetaObject;import org.springframework.stereotype.Component;/** * @program: xiaomo-take-out * @description: 实现公共字段自动填充 * @author: Mr.Xuan * @create: 2023-09-08 07:47 */@Component@Slf4jpublic class MpHandler implements MetaObjectHandler &#123; /** * 插入元对象字段填充（用于插入时对公共字段的填充） * * @param metaObject 元对象 */ @Override public void insertFill(MetaObject metaObject) &#123; log.info(&quot;开始插入填充&quot;); this.strictInsertFill(metaObject, &quot;createUser&quot;, Long.class, BaseContext.getCurrentId()); this.strictInsertFill(metaObject, &quot;createTime&quot;, LocalDateTime.class, LocalDateTime.now()); this.strictInsertFill(metaObject, &quot;updateUser&quot;, Long.class, BaseContext.getCurrentId()); this.strictInsertFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now()); &#125; /** * 更新元对象字段填充（用于更新时对公共字段的填充） * * @param metaObject 元对象 */ @Override public void updateFill(MetaObject metaObject) &#123; log.info(&quot;开始更新填充&quot;); this.strictUpdateFill(metaObject, &quot;updateUser&quot;, Long.class, BaseContext.getCurrentId()); this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now()); &#125;&#125; 此处BaseContext是由ThreadLocal获取。 /** * 字段填充策略枚举类 * * &lt;p&gt; * 判断注入的 insert 和 update 的 sql 脚本是否在对应情况下忽略掉字段的 if 标签生成 * &lt;if test=&quot;...&quot;&gt;......&lt;/if&gt; * 判断优先级比 &#123;@link FieldStrategy&#125; 高 * &lt;/p&gt; * * @author hubin * @since 2017-06-27 */public enum FieldFill &#123; /** * 默认不处理 */ DEFAULT, /** * 插入时填充字段 */ INSERT, /** * 更新时填充字段 */ UPDATE, /** * 插入和更新时填充字段 */ INSERT_UPDATE&#125;","tags":["java","学习分享"],"categories":["java"]},{"title":"Hexo添加字数统计","path":"/post/5904fa7e/","content":"本篇文章使用的是hexo-stellar主题 footer.ejs 首先找到node_modules/hexo-theme-stellar/layout/_partial/main/footer.ejs文件 末尾可直接复制整个footer.ejs文件 找到该代码所处区域 // footer el += &#x27;&lt;div class=&quot;text&quot;&gt;&#x27;; if (content) &#123; if ((typeof content == &#x27;string&#x27;) &amp;&amp; content.constructor == String) &#123; el += markdown(content); &#125; else if ((typeof content == &#x27;object&#x27;) &amp;&amp; content.constructor == Array) &#123; content.forEach((item, i) =&gt; &#123; el += markdown(item); &#125;); &#125; &#125; 在其尾部添加代码 if (theme.footer.up_time) &#123; el += &#x27;&lt;div&gt;&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;&#x27;; if (theme.footer.busuanzi.enable) &#123; el += &#x27;，&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;总访问量: &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;&#x27;; el += &#x27;，&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;访客数: &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人&lt;/span&gt;&#x27;; &#125; el += &#x27;&lt;/div&gt;&#x27; &#125; 最后在最底部添加代码 &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;script&gt; function createtime() &#123; var now = new Date(); var grt= new Date(&quot;09/01/2023 00:00:00&quot;); now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125; document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已运行 &quot;+dnum+&quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; &#125;; setInterval(&quot;createtime()&quot;,250);&lt;/script&gt; 最终代码 &lt;%const content = theme.footer.content;function layoutDiv() &#123; var el = &#x27;&#x27;; el += &#x27;&lt;footer class=&quot;page-footer reveal fs12&quot;&gt;&#x27;; el += &#x27;&lt;hr&gt;&#x27;; // sitemap if (theme.footer.sitemap &amp;&amp; Object.keys(theme.footer.sitemap).length &gt; 0) &#123; el += &#x27;&lt;div class=&quot;sitemap&quot;&gt;&#x27;; for (let group of Object.keys(theme.footer.sitemap)) &#123; let items = theme.footer.sitemap[group]; if (items == undefined || items.length == 0) &#123; continue; &#125; el += &#x27;&lt;div class=&quot;sitemap-group&quot;&gt;&#x27;; el += &#x27;&lt;span class=&quot;fs14&quot;&gt;&#x27; + group + &#x27;&lt;/span&gt;&#x27;; items.forEach((item, i) =&gt; &#123; el += &#x27;&lt;a href=&quot;&#x27; + url_for(md_link(item)) + &#x27;&quot;&gt;&#x27;; el += __(md_text(item)); el += &#x27;&lt;/a&gt;&#x27;; &#125;); el += &#x27;&lt;/div&gt;&#x27;; &#125; el += &#x27;&lt;/div&gt;&#x27;; &#125; // footer el += &#x27;&lt;div class=&quot;text&quot;&gt;&#x27;; if (content) &#123; if ((typeof content == &#x27;string&#x27;) &amp;&amp; content.constructor == String) &#123; el += markdown(content); &#125; else if ((typeof content == &#x27;object&#x27;) &amp;&amp; content.constructor == Array) &#123; content.forEach((item, i) =&gt; &#123; el += markdown(item); &#125;); &#125; &#125; if (theme.footer.up_time) &#123; el += &#x27;&lt;div&gt;&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;&#x27;; if (theme.footer.busuanzi.enable) &#123; el += &#x27;，&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;总访问量: &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;&#x27;; el += &#x27;，&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;访客数: &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人&lt;/span&gt;&#x27;; &#125; el += &#x27;&lt;/div&gt;&#x27; &#125; el += &#x27;&lt;/div&gt;&lt;/footer&gt;&#x27;; return el;&#125;%&gt;&lt;%- layoutDiv() %&gt;&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;script&gt; function createtime() &#123; var now = new Date(); var grt= new Date(&quot;09/01/2023 00:00:00&quot;); now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125; document.getElementById(&quot;timeDate&quot;).innerHTML = &quot;本站已运行 &quot;+dnum+&quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; &#125;; setInterval(&quot;createtime()&quot;,250);&lt;/script&gt; _config.yml 在主题目录（不是根目录） node_modules/hexo-theme-stellar/_config.yml添加如下配置即可 ######## Footer ########footer: ... up_time: enable: true busuanzi: enable: true","tags":["hexo"],"categories":["hexo"]},{"title":"数据库表自增问题","path":"/post/4fc13300/","content":"数据库表自增问题 前言：因为在使用mp时没有在配置文件中设置自增策略，也没有使用@TableId注解去修饰id字段，导致数据库中的id在添加时使用mp默认的雪花算法，但这并不是我期望在本表中使用的，所以需要修改 首先我赶紧在id字段上添加上@TableId(type = IdType.AUTO) 好消息是id变成+1的自增了 坏消息是仍然保持了最迟一次生成的雪花值在+1自增，即使这个雪花值已经被删除。 MySQL 是一个开源的关系型数据库管理系统，广泛应用于各种企业和互联网应用中。在 MySQL 数据库中，自增键是一种非常常用的类型，能够简化开发者的开发工作。但有时候我们需要能够动态修改自增值。下面介绍一下如何使用 MySQL 实现动态修改自增值的方法。 ALTER TABLE tableName AUTO_INCREMENT = value; 以上代码可以改变指定表的 AUTO_INCREMENT 值，设置自增键的下一个值为 value。首先需要了解的是，MySQL 中自增键是用于提供唯一值的一种类型，即每个自增键值都必须是唯一的。我们可以通过以下步骤实现动态修改自增值： 查看数据库中的所有表： SHOW TABLES; 确定需要修改自增值的表。 查看表的结构信息： DESCRIBE tableName; 确定需要修改自增值的字段和表名。 使用ALTER TABLE命令修改自增值： ALTER TABLE tableName AUTO_INCREMENT = value; 将自增键的下一个值设置为指定的value。 通过以上步骤，就可以在MySQL数据库中实现动态修改自增值。","tags":["mysql","问题处理"],"categories":["mysql"]},{"title":"Hexo文章图片显示","path":"/post/528f971c/","content":"配置 直接进入到你hexo的目录，右键打开git bash命令行，执行npm install hexo-asset-image –save 接着node_modules -&gt; hexo-asset-image -&gt; index.js 第58行找到，或者直接全局搜索也行 修改为 image-20230905132247109 然后在hexo目录的_config.yml配置文件中设置 image-20230905132432534 每次生成new 一篇文章的时候会自动再同目录下生成相同名的文件夹，该文件夹下存放你的图片地址 如果使用typora软件的话，进行如下配置，在插入图片时会自动插入到同名文件夹下 image-20230905132639300","tags":["hexo"],"categories":["hexo"]},{"title":"Knife4j","path":"/post/3ba05f4e/","content":"Knife4j 是日常开发中很常用的框架，基于此框架，后端可以和前端开发人员进行高效沟通。 详细使用可以参考官方文档Knife4j · 集Swagger2及OpenAPI3为一体的增强解决方案. | Knife4j (xiaominfo.com) 快速入门 Swagger&amp;&amp;knife4j 导入依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-openapi2-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;4.3.0&lt;/version&gt;&lt;/dependency&gt; 开启增强 knife4j: enable: true 配置类 package com.ezhixuan.knife4jquickstart.config;import com.github.xiaoymin.knife4j.spring.annotations.EnableKnife4j;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;/** * @program: knife4j-quickstart * @description: knife4j配置类 * @author: Mr.Xuan * @create: 2023-09-05 09:29 **/@Slf4j@EnableKnife4j@Configurationpublic class Knife4jConfig extends WebMvcConfigurationSupport&#123; /** * 通过knife4j生成接口文档 * @return */ @Bean(value = &quot;docket&quot;) public Docket docket() &#123; log.info(&quot;正在生成接口文档&quot;); ApiInfo apiInfo = new ApiInfoBuilder() .title(&quot;xxx项目接口文档&quot;) .version(&quot;1.0&quot;) .description(&quot;xxx项目接口文档&quot;) .build(); Docket docket = new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo) .select() .apis(RequestHandlerSelectors.basePackage(&quot;com.ezhixuan.knife4jquickstart.controller&quot;)) .paths(PathSelectors.any()) .build(); return docket; &#125; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(&quot;doc.html&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/&quot;); registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;); super.addResourceHandlers(registry); &#125;&#125; controller package com.ezhixuan.knife4jquickstart.controller;import com.ezhixuan.knife4jquickstart.pojo.entity.User;import io.swagger.annotations.Api;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiOperation;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.*;/** * @program: knife4j-quickstart * @description: controller-demo * @author: Mr.Xuan * @create: 2023-09-05 09:31 **/@Api(tags = &quot;你好&quot;)@RestController@RequestMapping(&quot;/hello&quot;)public class HelloController &#123; @ApiOperation(value = &quot;向客人问好&quot;) @ApiImplicitParam(name = &quot;name&quot;, value = &quot;用户名&quot;, required = true, paramType = &quot;String&quot;) @GetMapping(&quot;/sayHi&quot;) public ResponseEntity&lt;String&gt; sayHi(@RequestParam(&quot;name&quot;)String name)&#123; return ResponseEntity.ok(&quot;Hi:&quot;+name); &#125; @PostMapping(&quot;/login&quot;) @ApiOperation(value = &quot;登录&quot;) public ResponseEntity&lt;String&gt; login(@RequestBody User user) &#123; return ResponseEntity.ok(&quot;login&quot;); &#125;&#125; pojo package com.ezhixuan.knife4jquickstart.pojo.entity;import io.swagger.annotations.ApiModelProperty;import lombok.Data;/** * @program: knife4j-quickstart * @description: 用户信息 * @author: Mr.Xuan * @create: 2023-09-05 09:33 **/@Datapublic class User &#123; @ApiModelProperty(value = &quot;用户名&quot;, required = true, example = &quot;张三&quot;) private String userName; @ApiModelProperty(value = &quot;密码&quot;, required = true, example = &quot;123456&quot;) private String password;&#125; image-20230905112951285 image-20230905113002420 image-20230905113013447 常用注解 注解 作用 使用位置 @Api 表示对类的说明常用参数 类上面 @ApiOperation 说明方法的用途、作用 方法上面 @ApiModel 表示一个返回响应数据的信息 响应类 @ApiModelProperty 描述响应类的属性 属性 @ApiImplicitParams 参数注解 方法上 @Api 标识一个java类型是文档类，用在controller类的类名上 value: 字符串类型，对controller类的作用进行描述 tags: 字符串数组，同样对controller类的作用进行描述 示例代码： @Api(tags = &quot;你好&quot;)@RestController@RequestMapping(&quot;/hello&quot;)public class HelloController &#123;&#125; @ApiOperation 作用在接口类的方法上，控制方法的相关描述 value：字符串，方法的功能描述 tags：字符串数组，标签组，同样可以描述方法的作用； response：ClassType，显示指出返回的对象类型；在响应示例中会显示出改对象的字段以及示例、描述 code：响应代码，默认200，一般不改； 示例代码: @ApiOperation(value = &quot;向客人问好&quot;) @ApiImplicitParam(name = &quot;name&quot;, value = &quot;用户名&quot;, required = true, paramType = &quot;String&quot;) @GetMapping(&quot;/sayHi&quot;) public ResponseEntity&lt;String&gt; sayHi(@RequestParam(&quot;name&quot;)String name)&#123;&#125; @ApiModel 表示一个实体类/模型文档，用在类名上 value: 字符串类型，设置模型别名 description: 字符串，对模型进行描述 示例代码: @Data@ApiModel(value = &quot;用户登录信息&quot;, description = &quot;判断用户登录状况&quot;)public class User &#123;&#125; @ApiModelProperty 作用在属性上，添加属性描述 value：字符串，字段描述； required：boolean；指定参数是否必须，默认false； example：字符串，参数值的示例 示例代码: @ApiModelProperty(value = &quot;用户名&quot;, required = true, example = &quot;张三&quot;) private String userName; @ApiImplicitParams （@ApiImplicitParam 对单个参数）用在请求的方法上，包含一组参数说明 name：参数名 value：参数的说明、描述 required：参数是否必须必填 paramType：参数放在哪个地方 · query --&gt; 请求参数的获取：@RequestParam · header --&gt; 请求参数的获取：@RequestHeader · path（用于restful接口）–&gt; 请求参数的获取：@PathVariable · body（请求体）–&gt; @RequestBody User user · form（普通表单提交） dataType：参数类型，默认String，其它值dataType=“Integer” dataTypeClass: 类属性，填写dataType的类，不填也没关系但是控制台会给一个警告提示。 defaultValue：参数的默认值 示例代码： @ApiOperation(value = &quot;向客人问好&quot;) @ApiImplicitParams(&#123; @ApiImplicitParam(name = &quot;name&quot;, value = &quot;用户名&quot;, required = true, dataType = &quot;String&quot;), @ApiImplicitParam(...) &#125; ) @GetMapping(&quot;/sayHi&quot;) public ResponseEntity&lt;String&gt; sayHi(@RequestParam(&quot;name&quot;)String name)&#123;&#125;@ApiOperation(value = &quot;向客人问好&quot;) @ApiImplicitParam(name = &quot;name&quot;, value = &quot;用户名&quot;, required = true, dataType = &quot;String&quot;) @GetMapping(&quot;/sayHi&quot;) public ResponseEntity&lt;String&gt; sayHi(@RequestParam(&quot;name&quot;)String name)&#123;&#125; 补充 Unable to interpret the implicit parameter configuration with dataType: Integer, dataTypeClass: class java.lang.Void image-20230906145315400 启动时发现说dataType与dataTypeClass不符。 是在配置 @ApiImplicitParam(name = &quot;id&quot;, value = &quot;员工id&quot;, required = true, dataType = &quot;Integer&quot;, dataTypeClass = Integer.class) 时漏填或者填错dataTypeClass，修改一致即可。","tags":["java","knife4j"],"categories":["技术分享"]},{"title":"Xxl-Job","path":"/post/586965a7/","content":"xxl-job XXL-JOB是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。 源码地址：xxl-job: 一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。 文档地址：分布式任务调度平台XXL-JOB (xuxueli.com) 分布式任务调度 为什么使用xxl-job xxl-job是一款分布式任务调度的开源框架 与Springboot提供的@scheduled定时任务相比 @Scheduled存在以下问题 定时任务失败无法重试 在处理集群任务时会出现重复执行的问题 cron表达式定义在代码之中，不方便修改 当任务量过大时，无法有效分片执行 使用xxl-job来解决这些问题 什么是分布式任务调度 当前软件的架构已经向分布式架构转变，将单体项目拆分成若干服务，服务之间通过网络交互来完成业务处理。在分布式架构下，一个服务往往会部署多个实例来运行业务，在这种分布式系统环境下运行任务调度，称为分布式调度 ​\t1、并行任务调度 并行任务调度实现靠多线程，如果有大量任务需要调度，此时光靠多线程就会有瓶颈了，因为一台计算机CPU的处理能力是有限的。 如果将任务调度程序分布式部署，每个结点还可以部署为集群，这样就可以让多台计算机共同去完成任务调度，我们可以将任务分割为若干个分片，由不同的实例并行执行，来提高任务调度的处理效率。 ​\t2、高可用 若某一个实例宕机，不影响其他实例来执行任务。 ​\t3、弹性扩容 当集群中增加实例就可以提高并执行任务的处理效率。 ​\t4、任务管理与监测 对系统中存在的所有定时任务进行统一的管理及监测。让开发人员及运维人员能够时刻了解任务执行情况，从而做出快速的应急处理响应。 分布式任务调度面临的问题： 当任务调度以集群方式部署，同一个任务调度可能会执行多次，例如：电商系统定期发放优惠券，就可能重复发放优惠券，对公司造成损失，信用卡还款提醒就会重复执行多次，给用户造成烦恼，所以我们需要控制相同的任务在多个运行实例上只执行一次。常见解决方案： 分布式锁，多个实例在任务执行前首先需要获取锁，如果获取失败那么就证明有其他服务已经在运行，如果获取成功那么证明没有服务在运行定时任务，那么就可以执行。 ZooKeeper选举，利用ZooKeeper对Leader实例执行定时任务，执行定时任务的时候判断自己是否是Leader，如果不是则不执行，如果是则执行业务逻辑，这样也能达到目的。 特性 简单灵活 提供Web页面对任务进行管理，管理系统支持用户管理、权限控制； 支持容器部署； 支持通过通用HTTP提供跨平台任务调度； 丰富的任务管理功能 支持页面对任务CRUD操作； 支持在页面编写脚本任务、命令行任务、Java代码任务并执行； 支持任务级联编排，父任务执行结束后触发子任务执行； 支持设置指定任务执行节点路由策略，包括轮询、随机、广播、故障转移、忙碌转移等； 支持Cron方式、任务依赖、调度中心API接口方式触发任务执行 高性能 任务调度流程全异步化设计实现，如异步调度、异步运行、异步回调等，有效对密集调度进行流量削峰； 高可用 任务调度中心、任务执行节点均 集群部署，支持动态扩展、故障转移 支持任务配置路由故障转移策略，执行器节点不可用是自动转移到其他节点执行 支持任务超时控制、失败重试配置 支持任务处理阻塞策略：调度当任务执行节点忙碌时来不及执行任务的处理策略，包括：串行、抛弃、覆盖策略 易于监控运维 支持设置任务失败邮件告警，预留接口支持短信、钉钉告警； 支持实时查看任务执行运行数据统计图表、任务进度监控数据、任务完整执行日志； 部署xxl-job 调度中心环境要求 Maven3+ Jdk1.8+ Mysql5.7+ 初始化调度数据库 请下载项目源码并解压，获取 “调度数据库初始化SQL脚本” 并执行即可。 位置：/xxl-job/doc/db/tables_xxl_job.sql 共8张表 - xxl_job_lock：任务调度锁表；- xxl_job_group：执行器信息表，维护任务执行器信息；- xxl_job_info：调度扩展信息表： 用于保存XXL-JOB调度任务的扩展信息，如任务分组、任务名、机器地址、执行器、执行入参和报警邮件等等；- xxl_job_log：调度日志表： 用于保存XXL-JOB任务调度的历史信息，如调度结果、执行结果、调度入参、调度机器和执行器等等；- xxl_job_logglue：任务GLUE日志：用于保存GLUE更新历史，用于支持GLUE的版本回溯功能；- xxl_job_registry：执行器注册表，维护在线的执行器和调度中心机器地址信息；- xxl_job_user：系统用户表； 调度中心支持集群部署，集群情况下各节点务必连接同一个mysql实例; 如果mysql做主从,调度中心集群节点务必强制走主库; 部署调度中心 调度中心项目：xxl-job-admin 作用：统一管理任务调度平台上调度任务，负责触发调度执行，并且提供任务管理平台。 步骤一：调度中心配置 调度中心配置文件地址：/xxl-job/xxl-job-admin/src/main/resources/application.properties 数据库的连接信息修改为自己的数据库 ### webserver.port=8888server.servlet.context-path=/xxl-job-admin### actuatormanagement.server.servlet.context-path=/actuatormanagement.health.mail.enabled=false### resourcesspring.mvc.servlet.load-on-startup=0spring.mvc.static-path-pattern=/static/**spring.resources.static-locations=classpath:/static/### freemarkerspring.freemarker.templateLoaderPath=classpath:/templates/spring.freemarker.suffix=.ftlspring.freemarker.charset=UTF-8spring.freemarker.request-context-attribute=requestspring.freemarker.settings.number_format=0.############# mybatismybatis.mapper-locations=classpath:/mybatis-mapper/*Mapper.xml#mybatis.type-aliases-package=com.xxl.job.admin.core.model### xxl-job, datasourcespring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?Unicode=true&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver### datasource-poolspring.datasource.type=com.zaxxer.hikari.HikariDataSourcespring.datasource.hikari.minimum-idle=10spring.datasource.hikari.maximum-pool-size=30spring.datasource.hikari.auto-commit=truespring.datasource.hikari.idle-timeout=30000spring.datasource.hikari.pool-name=HikariCPspring.datasource.hikari.max-lifetime=900000spring.datasource.hikari.connection-timeout=10000spring.datasource.hikari.connection-test-query=SELECT 1### xxl-job, emailspring.mail.host=smtp.qq.comspring.mail.port=25spring.mail.username=xxx@qq.comspring.mail.password=xxxspring.mail.properties.mail.smtp.auth=truespring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=truespring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory### xxl-job, access tokenxxl.job.accessToken=### xxl-job, i18n (default is zh_CN, and you can choose &quot;zh_CN&quot;, &quot;zh_TC&quot; and &quot;en&quot;)xxl.job.i18n=zh_CN## xxl-job, triggerpool max sizexxl.job.triggerpool.fast.max=200xxl.job.triggerpool.slow.max=100### xxl-job, log retention daysxxl.job.logretentiondays=30 启动调度中心， localho:8080/xxl-job-amdin 默认登录账号 “admin/123456” docker安装xxl-job 1.创建mysql容器，初始化xxl-job的SQL脚本 docker run -p 3306:3306 --name mysql57 \\-v /opt/mysql/conf:/etc/mysql \\-v /opt/mysql/logs:/var/log/mysql \\-v /opt/mysql/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=root \\-d mysql:5.7 2.拉取镜像 docker pull xuxueli/xxl-job-admin:2.3.0 3.创建容器 docker run -e PARAMS=&quot;--spring.datasource.url=jdbc:mysql://192.168.88.130:3306/xxl_job?Unicode=true&amp;characterEncoding=UTF-8 \\--spring.datasource.username=root \\--spring.datasource.password=123456&quot; \\-p 8888:8080 -v /tmp:/data/applogs \\--name xxl-job-admin --restart=always -d xuxueli/xxl-job-admin:2.3.0 任务调度中心访问地址 默认账号 admin 密码 123456 image-20230816161833815 Springboot集成xxl-job 导入依赖，与使用版本保持一致 &lt;!--xxl-job--&gt;&lt;dependency&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt; application.yml配置 server: port: 8881xxl: job: admin: addresses: http://192.168.200.130:8888/xxl-job-admin executor: appname: xxl-job-executor-sample port: 9999 新建配置类 package com.heima.xxljob.config;import com.xxl.job.core.executor.impl.XxlJobSpringExecutor;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * xxl-job config * * @author xuxueli 2017-04-28 */@Configurationpublic class XxlJobConfig &#123; private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class); @Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;) private String adminAddresses; @Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;) private String appname; @Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;) private int port; @Bean public XxlJobSpringExecutor xxlJobExecutor() &#123; logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;); XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor(); xxlJobSpringExecutor.setAdminAddresses(adminAddresses); xxlJobSpringExecutor.setAppname(appname); xxlJobSpringExecutor.setPort(port); return xxlJobSpringExecutor; &#125;&#125; 任务代码，重要注解:@XxlJob(“JobHandler”) package com.zyxstu.service.impl;import com.xxl.job.core.handler.annotation.XxlJob;import org.springframework.stereotype.Component;@Componentpublic class HelloJob &#123; @XxlJob(&quot;xuanTest&quot;) public void helloJob()&#123; System.out.println(&quot;简单任务执行中。。。&quot;); &#125;&#125; 测试-单节点 启动微服务 在xxl-job的调度中心中启动任务 image-20230816170502010 image-20230816170518069 任务详解-执行器 执行器：任务的绑定的执行器，任务触发调度时将会自动发现注册成功的执行器, 实现任务自动发现功能; 另一方面也可以方便的进行任务分组。每个任务必须绑定一个执行器 image-20210729232926534 image-20210729232825564 以下是执行器的属性说明： 属性名称 说明 AppName 是每个执行器集群的唯一标示AppName, 执行器会周期性以AppName为对象进行自动注册。可通过该配置自动发现注册成功的执行器, 供任务调度时使用; 名称 执行器的名称, 因为AppName限制字母数字等组成,可读性不强, 名称为了提高执行器的可读性; 排序 执行器的排序, 系统中需要执行器的地方,如任务新增, 将会按照该排序读取可用的执行器列表; 注册方式 调度中心获取执行器地址的方式； 机器地址 注册方式为&quot;手动录入&quot;时有效，支持人工维护执行器的地址信息； 自动注册和手动注册的区别和配置 image-20210729233016355 任务详解-基础配置 image-20230816170151366 基础配置 执行器：每个任务必须绑定一个执行器, 方便给任务进行分组 任务描述：任务的描述信息，便于任务管理； 负责人：任务的负责人； 报警邮件：任务调度失败时邮件通知的邮箱地址，支持配置多邮箱地址，配置多个邮箱地址时用逗号分隔 image-20210729234009010 调度配置 调度类型： 无：该类型不会主动触发调度； CRON：该类型将会通过CRON，触发任务调度； 固定速度：该类型将会以固定速度，触发任务调度；按照固定的间隔时间，周期性触发； image-20210729234114283 任务配置 运行模式： ​ BEAN模式：任务以JobHandler方式维护在执行器端；需要结合 “JobHandler” 属性匹配执行器中任务； JobHandler：运行模式为 “BEAN模式” 时生效，对应执行器中新开发的JobHandler类“@JobHandler”注解自定义的value值； 执行参数：任务执行所需的参数； image-20210729234219162 阻塞处理策略 阻塞处理策略：调度过于密集执行器来不及处理时的处理策略； 单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO(First Input First Output)队列并以串行方式运行； 丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败； 覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务； image-20210729234256062 路由策略 当执行器集群部署时，提供丰富的路由策略，包括； FIRST（第一个）：固定选择第一个机器； LAST（最后一个）：固定选择最后一个机器； ROUND（轮询） RANDOM（随机）：随机选择在线的机器； CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。 LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举； LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举； FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度； BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度； SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务； image-20210729234409132","tags":["java","学习","开源框架"]},{"title":"“Hexo”","path":"/post/54193/","content":"什么是 Hexo？ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装 详细参考文档 | Hexo 在安装完前置条件，nodejs、git后 $ npm install -g hexo-cli 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 补充（npm无法安装或速度过慢的问题） 方法一：修改配置文件 这种方法是通过修改npm的全局配置文件，将默认的镜像源改为淘宝镜像。具体步骤如下： 打开终端，输入以下命令，设置淘宝镜像源： npm config set registry https://registry.npm.taobao.org 输入以下命令，查看是否设置成功： npm config get registry 如果返回https://registry.npm.taobao.org/，说明配置的是淘宝镜像。 现在你就可以正常使用npm安装包了，例如： npm install express 这样就会从淘宝镜像下载express包，速度会比官方快很多。 如果你想恢复成原来的官方镜像源，只需要输入以下命令： npm config set registry https://registry.npmjs.org 方法二：通过安装cnpm 这种方法是通过安装一个名为cnpm的工具，它是一个和npm兼容的命令行工具，但是默认使用淘宝镜像源。具体步骤如下： 打开终端，输入以下命令，安装cnpm： npm install -g cnpm --registry=https://registry.npm.taobao.org 输入以下命令，查看是否安装成功： cnpm -v 如果返回cnpm的版本号，说明安装成功。 现在你就可以使用cnpm代替npm安装包了，例如： cnpm install express 这样也会从淘宝镜像下载express包。 如果你想卸载cnpm，只需要输入以下命令： cnpm install express $ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install #启动服务hexo s#停止服务ctrl + C#推送至github组合命令hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 启动对应服务，打开对应网址 安装主题 这里选择的是简洁的stellar 安装与更新 安装方法 在终端中输入： $ npm i hexo-theme-stellar 在 blog/_config.yml 文件中找到并修改： theme: stellar 可以重新启动服务查看效果 image-20230901214253946 绑定github 首先需要拥有github账号并且创建一个仓库 配置对应账户邮箱的ssh密钥 $ ssh-keygen -t rsa -C &quot;你的邮箱&quot; 输入之后一直回车直到生成结束。 image-20230901221254003 到达对应地址的id_rsa.pub文件中获取，一般是在c盘的用户你的用户文件夹的.ssh中 在GitHub setting中新建密钥并添加。 到gitbash中输入 $ git config --global user.name &quot;你的名字&quot;$ git config --global user.email &quot;你的邮箱&quot; 到主题根目录中找到_config.yml文件 在底部添加如下配置 # Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git branch: main repo: git@github.com:Ezhixuan/xuanBlog.git 在gitbash中输入以下命令安装上传插件并上传 $ cnpm install hexo-deployer-git --save$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 至此绑定成功 备份数据 由于某些原因，我们可能会需要修改配置文件等未被上传的文件，但恰巧文件丢失，github上收录的又是编译后的文件，所以对数据进行备份是有必要的。 这里选择在gitee上建立一个私有仓库来存储源码 如果使用gitee记得添加ssh #git初始化git init#创建hexo分支，用来存放源码git checkout -b hexo#git 文件添加git add .#git 提交git commit -m &quot;init&quot;#添加远程仓库git remote add origin &quot;仓库地址&quot;#push到hexo分支git push origin hexo 修改日常 依次执行 $ git add .$ git commit -m &#x27;...&#x27;$ git push origin hexo 如何恢复 当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤： $ git clone -b hexo &quot;仓库地址&quot;# 在本地新拷贝的YOURNAME.github.io文件夹下通过Git bash依次执行下列指令：$ npm install hexo$ npm install$ npm install hexo-deployer-git（记得，不需要hexo init这条指令）。 部署上线 因为笔者之前已经部署上线，暂时不多赘述，后续有空会进行补充，可以自行搜索查看一些文档视频等自行部署。","tags":["hexo","学习"]},{"path":"/about/index.html","content":"种植一棵树，最好的时间是二十年前，其次是现在。Ezhixuan目前大四在读小透明，欢迎来到我的小破站，记录一些学习、生活经历。希望能够结识有趣的、志同道合的朋友。关于友链动态GitHub 关于博客 本身不善言辞，偶尔有感而发会记录下来。 学习上经常记一些笔记，但是存放位置相对零散。 一些奇奇怪怪的原因，不好意思把自己的文章放在大平台上。 戳戳戳这里添加我的联系方式微信QQ微信推荐或者添加我的WX:qq或者添加我的QQ:"},{"path":"/friends/index.html","content":"种植一棵树，最好的时间是二十年前，其次是现在。Ezhixuan目前大四在读小透明，欢迎来到我的小破站，记录一些学习、生活经历。希望能够结识有趣的、志同道合的朋友。关于友链动态GitHub 我在等你"},{"path":"/timeline/index.html","content":"种植一棵树，最好的时间是二十年前，其次是现在。Ezhixuan目前大四在读小透明，欢迎来到我的小破站，记录一些学习、生活经历。希望能够结识有趣的、志同道合的朋友。关于友链动态GitHub 2023 年 9 月 1 日建立小破站2023 年 9 月 3 日完善一些小功能，添加建站计时，添加分组分页，添加关于自己等2023 年 9 月 4 日添加评论组件giscus更换评论组件由giscus -&gt; waline"},{"path":"/friends/rss/index.html","content":""},{"title":"前言","path":"/wiki/blog/index.html","content":"xuanBlog 8809c7663516fb0bb69e6f8aaee7ece 博客项目一直是我想实现的项目，得益于国庆的空闲，有机会将该项目复现，本身的功能十分简单，各种对数据的crud，本意希望能够通过不断完善这个项目来整合自己最近学的一些相关知识，或是学习某项技术来实现某些功能，来扩展自己的技术栈。 Alt text 项目分析 作为单体项目但是分为三个模块，分别是framework公共模块，blog博客模块以及admin后台模块。大部分公共的业务代码都是在framework模块中实现，博客前台与后台基于自身进行一些特殊配置。 技术使用：SpringBoot + Mysql + Redis + SpringSecurity + Knife4j + MyBatisPlus + ElasticSearch + RabbitMQ + Canal + xxl-job + rabbitMq 对各种数据的CRUD。 使用AOP实现Service的运行日志打印。 通过策略模式实现多种图片上传方式的灵活切换。 缓存操作频率高但不重要的数据至redis，并通过定时任务定时推送至数据库存储。 采用 RABC 权限模型进行权限管理，通过SpringSecurity实现登录校验，并进行各种权限认证。 Future [x] 通过策略模式增加上传图片的方式 [ ] 增加canal实现双写一致性 [ ] 增加邮箱登录，qq登录，微信登录等方式 [ ] 增加rabbitMq对文章定时发布处理 [ ] 添加Elasticsearch与Mysql作为搜索策略切换 [ ] 增加对于秒杀操作的复现 [ ] 增加minIO的图片上传方式 [ ] 敏感词识别，上传图片识别 [ ] 大重构(明显能够感受到是有很大一部分的问题)"},{"title":"前言","path":"/wiki/leetcode/index.html","content":"此前已经一刷算法，但是有一段时间没有用了，所以觉得开启二刷，记录一下 2023 年 9 月 3 日数组"},{"title":"前言","path":"/notes/index.html","content":"记录一下"},{"title":"短信登录","path":"/wiki/hmdp/1.短信登录.html","content":"配置好环境后启动程序，我们的nginx是配置在8080端口，所以我们访问8080端口即可。 image-20230914155239256 首先可以看到这里的手机号码快捷登录页面。 大致流程为，用户输入手机号后点击发送验证码 发送短信 controller @PostMapping(&quot;code&quot;)@ApiOperation(&quot;发送手机验证码&quot;)@ApiImplicitParams(&#123; @ApiImplicitParam(name = &quot;phone&quot;, value = &quot;手机号&quot;, required = true), @ApiImplicitParam(name = &quot;session&quot;, value = &quot;session&quot;, required = true)&#125;)public Result sendCode(@RequestParam(&quot;phone&quot;) String phone, HttpSession session) &#123; // 发送短信验证码并保存验证码 return userService.sendCode(phone, session);&#125; Impl 这里因为是模拟项目，所以并没有进行实际的验证码发送，实际发送可以参考阿里云短信服务Api。 校验手机号，如果符合规范就生成随机验证码，然后将用户手机号作为key，生成的验证码作为value存入redis中，发生给用户验证码信息 /** * 发送验证码 * * @param phone * @param session * @return */ @Override public Result sendCode(String phone, HttpSession session) &#123; // 业务流程分析 // 1. 校验手机号是否正确 if (RegexUtils.isPhoneInvalid(phone)) &#123; // 校验不符合规范，返回 return Result.fail(&quot;请输入正确手机号&quot;); &#125; // 2. 创建验证码 String code = RandomUtil.randomNumbers(6); // 3. 将验证码存入redis中 // 确定key String key = LOGIN_CODE_KEY + phone; stringRedisTemplate.opsForValue().set(key, code, LOGIN_CODE_TTL, TimeUnit.MINUTES); // 4. 发送验证码 log.info(&quot;短信验证码为&#123;&#125;&quot;, code); return Result.ok(&quot;短信发送成功&quot;); &#125; 点击登录 在用户接受到验证码后输入验证码点击登录 Controller @PostMapping(&quot;/login&quot;)@ApiOperation(&quot;登录&quot;)public Result login(@RequestBody LoginFormDTO loginForm, HttpSession session) &#123; // 实现登录功能 return userService.login(loginForm, session);&#125; Impl 用户输入手机号和验证码点击登录，后端接收到登录请求后，用接收的手机号去redis中取出对应的value，与用户输入的验证码进行比较，如果不一致则登录失败，如果一致生成一个token作为用户登录标识，存入redis缓存中并设置过期时间，并将token返回给前端。 /** * 登录 * @param loginForm * @param session * @return */@Overridepublic Result login(LoginFormDTO loginForm, HttpSession session) &#123; // 模块实现分析 String phone = loginForm.getPhone(); // 1.从redis中取出code与loginForm中的code进行比较 // 确定key String codeKey = LOGIN_CODE_KEY + phone; String codeInRedis = stringRedisTemplate.opsForValue().get(codeKey); if (codeInRedis == null || !codeInRedis.equals(loginForm.getCode())) &#123; // 验证码不正确 return Result.fail(&quot;验证码错误，登录失败&quot;); &#125; // 2.到数据库中查询该手机对应的用户是否存在 // 构建查询条件 SQL : select * from tb_user where phone = ? LambdaQueryWrapper&lt;User&gt; userLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); userLambdaQueryWrapper.eq(User::getPhone, phone); User user = getOne(userLambdaQueryWrapper); if (user == null) &#123; // 用户不存在则创建一个新用户 user = createUserByPhone(phone); save(user); &#125; UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class); // 3.存在，则将用户数据存入redis中 // 需要将用户数据存进redis中需要确定key // 为用户生成随机token String token = UUID.randomUUID().toString(); String UserKey = LOGIN_USER_KEY + token; stringRedisTemplate .opsForValue() .set(UserKey, JSONUtil.toJsonStr(userDTO), LOGIN_USER_TTL, TimeUnit.SECONDS); // 4.清除code的缓存 stringRedisTemplate.delete(codeKey); return Result.ok(token);&#125; 登录用户token续期 默认给到token的一个时间是30分钟，用户在获得token后每次访问都会携带这个token，为了防止用户在浏览时遇到信息过期的情况，我们设置了一个自动续期的方法。 该方法是通过拦截器实现的，当用户进行浏览访问时，请求会被拦截器捕获，拦截器会去获取用户携带的token信息，以此去查询redis缓存，如果缓存未命中，则表示是游客，未登录，允许浏览部分未拦截的页面。如果缓存命中，说明该用户已登录，则为这个缓存重新设置30分钟的过期时间，并且将用户信息存入ThreadLocal中方便全局获取。 impl /** * 刷新用户信息过期时间 */public class RefreshExpireInterceptor implements HandlerInterceptor &#123; private StringRedisTemplate stringRedisTemplate; public RefreshExpireInterceptor(StringRedisTemplate stringRedisTemplate) &#123; this.stringRedisTemplate = stringRedisTemplate; &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 1.从请求头中获取token String token = request.getHeader(&quot;authorization&quot;); if (token == null) &#123; return true; &#125; // 2.根据token拼接得到UserKey并进行查询 String key = LOGIN_USER_KEY + token; String userString = stringRedisTemplate.opsForValue().get(key); if (StrUtil.isBlank(userString)) &#123; return true; &#125; // 3.确定用户数据确实存在，刷新过期时间 stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.SECONDS); // 4.将用户信息转存至ThreadLocal中 UserDTO userDTO = JSONUtil.toBean(userString, UserDTO.class); UserHolder.saveUser(userDTO); return true; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; HandlerInterceptor.super.afterCompletion(request, response, handler, ex); UserHolder.removeUser(); &#125;&#125; /** * 登录检查拦截器 */public class LoginCheckInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 1.从ThreadLocal中获取用户信息 UserDTO user = UserHolder.getUser(); // 2.判断用户信息是否存在 if (user == null) &#123; // 信息不存在，表示未登录 response.setStatus(401); return false; &#125; // 3.存在,放行 return true; &#125;&#125; /** * MVC配置类 */@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Resource private StringRedisTemplate stringRedisTemplate; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new RefreshExpireInterceptor(stringRedisTemplate)).order(0); registry.addInterceptor(new LoginCheckInterceptor()) .excludePathPatterns( &quot;shop/**&quot;, &quot;shop-type/**&quot;, &quot;upload/**&quot;, &quot;/voucher/**&quot;, &quot;/blog/hot&quot;, &quot;/user/code&quot;, &quot;/user/login&quot; ).order(1); &#125;&#125; 至此用户登录基本实现完成。"},{"title":"用户签到","path":"/wiki/hmdp/2.用户签到.html","content":"用户签到是一个非常常见的功能，这里选择使用redis的bitMap来进行存储实现。Bitmap在存储和处理大规模位数据时非常高效，它占用的内存空间相对较小，并且各种位操作可以在常数时间内完成。关于bitmap的一些常用命令或者redis的常用命令，感兴趣的可以移步我的redis使用文章。 https://www.ezhixuan.xyz/post/bae4ff13/https://www.ezhixuan.xyz/post/bae4ff13/ controller @PostMapping(&quot;/sign&quot;)@ApiOperation(&quot;签到&quot;)public Result sign() &#123; return userService.sign();&#125;@GetMapping(&quot;/sign/count&quot;)@ApiOperation(&quot;连续签到次数&quot;)public Result signCount() &#123; return userService.signCount();&#125; Impl 用户点击签到后将签到信息记录到redis中，点击统计连续签到天数，通过bitfield获取当天时间记录的位置，依次向前遍历记录天数。 /** * 用户登录签到 * @return */ @Override public Result sign() &#123; // 1.获取当前用户 Long userId = UserHolder.getUser().getId(); // 2. 获取当前时间 String now = LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyyMM&quot;)); String key = USER_SIGN_KEY + userId + &quot;:&quot; + now; // 3. 获取当前时间的天数 int dayOfMonth = LocalDateTime.now().getDayOfMonth(); // 4. 存储信息至redis中 stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - 1, true); return Result.ok(); &#125; /** * 统计连续签到天数 * @return */ @Override public Result signCount() &#123; // 1.获取当前用户 Long userId = UserHolder.getUser().getId(); // 2. 获取当前时间 String now = LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyyMM&quot;)); String key = USER_SIGN_KEY + userId + &quot;:&quot; + now; // 3. 获取当前时间的天数 int dayOfMonth = LocalDateTime.now().getDayOfMonth(); // 4. 从redis中取出数据 List&lt;Long&gt; result = stringRedisTemplate .opsForValue() .bitField( key, BitFieldSubCommands.create() .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth - 1)) .valueAt(0)); if (result == null || result.isEmpty()) &#123; // 没有签到记录 return Result.ok(0); &#125; // 5. 解析数据 Long sign = result.get(0); if (sign == null || sign == 0) &#123; return Result.ok(0); &#125; int count = 0; while (true) &#123; if ((sign &amp; 1) == 0) &#123; // 如果为0，说明未签到，结束 break; &#125; else &#123; // 如果不为0，说明已签到，计数器加+1 count++; &#125; // 数字右移 sign &gt;&gt;&gt;= 1; &#125; return Result.ok(count); &#125;"},{"title":"秒杀券","path":"/wiki/hmdp/3.秒杀券.html","content":"关于秒杀券，我认为它有几个特点 并发量大 数量少 持续时间短 活动独立 次数限次 对于这类秒杀模式的活动，我们设计时需要考虑服务器能否承受高并发带来的压力，是否会出现超卖现象，用户购买次数限定等问题 在本项目中，我学习了使用redis来处理秒杀业务。 全局ID生成器 全局ID生成器，是一种在分布式系统下用来生成全局唯一ID的工具 当用户抢购时，就会生成订单并保存到tb_voucher_order这张表中，而订单表如果使用数据库自增ID就存在一些问题： id的规律性太明显 受单表数据量的限制 场景分析：如果我们的id具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。 场景分析二：随着我们商城规模越来越大，mysql的单表的容量不宜超过500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的id是不能一样的， 于是乎我们需要保证id的唯一性。 /** * @program: seckill-demo * @description: 全局订单id生成工具 * @author: Mr.Xuan * @create: 2023-09-18 16:47 **/public class OrderIdFactory &#123; /** * 2023-01-01 00:00:00 * LocalDateTime.of(2023,1,1,0,0,0).toEpochSecond(ZoneOffset.UTC); */ private static final Long BEGIN = 1672531200L; private RedisTemplate redisTemplate; private static final Integer BIT = 32; public OrderIdFactory(RedisTemplate redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; public Long getOrderId()&#123; // 1. 获取当前时间 LocalDateTime now = LocalDateTime.now(); long nowEpochSecond = now.toEpochSecond(ZoneOffset.UTC); // 2. 计算时间戳 long timeStamp = BEGIN - nowEpochSecond; // 3. 获取当前时间并序列化作为key String format = now.format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;)); // 4. 获取自增 Long increment = redisTemplate.opsForValue().increment(&quot;order:&quot; + format); return timeStamp &lt;&lt; BIT | increment; &#125;&#125; 秒杀下单 最早我们的秒杀下单业务的流程是提交优惠券的id，后台去查询该优惠券的信息，首先判断秒杀抢购是否开始，再判断库存是否充足，再扣减库存创建订单，最后返回订单id。如果其中判断出现不满足则返回异常结果直接结束。这其中有很多需要优化的问题，我们一点一点进行优化。 超卖问题分析 首先是关于扣减库存的问题，起初我们是当判断库存充足后扣减库存，这在单线程的情况下是没有问题的，但是假如在多线程的情况下，只剩1的库存，线程1判断库存充足还未扣减库存时，线程2也判断了库存充足，两个线程都能进行库存扣减从而导致出现超卖问题。 解决超卖问题 对于超卖问题，常见的解决方法就是加锁，而对于加锁，一般有两种解决方案 悲观锁 乐观锁 悲观锁：认为线程安全是一定会发生，所以在进行数据操作之前，要先获取一把锁，确保线程是串行执行的。syn，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁等。 乐观锁：认为线程安全不一定会发生，因此不加锁，只在更新数据时判断数据有没有被其他线程修改。如果没有被修改则认为是安全的，更新数据。如果数据被修改则说明出现安全问题，此时进行重试或抛出异常。 如果系统的并发量非常大，悲观锁会带来很大的性能问题，它会在改变对象前将对象锁住，直到提交更改后才释放锁，加锁的时间可能很长。会长时间限制其他用户访问，并发访问性并不好，所以这里选择使用乐观锁解决超卖问题。 具体示例代码如下 /** seckill测试 */ @Test void test1() &#123; // 初始化变量 Random random = new Random(); Long voucherId = 10L; int userId = (random.nextInt(20000) + 20000) % 20000; log.info(&quot;用户&#123;&#125;开始抢购代金券&#123;&#125;&quot;, userId, voucherId); // 1. 查询对应代金券信息 SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId); Integer stock = seckillVoucher.getStock(); // 1.1 如果开始时间在当前时间之后，则表示活动还未开始 if (seckillVoucher.getBeginTime().after(new Date())) &#123; System.out.println(&quot;抢购失败，活动还未开始&quot;); return; &#125; // 1.2 如果结束时间在当前时间之前，则表示活动已经结束 if (seckillVoucher.getEndTime().before(new Date())) &#123; System.out.println(&quot;抢购失败，活动已经结束&quot;); return; &#125; // 1.3 如果当前库存小于0，则表示活动已结束 if (stock &lt;= 0) &#123; System.out.println(&quot;抢购失败，活动已结束&quot;); return; &#125; // 2. 查询用户是否已经购买过 Boolean flag = (Boolean) redisTemplate.opsForHash().get(&quot;seckill:order&quot;, Integer.toString(userId)); if (Boolean.TRUE.equals(flag)) &#123; System.out.println(&quot;您已经购买过了&quot;); return ; &#125; // 3. 生成 // 3.1 扣减库存 boolean update = seckillVoucherService.update( Wrappers.&lt;SeckillVoucher&gt;lambdaUpdate() .setSql(&quot;stock = stock - 1&quot;) .eq(SeckillVoucher::getVoucherId, voucherId) .gt(SeckillVoucher::getStock, 0)); log.info(&quot;update:&#123;&#125;&quot;, update); if (!update) &#123; System.out.println(&quot;库存不足，活动已结束&quot;); return ; &#125; // 3.2 生成订单 OrderIdFactory orderIdFactory = new OrderIdFactory(redisTemplate); Long orderId = orderIdFactory.getOrderId(); VoucherOrder voucherOrder = new VoucherOrder(); voucherOrder.setId(orderId); voucherOrder.setUserId(userId); voucherOrder.setVoucherId(voucherId); voucherOrder.setPayType(1); voucherOrder.setStatus(1); voucherOrder.setCreateTime(new Date()); voucherOrder.setUpdateTime(new Date()); log.info(&quot;用户&#123;&#125;抢购代金券&#123;&#125;成功&quot;, userId, voucherId); try &#123; voucherOrderService.save(voucherOrder); &#125; catch (Exception e) &#123; log.error(&quot;用户&#123;&#125;抢购代金券&#123;&#125;成功&quot;, userId, voucherId); throw new RuntimeException(e); &#125; // 3.3 将用户购买信息存入redis redisTemplate.opsForHash().put(&quot;seckill:order&quot;, Integer.toString(userId), true); // 4. 返回订单号 System.out.println(&quot;抢购成功！订单号：&quot; + orderId); &#125; 这里使用jmeter进行压测，10000个线程1秒抢100张秒杀券。 image-20230918213430238 image-20230919140114615 其中一些异常是由于连接问题导致，可见我们应该是解决了超卖的问题。 一人一单资格判断问题分析 要保证一人只能购买一次，我们有多种解决方案，首先最容易想到的就是加锁，synchronized锁便是一个解决方案，但是使用synchronized锁，虽然可以满足单机情况下的一人一单问题，但是在集群模式下就会失效。 因为每个tomcat都有自己的jvm，同一个服务器中的多个线程锁的对象是同一个，可以实现互斥，但不同的服务器锁的对象却是不相同的，不同服务器的各个线程是不能实现互斥的，所以会导致锁失效。 所以这里引入了分布式锁来实现一人一单，使用redis来实现分布式锁，当验证购买资格时到redis中获取对应信息并做相应处理即可。 解决一人一单问题 在上述代码中，资格判断是通过获取用户是否在redis存储的购买名单中来判断，但添加是在生成订单后才对redis进行添加，如果同一个用户同时发起线程A、B，线程A还未添加进redis前，线程B依旧能够通过验证的判断，就会导致同一个用户能够抢购到多个订单。在这里我们也有多种方法来解决，可以使用redis的setnx,hset,sadd都能够满足首次添加时返回1如果已经存在则返回0，这里我们选择使用sadd来完成需求，因为set数据结构天生也能满足成员不重复。 具体实现代码如下 /** seckill测试2 */ private static final Long SUCCESS = 1L; @Test void test2() &#123; // 初始化变量 Random random = new Random(); Long voucherId = 10L; int userId = 1; log.info(&quot;用户&#123;&#125;开始抢购代金券&#123;&#125;&quot;, userId, voucherId); // 1. 查询对应代金券信息 SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId); Integer stock = seckillVoucher.getStock(); // 1.1 如果开始时间在当前时间之后，则表示活动还未开始 if (seckillVoucher.getBeginTime().after(new Date())) &#123; System.out.println(&quot;抢购失败，活动还未开始&quot;); return; &#125; // 1.2 如果结束时间在当前时间之前，则表示活动已经结束 if (seckillVoucher.getEndTime().before(new Date())) &#123; System.out.println(&quot;抢购失败，活动已经结束&quot;); return; &#125; // 1.3 如果当前库存小于0，则表示活动已结束 if (stock &lt;= 0) &#123; System.out.println(&quot;抢购失败，活动已结束&quot;); return ; &#125;// ==================================修改======================================= // 2. 查询用户是否已经购买过 Long add = redisTemplate.opsForSet().add(&quot;seckill:order&quot;, userId); log.info(&quot;add:&#123;&#125;&quot;, add); if (! SUCCESS.equals(add)) &#123; System.out.println(&quot;您已经购买过了&quot;); return; &#125; // 3. 生成 // 3.1 扣减库存 boolean update = seckillVoucherService.update( Wrappers.&lt;SeckillVoucher&gt;lambdaUpdate() .setSql(&quot;stock = stock - 1&quot;) .eq(SeckillVoucher::getVoucherId, voucherId) .gt(SeckillVoucher::getStock, 0)); log.info(&quot;update:&#123;&#125;&quot;, update); if (!update) &#123; System.out.println(&quot;库存不足，活动已结束&quot;); return ; &#125; // 3.2 生成订单 OrderIdFactory orderIdFactory = new OrderIdFactory(redisTemplate); Long orderId = orderIdFactory.getOrderId(); VoucherOrder voucherOrder = new VoucherOrder(); voucherOrder.setId(orderId); voucherOrder.setUserId(userId); voucherOrder.setVoucherId(voucherId); voucherOrder.setPayType(1); voucherOrder.setStatus(1); voucherOrder.setCreateTime(new Date()); voucherOrder.setUpdateTime(new Date()); log.info(&quot;用户&#123;&#125;抢购代金券&#123;&#125;成功&quot;, userId, voucherId); try &#123; voucherOrderService.save(voucherOrder); &#125; catch (Exception e) &#123; log.error(&quot;用户&#123;&#125;抢购代金券&#123;&#125;成功&quot;, userId, voucherId); throw new RuntimeException(e); &#125;// ==================================修改======================================= // 4. 返回订单号 System.out.println(&quot;抢购成功！订单号：&quot; + orderId); &#125; 响应问题分析 对于秒杀模块的基本功能已经实现，超卖和一人一单的问题也基本解决，现在就是响应速度的优化。 对于用户资格的判断和库存的判断，我们可以移到响应速度更快的redis中解决，不用每次都查询数据库，可以提高响应速度和减轻数据库的压力。 对于生成订单的代码，我们可以另外生成，先返回用户的订单号即可。 优化响应 具体代码如下 /** * @author ezhixuan * @description 针对表【tb_voucher_order】的数据库操作Service实现 * @createDate 2023-09-18 16:42:06 */@Service@Slf4jpublic class VoucherOrderServiceImpl extends ServiceImpl&lt;VoucherOrderMapper, VoucherOrder&gt; implements VoucherOrderService &#123; @Resource private SeckillVoucherService seckillVoucherService; private static final DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT; @Resource private RedisTemplate&lt;String, Object&gt; redisTemplate; @Resource private RabbitTemplate rabbitTemplate; static &#123; SECKILL_SCRIPT = new DefaultRedisScript&lt;&gt;(); SECKILL_SCRIPT.setLocation(new ClassPathResource(&quot;lua/SeckillLua.lua&quot;)); SECKILL_SCRIPT.setResultType(Long.class); &#125; @Override public void seckillVoucher() &#123; // 初始化变量 Random random = new Random(); Long voucherId = 10L; int userId = (random.nextInt(20000) + 20000) % 20000; log.info(&quot;用户&#123;&#125;开始抢购代金券&#123;&#125;&quot;, userId, voucherId); // 1. redisLua处理 Long execute = redisTemplate.execute( SECKILL_SCRIPT, Collections.emptyList(), voucherId.toString(), Integer.toString(userId), LocalDateTime.now().toEpochSecond(ZoneOffset.UTC)); assert execute != null; log.info(&quot;execute = &#123;&#125;&quot;, execute); if (!execute.equals(0L)) &#123; if (execute.equals(1L)) &#123; System.out.println(&quot;活动未开始&quot;); &#125; else if (execute.equals(2L)) &#123; System.out.println(&quot;活动已结束&quot;); &#125; else if (execute.equals(3L)) &#123; System.out.println(&quot;库存不足&quot;); &#125; else if (execute.equals(4L)) &#123; System.out.println(&quot;用户已购买&quot;); &#125; System.out.println(&quot;抢购失败，活动已结束&quot;); return; &#125; // 2. 生成 // 2.1 生成订单 OrderIdFactory orderIdFactory = new OrderIdFactory(redisTemplate); Long orderId = orderIdFactory.getOrderId(); log.info(&quot;用户&#123;&#125;抢购代金券&#123;&#125;成功&quot;, userId, voucherId); // 2.2 使用kafka发送消息 VoucherOrder voucherOrder = new VoucherOrder(); voucherOrder.setId(orderId); voucherOrder.setUserId(userId); voucherOrder.setVoucherId(voucherId); rabbitTemplate.convertAndSend(&quot;order.seckill&quot;, JSONUtil.toJsonStr(voucherOrder)); // 3. 返回订单号 System.out.println(&quot;抢购成功！订单号：&quot; + orderId); &#125; /** * 保存订单信息 * * @param order */ @Override @Transactional public void saveOrder(VoucherOrder order) &#123; // 初始化一些变量 int userId = 2; // 1 扣减库存 boolean update = seckillVoucherService.update( Wrappers.&lt;SeckillVoucher&gt;lambdaUpdate() .setSql(&quot;stock = stock - 1&quot;) .eq(SeckillVoucher::getVoucherId, order.getVoucherId()) .gt(SeckillVoucher::getStock, 0)); log.info(&quot;update:&#123;&#125;&quot;, update); if (!update) &#123; System.out.println(&quot;库存不足，活动已结束&quot;); return; &#125; // 2. 保存 order.setPayType(1); order.setStatus(1); order.setCreateTime(new Date()); order.setUpdateTime(new Date()); save(order); &#125;&#125; lua脚本 ------ Generated by EmmyLua(https://github.com/EmmyLua)--- Created by ezhixuan.--- DateTime: 2023/9/19 14:31----- 参数列表-- 优惠券idlocal voucherId = ARGV[1]-- 用户idlocal userId = ARGV[2]-- 当前时间local currentTime = ARGV[3]-- keylocal key = &#x27;seckill:10&#x27;local orderKey = &#x27;seckill:order&#x27;-- 获取库存值local stock = redis.call(&#x27;hget&#x27;,key,&#x27;stock&#x27;)-- 获取开始时间local beginTime = redis.call(&#x27;hget&#x27;,key,&#x27;beginTime&#x27;)-- 获取结束时间local endTime = redis.call(&#x27;hget&#x27;,key,&#x27;endTime&#x27;)local diff = beginTime - currentTimeif diff &gt; 0 then return 1; -- 活动未开始enddiff = endTime - currentTimeif diff &lt; 0 then return 2; -- 活动已结束endif tonumber(stock) &lt;= 0 then return 3; -- 库存不足endif redis.call(&#x27;sadd&#x27;, orderKey, userId) ~= 1 then return 4; -- 用户已在购买名单中end-- 扣库存redis.call(&#x27;hincrby&#x27;, key, &#x27;stock&#x27;, -1)return 0; -- 成功 lua脚本都是一些简单的redis命令使用，在这里就不多赘述了。 但是这里有一个问题，因为我不太了解lua语言，我知道在拼接时可以使用 … 拼接，在上述代码中 -- 原代码local key = &#x27;seckill:&#x27; .. voucherId-- 修改local key = &#x27;seckill:10&#x27; 修改成这样是因为我在使用原代码时会导致查询失败，经过排查找到原因才确定是这里的问题，并且只要写成这样的确定值查询就可以正常生效，希望有大神指点一下。 (------------------已移除----------------) 关键在于proxy的使用，在本文中所有的代码都是在test中复刻的，实际上应该是编写在Impl中，当我们在一个Service中调用该Service的另一个方法，如果直接调用会导致事务失效，所以这里需要使用proxy来保存当前的服务并使用proxy调用方法保证事务。(个人理解如有错误欢迎指正) 使用proxy需要导入如下依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;&lt;/dependency&gt; 并在启动类上添加@EnableAspectJAutoProxy(exposeProxy = true) (------------------已移除----------------) 同时这里使用了rabbitMQ作为消息中间件来接收并通知实现订单生成。使用线程池另起线程异步实现也可以，但是如果处于高压情况下，线程本身就多，另起线程对处理速度并没有任何优化，反而增加了线程数。使用MQ是这种情况的最优解。 @Component@Slf4jpublic class RabbitListener &#123; @Resource private VoucherOrderService voucherOrderService; @org.springframework.amqp.rabbit.annotation.RabbitListener(queues = &quot;order.seckill&quot;) public void listenMessage(String onMessage)&#123; log.info(&quot;秒杀订单生成中&quot;); VoucherOrder voucherOrder = JSONUtil.toBean(onMessage, VoucherOrder.class); voucherOrderService.saveOrder(voucherOrder); &#125;&#125; 至此，秒杀下单流程基本结束，以上代码为独自实现，如果有任何错误以及理解问题，欢迎交流指正。"},{"title":"前言","path":"/wiki/hmdp/index.html","content":"2023年9月14日开启复习这个项目 前言 这个项目的难度不大，但是我认为它是有很多值得学习的地方的，主要是一个学习redis使用的项目。 主要的项目实现功能应该是这些，具体功能实现等复习结束补充。 image-20230914151525569"},{"title":"测试","path":"/wiki/stellar/index.html","content":"支持多彩标记，包括：默认 红 橙 黄 绿 青 蓝 紫 浅 深 警告 错误 一共 12 种颜色。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 &#123;% note 这&amp;nbsp;是标题 这是正文 哈哈。 %&#125; 这&nbsp;是标题这是正文 哈哈。 我是一个标题 我是一个h3标题 我是一个h1标题"},{"title":"我说一句话","path":"/wiki/stellar/我说一句话.html","content":"公道话"},{"title":"前言","path":"/wiki/xiaomo/index.html","content":"2023年9月5日晚上经过一番思想斗争，选择开启这个的项目2023年9月13日项目完成 比较简单的一个项目，实际上是黑马刚推出的苍穹外卖项目。 因为比较简单基础，所以我也纠结了一段时间 选择的原因是看中了微信小程序的制作使用(虽然最后我申请注册微信小程序被驳回了。。。) 最终微信小程序的交互只能通过swagger生成的接口文档进行检验测试 之前已经完成数个springboot的项目以及一个springCloud的项目，所以总体来说实现这个项目的难度并不大 在实现的时候我也是严格要求自己不根据视频，由自己按照接口文档的要求进行实现 对于一些实现有问题的欢迎交流指正 因为有一些密钥的原因，仓库未能公开，更多源码可以向我联系 接下来短期的目标是将原来实现的一些项目复习一下，并复习一些相对应的技术栈以及准备一些面试题 希望能够找到心仪的工作吧。 ​ —2023.09.13"},{"title":"我试试","path":"/wiki/stellar/测试.html","content":"有没有问题"},{"title":"工程初始化","path":"/wiki/xiaomo/初始化.html","content":"工程初始化 导入sql文件"},{"title":"一些问题","path":"/notes/一些问题/question.html","content":"springBoot打包 There are test failures. There are test failures.Please refer to ... for the individual test results.Please refer to dump files (if any exist) [date].dump, [date]-jvmRun[N].dump and [date].dumpstream. 问题是maven打包时springboot的test包出问题 解决方法 添加mavenPlugin跳过测试忽略问题即可，不影响jar包部署使用。 &lt;plugin&gt;\t&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\t&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\t&lt;configuration&gt; &lt;!--跳过测试--&gt; &lt;skipTests&gt;true&lt;/skipTests&gt;\t&lt;/configuration&gt;&lt;/plugin&gt; Knife4j 启动时无法访问对应文档 image-20230916142938335 要么显示knife4j文档请求异常 ，要么干脆网页直接显示不出来。 我们配置了静态资源映射，但依旧不行。 @Overrideprotected void addResourceHandlers(ResourceHandlerRegistry registry) &#123; log.info(&quot;开启静态资源映射&quot;); registry .addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;); registry.addResourceHandler(&quot;/doc.html&quot;).addResourceLocations(&quot;classpath:/META-INF/resources/&quot;); super.addResourceHandlers(registry); 解决方法 这种情况最终通过排查是因为配置了拦截器被拦截请求导致的。 省略了一些代码的拦截器代码如下 registry .addInterceptor(new LoginCheckInterceptor()) .excludePathPatterns(&quot;/doc.html&quot;) .excludePathPatterns(&quot;/webjars/**&quot;) .order(1); 可见已经配置了过滤请求，但是依旧不行。此时我们使用debug进入拦截器方法一探究竟。 image-20230916143431531 进入发现是该请求被拦截 在拦截器方添加相应过滤即可 registry .addInterceptor(new LoginCheckInterceptor()) .excludePathPatterns(&quot;/swagger-resources&quot;) .excludePathPatterns(&quot;/doc.html&quot;) .excludePathPatterns(&quot;/webjars/**&quot;) .order(1); 实现类添加了@service但是报错找不到bean 具体描述是因为无法找到对应的Servicebean，但是已经在Impl上添加了@Service。 环境是处于多模块的开发环境下，controller类与service等处于不同模块下。 Error starting ApplicationContext. To display the conditions report re-run your application with &#x27;debug&#x27; enabled.2023-09-23 18:20:10.484 ERROR 67184 --- [ main] o.s.b.d.LoggingFailureAnalysisReporter : ***************************APPLICATION FAILED TO START***************************Description:Field articleService in com.ezhixuan.xuan_blog.controller.ArticleController required a bean of type &#x27;com.ezhixuan.xuan_framework.service.ArticleService&#x27; that could not be found.The injection point has the following annotations:\t- @org.springframework.beans.factory.annotation.Autowired(required=true)Action:Consider defining a bean of type &#x27;com.ezhixuan.xuan_framework.service.ArticleService&#x27; in your configuration. 解决方法 在启动类上添加@ComponentScan注解去扫包即可 @SpringBootApplication@MapperScan(&quot;com.ezhixuan.xuan_framework.dao&quot;)@ComponentScans(&#123; @ComponentScan(&quot;com.ezhixuan.xuan_framework.service&quot;), @ComponentScan(&quot;com.ezhixuan.xuan_framework.dao&quot;)&#125;)public class XuanBlogApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(XuanBlogApplication.class, args); &#125;&#125; 后端查询到数据并返回给前端，但是前端接收到的是空数据 在后端查询到了对应数据，但是前端接收时data是空 img image-20230924220116502 解决方法 debug+log打印发现原来是vo类没有进行重写。忘记添加@Data注解导致没有重写toString 给vo类上加上@Data注解即可。 image-20230924220351133"},{"title":"N皇后","path":"/wiki/leetcode/数组/N皇后.html","content":"题目 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。 n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 img 输入：n = 4输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]解释：如上图所示，4 皇后问题存在两个不同的解法。 输入：n = 1输出：[[&quot;Q&quot;]] 思路 首先编写大体框架 class Solution &#123; //主程序 public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; backTracking(); return res; &#125;\t//递归主体\tpublic void backTracking()&#123; //当到达最底行时对结果集进行添加 if(row == n)&#123; res.add(); return; &#125; //回溯主体 //每次向下都需要从头开始判断，所以col = 0 for(int col = 0; col &lt; n; col++)&#123; &#125; &#125;&#125; 初始化 大体框架出来后可以判断出我们至少需要定义结果集res,行数row ,以及用于收集路径且最终被结果集收集的paths。 根据题目可以知道这个paths是由若干个**.组成的并且由Q**替换 所以我们还需要初始化这个paths class Solution &#123; //定义全局的结果集res List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); //主程序 public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; //定义paths并初始化 char[][] paths = new char[n][n]; for(char[] path : paths)&#123; Arrays.fill(path,&#x27;.&#x27;); &#125; backTracking(n, 0, paths); return res; &#125;\t//递归主体\tpublic void backTracking(int n, int row, char[][] paths)&#123; //当到达最底行时对结果集进行添加 if(row == n)&#123; res.add(); return; &#125; //回溯主体 //每次向下都需要从头开始判断，所以col = 0 for(int col = 0; col &lt; n; col++)&#123; &#125; &#125;&#125; 现在关注回溯主体的编写 根据题意，我们在n皇后放下Queen时需要符合规则才放下，所以很容易想到添加时进行合法性判断,以及需要将paths有char转换为list添加进结果集 编写boolean方法isLegal判断是否合法 编写List方法arrayToList进行转换 class Solution &#123; //定义全局的结果集res List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); //主程序 public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; //定义paths并初始化 char[][] paths = new char[n][n]; for(char[] path : paths)&#123; Arrays.fill(path,&#x27;.&#x27;); &#125; backTracking(n, 0, paths); return res; &#125;\t//递归主体\tpublic void backTracking(int n, int row, char[][] paths)&#123; //当到达最底行时对结果集进行添加 if(row == n)&#123; res.add(arrayToList(paths)); return; &#125; //回溯主体 //每次向下都需要从头开始判断，所以col = 0 for(int col = 0; col &lt; n; col++)&#123; if(isLegal(row, col, paths, n))&#123; //当合法时修改Q递归并回溯 paths[row][col] = &#x27;Q&#x27;; backTracking(n, row + 1, paths); paths[row][col] = &#x27;.&#x27;; &#125; &#125; &#125; //char数组转换为List集合 public List arrayToList(char[][] paths)&#123; &#125; //判断是否合法 public boolean isLegal(int row, int col, char[][] paths, int n)&#123; &#125;&#125; 编写数组转换方法 //char数组转换为List集合public List arrayToList(char[][] paths)&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(char[] path : paths)&#123; list.add(String.copyValueOf(path)); &#125; return list;&#125; 编写合法性判断 n皇后需要满足 不同行 不同列 不同对角线 //判断是否合法 //只需要判断之前的值不需要判断之后的值，因为添加值是从前往后添加的 //不能同行 col-- //补充：因为每次添加后会进入下一列，且后续会进行回溯操作，所以不会出现同行情况 //不能同列 row-- //不能同对角线 row-- &amp;&amp; col-- //补充：此时判断为45°对角线，此外还存在135°对角线 //所以还需要判断 row-- &amp;&amp; col++ 的情况 public boolean isLegal(int row, int col, char[][] paths, int n)&#123; //判断是否同列 for(int i = 0; i &lt; n; i++)&#123; if(paths[i][col] == &#x27;Q&#x27;) return false; &#125; //判断45°对角线 for(int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--)&#123; if(paths[i][j] == &#x27;Q&#x27;) return false; &#125; //判断135°对角线 for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt;= n - 1; i--, j++)&#123; if(paths[i][j] == &#x27;Q&#x27;) return false; &#125; return true; &#125;&#125; 以上，得出最后结果 class Solution &#123; //定义全局的结果集res List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); //主程序 public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; //定义paths并初始化 char[][] paths = new char[n][n]; for(char[] path : paths)&#123; Arrays.fill(path,&#x27;.&#x27;); &#125; backTracking(n, 0, paths); return res; &#125;\t//递归主体\tpublic void backTracking(int n, int row, char[][] paths)&#123; //当到达最底行时对结果集进行添加 if(row == n)&#123; res.add(arrayToList(paths)); return; &#125; //回溯主体 //每次向下都需要从头开始判断，所以col = 0 for(int col = 0; col &lt; n; col++)&#123; if(isLegal(row, col, paths, n))&#123; //当合法时修改Q递归并回溯 paths[row][col] = &#x27;Q&#x27;; backTracking(n, row + 1, paths); paths[row][col] = &#x27;.&#x27;; &#125; &#125; &#125; //char数组转换为List集合 public List arrayToList(char[][] paths)&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(char[] path : paths)&#123; list.add(String.copyValueOf(path)); &#125; return list; &#125; //判断是否合法 //只需要判断之前的值不需要判断之后的值，因为添加值是从前往后添加的 //不能同行 col-- //补充：因为每次添加后会进入下一列，且后续会进行回溯操作，所以不会出现同行情况 //不能同列 row-- //不能同对角线 row-- &amp;&amp; col-- //补充：此时判断为45°对角线，此外还存在135°对角线 //所以还需要判断 row-- &amp;&amp; col++ 的情况 public boolean isLegal(int row, int col, char[][] paths, int n)&#123; //判断是否同列 for(int i = 0; i &lt; n; i++)&#123; if(paths[i][col] == &#x27;Q&#x27;) return false; &#125; //判断45°对角线 for(int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--)&#123; if(paths[i][j] == &#x27;Q&#x27;) return false; &#125; //判断135°对角线 for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt;= n - 1; i--, j++)&#123; if(paths[i][j] == &#x27;Q&#x27;) return false; &#125; return true; &#125;&#125;"},{"title":"二分查找","path":"/wiki/leetcode/数组/二分查找.html","content":"关于二分查找 二分查找法（Binary Search）是一种在有序数组中查找目标元素的高效算法。它的基本思想是通过比较目标值和数组中间元素的大小关系，将搜索范围缩小一半，直到找到目标值或确定目标值不存在。 以下是二分查找法的基本步骤： 确定搜索范围：在开始查找之前，确定要在哪个有序数组中进行查找。通常，这个数组会首先进行排序。 初始化指针：设置两个指针，一个指向搜索范围的起始位置（通常为数组的第一个元素），另一个指向搜索范围的结束位置（通常为数组的最后一个元素）。 迭代查找：在每一次迭代中，计算中间元素的索引，即指针的中间位置。然后，将目标值与中间元素进行比较。 如果目标值等于中间元素，则找到目标值，返回其索引。 如果目标值小于中间元素，则目标值可能在中间元素的左侧，将结束指针移动到中间元素的前一个位置。 如果目标值大于中间元素，则目标值可能在中间元素的右侧，将起始指针移动到中间元素的后一个位置。 更新搜索范围：根据比较的结果，更新搜索范围，将搜索范围缩小一半。 重复迭代：重复执行步骤 3 和步骤 4，直到找到目标值或确定目标值不存在。如果起始指针大于结束指针，则表示目标值不存在于数组中。 二分查找法的时间复杂度为 O(log n)，其中 n 是数组的大小。由于每次迭代都将搜索范围缩小一半，因此它的查找效率非常高。 需要注意的是，二分查找法要求数组是有序的。如果数组无序，需要先对其进行排序，然后再进行二分查找。 二分查找 704. 二分查找 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 解题 class Solution &#123; public int search(int[] nums, int target) &#123; // 递增的整型数组nums中查找目标值target，找到返回下标，没找到返回-1 // 1. 初始化变量 左右指针 int left = 0, right = nums.length - 1; // 2. 确定循环条件 [left, right],此处right可取，所以选择&lt;= while (left &lt;= right)&#123; // 3. 确定中值 int mid = left + (right - left) / 2; // 防止下标越界 if(nums[mid] == target)&#123; return mid; &#125;else if (nums[mid] &lt; target)&#123; // 中值小于目标值 更新左指针 left = mid + 1; // mid处已判断，无需重复处理 &#125;else&#123; // 中值大于目标值 更新右指针 right = mid - 1; &#125; &#125; // 3.1 没找到返回-1 return -1; &#125;&#125; 个人看法 做的比较多已经算是非常熟练了，主要在于确定循环条件以及更新左右指针的处理 当区间为[left, right]左闭右闭时，因为左右区间都为有效区间，所以循环时选择 &lt;= 当区间为[left, right)左闭右开或(left, right](不常见)时，因为存在无效区间，所以循环时不选择添加 = 对于左右指针更新的处理，也是去判断mid值是否已经判断过，就不多赘述了"},{"title":"关于数组","path":"/wiki/leetcode/数组/关于数组.html","content":"什么是数组 数组是非常基础的数据结构 数组（array）是一种最简单的复合数据类型，它是有序数据的集合，数组中的每个元素具有相同的数据类型，可以用一个统一的数组名和不同的下标来确定数组中唯一的元素。根据数组的维度，可以将其分为一维数组、二维数组和多维数组等。 数组是一个存于连续内存空间中的相同类型数据的集合。 数组可以方便的通过下标索引的方式获取到对应下标的数据 算法通关数组 需要注意的是 数组的下标都是从0开始 数组内存空间的地址是连续的 数组的优点 相比其它类型的数据结构，数组有以下优点： 数组允许随机访问数组元素，每个存储在数组中的元素可以通过直接访问其索引来使用 数组对存储友好。这意味着在某些情况下，由于数组的线性存储方式，代码的执行顺序会大大提高 数组的缺点 声明数组时，需要指定数组的长度。初始声明数组的长度过长或过短，在移动数组元素时都会有导致效率变低 插入和删除元素之后保持数组的连续性代价是昂贵的，因为有可能需要重新排列所有数组元素。 参考资料：代码随想录 (programmercarl.com)"},{"title":"有序数组的平方","path":"/wiki/leetcode/数组/有序数组的平方.html","content":"有序数组的平方 977. 有序数组的平方 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 1： 输入：nums = [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100] 示例 2： 输入：nums = [-7,-3,2,3,11]输出：[4,9,9,49,121] 提示： 1 &lt;= nums.length &lt;= 104 -104 &lt;= nums[i] &lt;= 104 nums 已按 非递减顺序 排序 进阶： 请你设计时间复杂度为 O(n) 的算法解决本问题 解题 class Solution &#123; public int[] sortedSquares(int[] nums) &#123; // 非递减排序的整数数组nums， 各个数据分别平方组成新递增数组 // 明确一个观点， 对于一个非递减的整数数组，它的最小值在哪不确定，因为可能存在负数，但是它的最大值一定出现在头或尾 // 我们可以设置双指针指向头尾两侧，循环比较大小，选择大的一方平方插入新数组的最尾部并更新对应指针位置 // 1. 初始化数据 头尾指针 int head = 0, tail = nums.length - 1; int[] res = new int[nums.length]; int resIndex = res.length - 1; // 2. 确定循环条件 判断头尾是否可以取等? 因为我们是从两端依次向中间靠拢， // 总会出现 head++ == tail 或者 tail-- == head的情况，而此时则是结束的时候 while (head &lt;= tail)&#123; int max = nums[head] * nums[head] &gt;= nums[tail] * nums[tail] ?(int) Math.pow(nums[head++], 2) : (int) Math.pow(nums[tail--], 2); res[resIndex--] = max; &#125; // 3. 返回结果 return res; &#125;&#125; 个人看法 比较简单的一题，确定最大值依次由高向低靠拢即可。 唯一的难点是对于循环条件的判断，需要辨别究竟能不能取等。"},{"title":"避免洪水泛滥","path":"/wiki/leetcode/每日一题/23-10-13避免洪水泛滥.html","content":"避免洪水泛滥 data:2023/10/13 1488. 避免洪水泛滥 中等 你的国家有无数个湖泊，所有湖泊一开始都是空的。当第 n 个湖泊下雨前是空的，那么它就会装满水。如果第 n 个湖泊下雨前是 满的 ，这个湖泊会发生 洪水 。你的目标是避免任意一个湖泊发生洪水。 给你一个整数数组 rains ，其中： rains[i] &gt; 0 表示第 i 天时，第 rains[i] 个湖泊会下雨。 rains[i] == 0 表示第 i 天没有湖泊会下雨，你可以选择 一个 湖泊并 抽干 这个湖泊的水。 请返回一个数组 ans ，满足： ans.length == rains.length 如果 rains[i] &gt; 0 ，那么ans[i] == -1 。 如果 rains[i] == 0 ，ans[i] 是你第 i 天选择抽干的湖泊。 如果有多种可行解，请返回它们中的 任意一个 。如果没办法阻止洪水，请返回一个 空的数组 。 请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生。 示例 1： 输入：rains = [1,2,3,4]输出：[-1,-1,-1,-1]解释：第一天后，装满水的湖泊包括 [1]第二天后，装满水的湖泊包括 [1,2]第三天后，装满水的湖泊包括 [1,2,3]第四天后，装满水的湖泊包括 [1,2,3,4]没有哪一天你可以抽干任何湖泊的水，也没有湖泊会发生洪水。 示例 2： 输入：rains = [1,2,0,0,2,1]输出：[-1,-1,2,1,-1,-1]解释：第一天后，装满水的湖泊包括 [1]第二天后，装满水的湖泊包括 [1,2]第三天后，我们抽干湖泊 2 。所以剩下装满水的湖泊包括 [1]第四天后，我们抽干湖泊 1 。所以暂时没有装满水的湖泊了。第五天后，装满水的湖泊包括 [2]。第六天后，装满水的湖泊包括 [1,2]。可以看出，这个方案下不会有洪水发生。同时， [-1,-1,1,2,-1,-1] 也是另一个可行的没有洪水的方案。 示例 3： 输入：rains = [1,2,0,1,2]输出：[]解释：第二天后，装满水的湖泊包括 [1,2]。我们可以在第三天抽干一个湖泊的水。但第三天后，湖泊 1 和 2 都会再次下雨，所以不管我们第三天抽干哪个湖泊的水，另一个湖泊都会发生洪水。 提示： 1 &lt;= rains.length &lt;= 105 0 &lt;= rains[i] &lt;= 109 解题思路 将rains拆分成两块，sunny(存储晴天)和rainy(存储下雨的湖和下雨天)，遍历rains如果是晴天存入sunny，雨天存入rainy，并且如果当天下雨的湖在之前已经下过雨了，那就需要去sunny中找到上一次下雨之后最近的晴天来抽水 class Solution &#123; public int[] avoidFlood(int[] rains) &#123; // 一开始所有的湖泊都是空的，第i天的rains[i]值下雨对应下雨的湖泊 int[] ans = new int[rains.length]; Arrays.fill(ans,-1); // &lt;晴天&gt; TreeSet&lt;Integer&gt; sunny = new TreeSet&lt;&gt;(); // &lt;i湖泊是否下雨(i &gt; 0 表示第i天i湖泊下雨， i == 0 表示第i天不下雨) ， 第i天&gt; HashMap&lt;Integer, Integer&gt; rainy = new HashMap&lt;&gt;(); for(int day = 0; day &lt; rains.length; day++)&#123; Integer lake = rains[day]; if (lake == 0)&#123; // 晴天 sunny.add(day); ans[day] = 1; &#125;else&#123; // 雨天 if (rainy.containsKey(lake))&#123; // 湖里是满的 Integer remove = sunny.higher(rainy.get(lake)); if (remove == null)&#123; return new int[0]; &#125; ans[remove] = lake; sunny.remove(remove); &#125; rainy.put(lake,day); &#125; &#125; return ans; &#125;&#125; 解答成功:\t执行耗时:58 ms,击败了91.95% 的Java用户\t内存消耗:58.8 MB,击败了64.37% 的Java用户"},{"title":"只出现一次的数字","path":"/wiki/leetcode/每日一题/23-10-14只出现一次的数字.html","content":"只出现一次的数字 data:2023/10/14 136. 只出现一次的数字 简单 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。 示例 1 ： 输入：nums = [2,2,1]输出：1 示例 2 ： 输入：nums = [4,1,2,1,2]输出：4 示例 3 ： 输入：nums = [1]输出：1 提示： 1 &lt;= nums.length &lt;= 3 * 104 -3 * 104 &lt;= nums[i] &lt;= 3 * 104 除了某个元素只出现一次以外，其余每个元素均出现两次。 解题思路 最容易想到的是使用hashMap依次添加并在添加前判断是否存在，如果不为空则数量加一，最后遍历获取数量为1的返回。 class Solution &#123; public int singleNumber(int[] nums) &#123; HashMap&lt;Integer, Integer&gt; numsMap = new HashMap&lt;&gt;(); for(Integer i : nums)&#123; Integer count = numsMap.get(i); count = count == null ? 1 : ++count; numsMap.put(i,count); &#125; for(Integer i : numsMap.keySet())&#123; Integer count = numsMap.get(i); if (count == 1)&#123; return i; &#125; &#125; return Integer.MIN_VALUE; &#125;&#125; 解答成功:\t执行耗时:14 ms,击败了6.12% 的Java用户\t内存消耗:42.6 MB,击败了90.63% 的Java用户 而更简单的实现方式可以通过异或来解决 关于异或N ^ 0 = N N ^ N = 0，我们可以取出一个依次异或，由于存在 A ^ B ^ A = A ^ A ^ B = B，所以两两存在的数字一定会被剔除，最终得到的结果就是所求答案。 class Solution &#123; public int singleNumber(int[] nums) &#123; int ans = nums[0]; if (nums.length &gt; 0)&#123; for (int i = 1; i &lt; nums.length; i++)&#123; ans = ans ^ nums[i]; &#125; &#125; return ans; &#125;&#125; 解答成功:\t执行耗时:0 ms,击败了100.00% 的Java用户\t内存消耗:43.5 MB,击败了29.56% 的Java用户"},{"title":"只出现一次的数字II","path":"/wiki/leetcode/每日一题/23-10-15只出现一次的数字II.html","content":"只出现一次的数字II data:2023/10/15 137. 只出现一次的数字 II 中等 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。 你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。 示例 1： 输入：nums = [2,2,3,2]输出：3 示例 2： 输入：nums = [0,1,0,1,0,1,99]输出：99 提示： 1 &lt;= nums.length &lt;= 3 * 104 -231 &lt;= nums[i] &lt;= 231 - 1 nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 解题思路 由于int是32位的数字，所以这里用32个数来模拟32位，添加各二进制位的数，由于除答案元素外其余元素都出现三次，那么对三求余剩余的数即为所求元素。 class Solution &#123; public int singleNumber(int[] nums) &#123; int ans = 0; for(int i = 0; i &lt; 32; i++)&#123; int count = 0; for (int number : nums)&#123; count += number &gt;&gt; i &amp; 1; &#125; if (count % 3 != 0)&#123; ans |= 1 &lt;&lt; i; &#125; &#125; return ans; &#125;&#125; 解答成功:\t执行耗时:1 ms,击败了89.64% 的Java用户\t内存消耗:42.4 MB,击败了96.28% 的Java用户"},{"title":"倍数求和","path":"/wiki/leetcode/每日一题/23-10-17倍数求和.html","content":"倍数求和 date:2023/10/17 2652. 倍数求和 简单 给你一个正整数 n ，请你计算在 [1，n] 范围内能被 3、5、7 整除的所有整数之和。 返回一个整数，用于表示给定范围内所有满足约束条件的数字之和。 示例 1： 输入：n = 7输出：21解释：在 [1, 7] 范围内能被 3、5、7 整除的所有整数分别是 3、5、6、7 。数字之和为 21 。 示例 2： 输入：n = 10输出：40解释：在 [1, 10] 范围内能被 3、5、7 整除的所有整数分别是 3、5、6、7、9、10 。数字之和为 40 。 示例 3： 输入：n = 9输出：30解释：在 [1, 9] 范围内能被 3、5、7 整除的所有整数分别是 3、5、6、7、9 。数字之和为 30 。 提示： 1 &lt;= n &lt;= 103 解题思路 依次遍历即可。 class Solution &#123; public int sumOfMultiples(int n) &#123; // 给定一个正整数n 计算出[1,n]内所有被3,5,7,整除的的整数之和 int sum = 0; for(int i = 1; i &lt;= n; i++)&#123; if (i % 3 == 0 || i % 5 == 0 || i % 7 == 0)&#123; sum += i; &#125; &#125; return sum; &#125;&#125; 解答成功:\t执行耗时:2 ms,击败了84.30% 的Java用户\t内存消耗:38.6 MB,击败了49.49% 的Java用户"},{"title":"只出现一次的数字III","path":"/wiki/leetcode/每日一题/23-10-16只出现一次的数字III.html","content":"只出现一次的数字III date:2023/10/16 260. 只出现一次的数字 III 中等 给你一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。 你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。 示例 1： 输入：nums = [1,2,1,3,2,5]输出：[3,5]解释：[5, 3] 也是有效的答案。 示例 2： 输入：nums = [-1,0]输出：[-1,0] 示例 3： 输入：nums = [0,1]输出：[1,0] 提示： 2 &lt;= nums.length &lt;= 3 * 104 -231 &lt;= nums[i] &lt;= 231 - 1 除两个只出现一次的整数外，nums 中的其他数字都出现两次 解题思路 依旧采用位运算，与136类似依次异或后会得到 两个只出现一次的整数的异或，使用lowbit求出第一次出现的1，再以此对原数组进行分类，重新异或即可求出两数。 class Solution &#123; public int[] singleNumber(int[] nums) &#123; int once = 0; for(int number : nums)&#123; once ^= number; &#125; // once == one ^ other int diff = once &amp; -once; int one = 0; for(int number : nums)&#123; if((number &amp; diff) != 0)&#123; one ^= number; &#125; &#125; int other = once ^ one; return new int[]&#123;one, other&#125;; &#125;&#125; 解答成功:\t执行耗时:0 ms,击败了 100.00%使用 Java 的用户\t内存消耗:42.06MB,击败了84.27%使用 Java 的用户"},{"title":"执行K次操作后的最大分数","path":"/wiki/leetcode/每日一题/23-10-18执行k次操作后的最大分数.html","content":"执行K次操作后的最大分数 date:2023/10/18 2530. 执行 K 次操作后的最大分数 中等 给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。你的 起始分数 为 0 。 在一步 操作 中： 选出一个满足 0 &lt;= i &lt; nums.length 的下标 i ， 将你的 分数 增加 nums[i] ，并且 将 nums[i] 替换为 ceil(nums[i] / 3) 。 返回在 恰好 执行 k 次操作后，你可能获得的最大分数。 向上取整函数 ceil(val) 的结果是大于或等于 val 的最小整数。 示例 1： 输入：nums = [10,10,10,10,10], k = 5输出：50解释：对数组中每个元素执行一次操作。最后分数是 10 + 10 + 10 + 10 + 10 = 50 。 示例 2： 输入：nums = [1,10,3,3,3], k = 3输出：17解释：可以执行下述操作：第 1 步操作：选中 i = 1 ，nums 变为 [1,4,3,3,3] 。分数增加 10 。第 2 步操作：选中 i = 1 ，nums 变为 [1,2,3,3,3] 。分数增加 4 。第 3 步操作：选中 i = 2 ，nums 变为 [1,1,1,3,3] 。分数增加 3 。最后分数是 10 + 4 + 3 = 17 。 提示： 1 &lt;= nums.length, k &lt;= 105 1 &lt;= nums[i] &lt;= 109 解题思路 ceil(a/b) == (a + b - 1) / b 要使在执行k次操作后得到的分数最大，则每次应该要选取最大的数，贪心的思维。 要保证取得数组中最大的元素，先考虑了排序。 class Solution &#123; public long maxKelements(int[] nums, int k) &#123; int res = 0; int index = nums.length - 1; // 需要分数最大，则每次挑选最大的nums[i] while (k &gt; 0)&#123; Arrays.sort(nums); res += nums[index]; nums[index] = ceil((nums[index] + 2)/3 ); k --; &#125; return res; &#125;&#125; 解答失败:\t测试用例:[672579538,806947365,854095676,815137524] 3\t测试结果:-1818786731\t期望结果:2476180565 这里是审题问题，想当然的以int来存储结果了，然后在这里int类型不足以存储答案，将int改为long即可。而且这个答案显然会超时，每次迭代中要对数组进行排序，会导致时间复杂度为O(nlogn)，效率较低，由此选择使用优先队列来解决。 class Solution &#123; public long maxKelements(int[] nums, int k) &#123; long res = 0; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((a,b) -&gt; b - a); for (Integer num : nums)&#123; pq.offer(num); &#125; // 需要分数最大，则每次挑选最大的nums[i] while (k &gt; 0)&#123; int temp = pq.poll(); res += temp; pq.offer((temp + 2) / 3); k --; &#125; return res; &#125;&#125; 解答成功:\t执行耗时:140 ms,击败了24.42% 的Java用户\t内存消耗:59 MB,击败了59.30% 的Java用户"},{"title":"同积元组","path":"/wiki/leetcode/每日一题/23-10-19同积元组.html","content":"同积元组 date:2023/10/19 1726. 同积元组 中等 给你一个由 不同 正整数组成的数组 nums ，请你返回满足 a * b = c * d 的元组 (a, b, c, d) 的数量。其中 a、b、c 和 d 都是 nums 中的元素，且 a != b != c != d 。 示例 1： 输入：nums = [2,3,4,6]输出：8解释：存在 8 个满足题意的元组：(2,6,3,4) , (2,6,4,3) , (6,2,3,4) , (6,2,4,3)(3,4,2,6) , (4,3,2,6) , (3,4,6,2) , (4,3,6,2) 示例 2： 输入：nums = [1,2,4,5,10]输出：16解释：存在 16 个满足题意的元组：(1,10,2,5) , (1,10,5,2) , (10,1,2,5) , (10,1,5,2)(2,5,1,10) , (2,5,10,1) , (5,2,1,10) , (5,2,10,1)(2,10,4,5) , (2,10,5,4) , (10,2,4,5) , (10,2,5,4)(4,5,2,10) , (4,5,10,2) , (5,4,2,10) , (5,,10,2) 提示： 1 &lt;= nums.length &lt;= 1000 1 &lt;= nums[i] &lt;= 104 nums 中的所有元素 互不相同 解题思路 由于给定的正整数数组都是不同的，所以使用hash表去依次记录两两乘积的结果以及出现次数，由题意可知，每两组乘积可以贡献8个答案，所以还需要通过n(n - 1)/2 去计算排序结果，最后乘8即为所求答案。 class Solution &#123; public int tupleSameProduct(int[] nums) &#123; HashMap&lt;Integer, Integer&gt; ansCount = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; int temp = nums[i] * nums[j]; ansCount.put(temp, ansCount.getOrDefault(nums[i] * nums[j], 0) + 1); &#125; &#125; int ans = 0; for (int val : ansCount.values()) &#123; ans += val * (val - 1) / 2; &#125; return ans &lt;&lt; 3; &#125;&#125; 解答成功:\t执行耗时:177 ms,击败了86.67% 的Java用户\t内存消耗:61.1 MB,击败了81.33% 的Java用户"},{"title":"根据规则将箱子分类","path":"/wiki/leetcode/每日一题/23-10-20根据规则将箱子分类.html","content":"根据规则将箱子分类 date:2023/10/20 2525. 根据规则将箱子分类 简单 给你四个整数 length ，width ，height 和 mass ，分别表示一个箱子的三个维度和质量，请你返回一个表示箱子 类别 的字符串。 如果满足以下条件，那么箱子是 &quot;Bulky&quot; 的： 箱子 至少有一个 维度大于等于 104 。 或者箱子的 体积 大于等于 109 。 如果箱子的质量大于等于 100 ，那么箱子是 &quot;Heavy&quot; 的。 如果箱子同时是 &quot;Bulky&quot; 和 &quot;Heavy&quot; ，那么返回类别为 &quot;Both&quot; 。 如果箱子既不是 &quot;Bulky&quot; ，也不是 &quot;Heavy&quot; ，那么返回类别为 &quot;Neither&quot; 。 如果箱子是 &quot;Bulky&quot; 但不是 &quot;Heavy&quot; ，那么返回类别为 &quot;Bulky&quot; 。 如果箱子是 &quot;Heavy&quot; 但不是 &quot;Bulky&quot; ，那么返回类别为 &quot;Heavy&quot; 。 注意，箱子的体积等于箱子的长度、宽度和高度的乘积。 示例 1： 输入：length = 1000, width = 35, height = 700, mass = 300输出：&quot;Heavy&quot;解释：箱子没有任何维度大于等于 104 。体积为 24500000 &lt;= 109 。所以不能归类为 &quot;Bulky&quot; 。但是质量 &gt;= 100 ，所以箱子是 &quot;Heavy&quot; 的。由于箱子不是 &quot;Bulky&quot; 但是是 &quot;Heavy&quot; ，所以我们返回 &quot;Heavy&quot; 。 示例 2： 输入：length = 200, width = 50, height = 800, mass = 50输出：&quot;Neither&quot;解释：箱子没有任何维度大于等于 104 。体积为 8 * 106 &lt;= 109 。所以不能归类为 &quot;Bulky&quot; 。质量小于 100 ，所以不能归类为 &quot;Heavy&quot; 。由于不属于上述两者任何一类，所以我们返回 &quot;Neither&quot; 。 提示： 1 &lt;= length, width, height &lt;= 105 1 &lt;= mass &lt;= 103 解题思路 捋出规则并分别判断即可 class Solution &#123; public String categorizeBox(int length, int width, int height, int mass) &#123; // 1. length, width, height 任意一个大于 10^4 || length * width * height 大于 10^9 则 Bulky // 2. mass 大于 100 则 Heavy // 1 &amp;&amp; 2 则 Both // ! 1 &amp;&amp; ! 2) 则 Neither // 1 &amp;&amp; ! 2 则 Bulky // ! 1 &amp;&amp; 2 则 Heavy boolean bulky = bulky(new int[] &#123;length, width, height&#125;); boolean heavy = mass &gt;= 100; if (bulky &amp;&amp; heavy) &#123; return &quot;Both&quot;; &#125; else if (heavy) &#123; return &quot;Heavy&quot;; &#125; else if (bulky) &#123; return &quot;Bulky&quot;; &#125; else &#123; return &quot;Neither&quot;; &#125; &#125; public boolean bulky(int[] nums) &#123; boolean flag = false; long temp = 1L; for (int num : nums) &#123; if (num &gt;= 10000) &#123; flag = true; return flag; &#125; temp *= num; &#125; if (temp &gt;= 1000000000) &#123; flag = true; return flag; &#125; return flag; &#125;&#125; 解答成功:\t执行耗时:0 ms,击败了100.00% 的Java用户\t内存消耗:38.3 MB,击败了96.80% 的Java用户"},{"title":"关于链表","path":"/wiki/leetcode/链表/关于链表.html","content":"关于链表 链表（Linked List）是一种常用的数据结构，用于存储和组织一系列的元素。它由一组节点（Node）组成，每个节点包含两部分：数据部分（存储元素的值）和指针部分（指向下一个节点的指针）。节点之间通过指针连接，形成一个链式结构。 每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。 链表的入口节点称为链表的头结点也就是head。 如图所示： 链表1 链表的特点 相比于数组，链表的一个主要特点是插入和删除元素的操作效率较高，而访问元素的效率较低。这是因为链表的插入和删除只需修改节点指针的指向，而不需要像数组那样移动大量元素。然而，由于链表中的节点并非连续存储，而是通过指针相连，所以在查找某个元素时需要从链表头开始逐个遍历节点，因此访问元素的效率较低。 链表在许多算法和数据结构中有广泛应用，例如堆栈（Stack）、队列（Queue）等。在实际编程中，链表可以使用面向对象的方式进行实现。每个节点可以定义为一个类，其中包含数据部分和指向下一个节点的指针，通过节点之间的链接，可以构建出一个完整的链表结构。 链表的类型 单链表 双链表 循环链表 双链表 单链表中的指针域只能指向节点的下一个节点。 双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。 双链表 既可以向前查询也可以向后查询。 如图所示： 链表2 #循环链表 循环链表（Circular Linked List）。循环链表与普通链表类似，不同之处在于循环链表的最后一个节点指向第一个节点，形成一个循环的环状结构。 在循环链表中，每个节点仍然包含数据部分和指向下一个节点的指针。与单向链表类似，循环链表的节点可以通过指针相互连接。不同之处是，循环链表的最后一个节点的指针指向链表的头节点，而头节点的指针依然指向下一个节点。 循环链表的一个优点是可以方便地遍历整个链表，只需从头节点开始，一直遍历到头节点为止。另外，循环链表也可以在实际应用中用于解决一些特定的问题，比如循环队列等。 循环链表可以用来解决约瑟夫环问题。 链表4 链表的存储方式 了解完链表的类型，再来说一说链表在内存中的存储方式。 数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。 链表是通过指针域的指针链接在内存中各个节点。 所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。 如图所示： 链表3 这个链表起始节点为2， 终止节点为7， 各个节点分布在内存的不同地址空间上，通过指针串联在一起。 链表的定义 单链表 class ListNode&#123;\tint val; ListNode next;\tpublic ListNode()&#123;&#125;\tpublic ListNode(int val)&#123; this.val = val;\t&#125;\tpublic ListNode(int val, ListNode next)&#123; this.val = val; this.next = next;\t&#125;&#125; 双链表 class ListNode&#123; int val; ListNode prev; ListNode next; public ListNode(int val)&#123; this.val = val; this.prev = null; this.next = null; &#125;&#125;class DoublyLinkedList&#123; ListNode head; public DoublyLinkedList()&#123; this.head = null; &#125; public void insert(int val)&#123; ListNode newNode = new ListNode(val); if(head == null)&#123; head = newNode; &#125;else&#123; ListNode currentNode = head; while(currentNode.next != null)&#123; currentNode = currentNode.next; &#125; currentNode.next = newNode; newNode.prev = currentNode; &#125; &#125;&#125; 循环链表 class ListNode &#123; int val; ListNode next; public ListNode(int val) &#123; this.val = val; this.next = null; &#125;&#125;class CircularLinkedList &#123; ListNode head; public CircularLinkedList() &#123; this.head = null; &#125; public void insert(int val) &#123; ListNode newNode = new ListNode(data); if (head == null) &#123; head = newNode; newNode.next = head; &#125; else &#123; ListNode currentNode = head; while (currentNode.next != head) &#123; currentNode = currentNode.next; &#125; currentNode.next = newNode; newNode.next = head; &#125; &#125;&#125; 链表操作 删除节点 只需要将该节点上一个写点的next指针指向该写点的下一个节点就可以了。 在java语音中有垃圾回收机制，会自动处理。 添加节点 选择在某一节点处添加指针，将该节点的next节点指向添加节点，将添加节点的指针指向该节点的下一节点。 性能分析 再把链表的特性和数组的特性进行一个对比，如图所示： 链表-链表与数据性能对比 数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。 链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。 参考资料：代码随想录 (programmercarl.com)"},{"title":"两两交换链表中的节点","path":"/wiki/leetcode/链表/两两交换链表中的节点 .html","content":"两两交换链表中的节点 24. 两两交换链表中的节点 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 示例 1： img 输入：head = [1,2,3,4]输出：[2,1,4,3] 示例 2： 输入：head = []输出：[] 示例 3： 输入：head = [1]输出：[1] 提示： 链表中节点的数目在范围 [0, 100] 内 0 &lt;= Node.val &lt;= 100 解题思路 根据三个示例可以分析出一些问题， img 示例一我们可以看出，在正常交换的情况下，结点的数量应该需要保证是偶数个，否则1-》2-》3-》4 交换过后应该是 2-》3-》4-》1显然不符合示例。所以1和2交换过后是3和4交换。 再到返回结果来说，我们需要返回的是头结点，但是显然在交换过程中指针是在不断变化的，所以我们需要确定一个不变的指针去记录头结点的情况，自然能够想到定义一个dummy节点，dummy的next指向头结点，我们在最后返回结果的时候，只需要返回dummy.next即可。 回到交换，因为是两两交换，拿1和2举例子，我们只需要确定curr = 1，curr.next != null ，就可以进行交换了，所以可以确定的一个条件是 curr.next != null。 再到交换的过程，拿示例1举例子，假如我们先将2指向1，那就会失去2与3的链接，1就无法知道自己要指向哪，所以优先将1.next -&gt; 2.next ，再将 2.next -&gt; 1 这样才不会出现断联的现象。 但是仔细思考会出现一个问题，此时dummy.next 指向的是 1，但是2指向后却没有续联，dummy.next指向的仍然是1，所以我们或许还需要一个参数prev来保证每(两两)个之间的续联。 示例二我们可以看出当head节点为空时，直接返回，所以curr ！= null 示例三我们可以看出当head.next 为空，没必要继续判断，即 curr.next != null。 解题 class Solution &#123; public ListNode swapPairs(ListNode head) &#123; // 提供一个链表，两两交换相邻节点，最后返回头结点 // 1. 初始化变量 dummy节点，curr节点，prev节点 ListNode dummy = new ListNode(); dummy.next = head; ListNode curr = head; ListNode prev = dummy; // 2. 确定循环条件 while (curr != null &amp;&amp; curr.next != null)&#123; // 3. 执行交换 ListNode temp = curr.next; curr.next = temp.next; temp.next = curr; prev.next = temp; // 4. 向前推进 prev = curr; curr = curr.next; &#125; // 4. 返回结果 return dummy.next; &#125;&#125; 个人看法 第一次把解题思路打出来，可能比较乱，但是应该是比较方便理解，也更有利于我自己后续复习使用。我个人认为把解题思路打出来或者写出来是一个非常不错的方法，因为思绪是比较零散跳动的，有时候突然想到一个点没有记录下来后续可能就忘了。 回想起之前刷题的时候，各种捋思路，感觉非常通顺，但是实现的时候到处都是问题，每次编写完自己也没个底，但刷题就是这样的，没有谁能百分百编写出来就通过，主要在于锻炼自己的思维，继续加油吧。 回到本题，这题的解法还是比较多的，因为是循环做同一件事，所以也可以使用递归解决，不过个人看来在大多数对链表进行删除，添加，交换的情况，使用虚拟头结点的方式都是不错的解法。"},{"title":"螺旋矩阵II","path":"/wiki/leetcode/数组/螺旋矩阵II.html","content":"螺旋矩阵 59. 螺旋矩阵 II 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 示例 1： img 输入：n = 3输出：[[1,2,3],[8,9,4],[7,6,5]] 示例 2： 输入：n = 1输出：[[1]] 提示： 1 &lt;= n &lt;= 20 解题 class Solution &#123; public int[][] generateMatrix(int n) &#123; // 正整数n 生成 1 -&gt; n * n 的元素按顺时针螺旋排序构成 n * n 的正方形矩阵 // 1. 初始化变量 记录下标位置,起始点 结果数组, 循环圈数 int x = 0, y = 0, index = 1, startX = 0, startY = 0; int res[][] = new int[n][n]; int loop = 0; // 2. 确定循环条件 while (loop++ &lt; n / 2 ) &#123; // 3.1 从左 -&gt; 右 for(y = startY; y &lt; n - loop; y ++)&#123; res[startX][y] = index++; &#125; // 3.2 从上 -&gt; 下 for(x = startX; x &lt; n - loop; x ++)&#123; res[x][y] = index++; &#125; // 3.3 从右 -&gt; 左 for(; y &gt; startY; y --)&#123; res[x][y] = index++; &#125; // 3.4 从下 -&gt; 上 for(; x &gt; startX; x--)&#123; res[x][y] = index++; &#125; startX++; startY++; &#125; // 4. 奇数特殊处理中心 if (n % 2 == 1)&#123; res[startX][startY] = index; &#125; return res; &#125;&#125; image-20230904130209025 个人看法 一道中等难度的题目，对于圈数的认知选择非常关键，是否有将单独点排除出圈单独处理，是在我看来本题的难点。 正确的圈数认知能够帮助我们确定循环条件以及步数。 不建议像我一样选择x，y作为坐标变量名思维惯性可能会套入坐标系导致做题时误导成横纵坐标 解题思路 关于起始点与终止点 按顺序依次处理的时候，需要明确上下左右的起始点和终点在哪 举个例子 img 就该图而言，向左起点如果是1，终点应该是2，而不是3 否则对于向下来说，起点是4，终点是5， 对于向右来说，起点是6，终点是7， 对于向上来说，起点是8，终点也是8。 这样看来，我们四次的步长向左是3步，向下和向右是2步，向上是1步，这样是不好编写的。 再看这个有n=4构成的正方形矩阵 1 2 3 4 12 13 14 5 11 16 15 6 10 9 8 7 第一次循环的步数推得为3步。第二次循环的步数推得为1步 起始步长为n-1步即3步，第二次步长为n-2步即1步 可以看出 n-1中 1 为第一次循环， n-2 中2为第二次循环 所以可以推断出对于步数的处理应该是 n - loop 圈数判断 我们需要大致正确的找到循环圈数的规律。 n = 1 -&gt; 1 圈数为1 n = 2 -&gt; 1 2 4 3 圈数为1 n = 3 -&gt; 1 2 3 8 9 4 7 6 5 圈数为2 n = 4 -&gt; 1 2 3 4 12 13 14 5 11 16 15 6 10 9 8 7 圈数为2 n = 5 -&gt; 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 圈数为3 n = 6 推断 为3 n = 7 推断 为 4 n = 8 推断为 4 可得12-1 34-2 56-3 78-4 不难推断循环旋转圈数应该是 (n + 1)/2 向下取整 但是如果选择以该圈数作为循环其实是有问题的，因为我们一次循环会经历上下左右的处理，但是在n为奇数时我们会发现在中间是只有一个小块而不是一圈，如果将此作为一圈得出的结果显然是违背题意的。 所以我们忽略只有单块的层级可以得出以下结论 1-0 23-1 45 -2 67-3 89-4 由此推断出循环的圈数应该是 n/2 向下取整 综上所述，我们可以知道。 对于正整数n 生成 1 -&gt; n * n 的元素按顺时针螺旋排序构成 n * n 的正方形矩阵 需要进行 n / 2 次循环 每次循环的步数为 n - loop"},{"title":"长度最小的子数组","path":"/wiki/leetcode/数组/长度最小的子数组.html","content":"长度最小的子数组 209. 长度最小的子数组 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度**。**如果不存在符合条件的子数组，返回 0 。 示例 1： 输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2： 输入：target = 4, nums = [1,4,4]输出：1 示例 3： 输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0 提示： 1 &lt;= target &lt;= 109 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105 进阶： 如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。 解法 class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; // 找出数组中和 &gt;= target 的长度最小的 连续的 子数组，返回长度，如果不存在返回0 // 我这里只想到应该是O(n)的解法，使用滑动窗口，最差的情况应该是遍历完集合，后续尝试看看能不能写出O(nlog(n))的解法 // 1. 初始化变量 左右窗口指针,返回结果(结果设置最大整数方便后续判断)，窗口值 int left = 0, right = 0, res = Integer.MAX_VALUE, sum = 0; // 2. 确定循环条件 这里选择右指针小于数组长度时循环，也就是直到右指针走出数组循环结束 while (right &lt; nums.length )&#123; sum += nums[right++]; while(sum &gt;= target )&#123; // 当窗口值大于等于target时，收集结果值，并且收缩窗口，窗口右滑，因为可能删去一个还是大于，所以用while保证判断结束后一定小于target res = res &lt; right - left ? res : right - left; sum -= nums[left++]; &#125; &#125; // 3. 返回结果 return res == Integer.MAX_VALUE ? 0 : res; &#125;&#125; 个人看法 一道中等难度的题目，个人认为主要在于res的选值如果赋予0为初始值的话后续结果不好判断 再就是收集结果的时候对于if和while的选择很关键。"},{"title":"移除元素","path":"/wiki/leetcode/数组/移除元素.html","content":"移除元素 27. 移除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 示例 1： 输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2： 输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示： 0 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 50 0 &lt;= val &lt;= 100 解题 class Solution &#123; public int removeElement(int[] nums, int val) &#123; // 原地移除数组中数值等于val的元素，返回移除后新数组的新长度，O(1)的额外空间, // 快慢指针 快指针自增遍历，当且仅当遇到！=val的元素时更新慢指针前进 // 1. 初始化变量 int fast = 0, slow = 0; for(;fast &lt; nums.length; fast++)&#123; if (nums[fast] != val)&#123; // 当且仅当遇到！=val的元素时更新慢指针前进 nums[slow] = nums[fast]; slow++; &#125; &#125; // 2. 返回新数组长度 return slow; &#125;&#125; 个人看法 也是比较基础的一个双指针的问题，这里使用的是快慢指针，因为我们需要原地更新数组。 快指针去寻找符合条件的数据传递给慢指针更新数组即可。"},{"title":"删除链表的倒数第 N 个结点","path":"/wiki/leetcode/链表/删除链表的倒数第n个节点.html","content":"删除链表的倒数第 N 个结点 19. 删除链表的倒数第 N 个结点 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例 1： img 输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5] 示例 2： 输入：head = [1], n = 1输出：[] 示例 3： 输入：head = [1,2], n = 1输出：[1] 提示： 链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz **进阶：**你能尝试使用一趟扫描实现吗？ 解题思路 要求解倒数第n个节点，我首先想到的是采用递归，当 curr.next == null 时返回，并在返回后进行 n–, 当n == 0 时，表示到达了倒数第n + 1 个节点，也就是倒数第n个节点的前一个节点，此时要进行删除就很简单了。 我很快就写出了初版代码 class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; // 给定一个链表，删除倒数第n个节点，最后返回头结点 // 1. 终止判断，到达末尾节点 if(head.next == null) return head; head.next = removeNthFromEnd(head.next, n); n--; if (n == 0 &amp;&amp; head.next != null)&#123; // 到达需要被删除的节点的前一个节点 // 2. 删除 head.next = head.next.next; &#125; // 3. 返回 return head; &#125;&#125; 很显然这是有问题的 假设n=2，则每次递归时n都是2，不管怎么减，返回后到达新的区域n仍是当前区域的2，我们减的是上一个区域的n。 确定问题后就好办了。我们只需要另设一个方法返回int值，当到达末尾时返回1，直到count值==n值的时候，就到达倒数第n + 1 个节点。 此外，为了应对[]这种特殊情况，因为当head == null 时，我们无法到达head.next 所以在选择curr节点的时候，选择dummy结点进行判断，这样当进入remove方法时就会直接被终止条件剔除。从而正常通过。 解题 - 递归 class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; // 给定一个链表，删除倒数第n个节点，最后返回头结点 ListNode dummy = new ListNode(); dummy.next = head; remove(dummy, n); return dummy.next; &#125; public int remove(ListNode curr, int n)&#123; // 1. 终止判断，到达末尾节点 if(curr.next == null) return 1; int count = remove(curr.next, n); if (n == count)&#123; // 到达需要被删除的节点的前一个节点 // 2. 删除 curr.next = curr.next.next; &#125; // 3. 返回 return count + 1; &#125;&#125; 快慢指针解法 仔细想来，在数组中我们层用过一个解法可以使得两点之间可以有一定距离的，就是双指针法，双指针法常用于滑动窗口，快慢指针，二分等问题，这里使用的是快慢指针。 根据题意说明，需要删除倒数第n个节点，我们只需要定义快慢指针，在初始化时，快指针比慢指针多走n步，然后一起向前遍历，当快指针到达终点时，慢指针恰好到达倒数第n+1个指针，然后我们直接操作慢指针即可。 下面是代码实现 解题 - 快慢指针 class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; // 给定一个链表，删除倒数第n个节点，最后返回头结点 // 使用快慢指针 // 1. 初始化变量 快慢指针,dummy指针 ListNode dummy = new ListNode(); dummy.next = head; ListNode fast = dummy; ListNode slow = dummy; // 2.初始化快指针 while(n-- != 0)&#123; fast = fast.next; &#125; // 3. 向前推进 while (fast.next != null)&#123; fast = fast.next; slow = slow.next; &#125; // 4. 执行删除 slow.next = slow.next.next; // 5. 返回 return dummy.next; &#125;&#125; 个人看法 依旧是离不开dummy指针，dummy指针在处理链表时真的很好用。题目本身难度并不大，细心细心再细心。"},{"title":"反转链表","path":"/wiki/leetcode/链表/反转链表.html","content":"反转链表 206. 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： img 输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 示例 2： img 输入：head = [1,2]输出：[2,1] 示例 3： 输入：head = []输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 &lt;= Node.val &lt;= 5000 解题 递归 class Solution &#123; public ListNode reverseList(ListNode head) &#123; // 给定单链表的头结点，反转链表 if (head == null) return null; // 边界判定 if(head.next == null)&#123; // 当结点的下一个节点为空时，表示到达最底部 return head; &#125; ListNode temp = reverseList(head.next); // 头结点 head.next.next = head; head.next = null; return temp; &#125;&#125; 双指针 class Solution &#123; public ListNode reverseList(ListNode head) &#123; // 1. 初始化变量 前指针，当前指针，临时指针 ListNode prev = null; ListNode curr = head; ListNode temp = null; while(curr != null)&#123; temp = curr.next; curr.next = prev; prev = curr; curr = temp; &#125; return prev; &#125;&#125; 个人看法 比较经典的链表题，第一反应就是递归，但是一开始选择了使用返回的头结点去处理导致后续无法拿到头结点，卡了一会才解决。"},{"title":"移除链表元素","path":"/wiki/leetcode/链表/移除链表元素.html","content":"移除链表元素 203. 移除链表元素 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 示例 1： img 输入：head = [1,2,6,3,4,5,6], val = 6输出：[1,2,3,4,5] 示例 2： 输入：head = [], val = 1输出：[] 示例 3： 输入：head = [7,7,7,7], val = 7输出：[] 提示： 列表中的节点数目在范围 [0, 104] 内 1 &lt;= Node.val &lt;= 50 0 &lt;= val &lt;= 50 解题 /** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; if (head == null) &#123; return head; &#125; // 1. 初始化变量，虚拟节点 ListNode dummy = new ListNode(-1, head); ListNode prev = dummy; ListNode curr = head; // 2. 遍历链表 while(curr != null)&#123; // 判断当前节点的值是否是目标值呢 if (curr.val == val)&#123; prev.next = curr.next; &#125;else &#123; prev = curr; &#125; curr = curr.next; &#125; // 3. 返回结果 return dummy.next; &#125;&#125; 个人看法 使用虚拟节点占位能够有效方便的去处理链表的添加删除问题。"},{"title":"设计链表","path":"/wiki/leetcode/链表/设计链表.html","content":"设计链表 707. 设计链表 你可以选择使用单链表或者双链表，设计并实现自己的链表。 单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。 如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。 实现 MyLinkedList 类： MyLinkedList() 初始化 MyLinkedList 对象。 int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。 void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。 void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。 void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。 void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。 示例： 输入[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;][[], [1], [3], [1, 2], [1], [1], [1]]输出[null, null, null, null, 2, null, 3]解释MyLinkedList myLinkedList = new MyLinkedList();myLinkedList.addAtHead(1);myLinkedList.addAtTail(3);myLinkedList.addAtIndex(1, 2); // 链表变为 1-&gt;2-&gt;3myLinkedList.get(1); // 返回 2myLinkedList.deleteAtIndex(1); // 现在，链表变为 1-&gt;3myLinkedList.get(1); // 返回 3 提示： 0 &lt;= index, val &lt;= 1000 请不要使用内置的 LinkedList 库。 调用 get、addAtHead、addAtTail、addAtIndex 和 deleteAtIndex 的次数不超过 2000 。 解题 class ListNode&#123; int val; ListNode next; public ListNode()&#123;&#125; public ListNode(int val)&#123; this.val = val; this.next = null; &#125;&#125;class MyLinkedList &#123; ListNode dummy; int size; public MyLinkedList() &#123; size = 0; // 在链表中，对于新增和删除操作，一般需要找到被操作节点的前一个节点 // 初始化时选择将头结点初始成一个dummy节点，后续操作index + 1 dummy = new ListNode(-1); &#125; public int get(int index) &#123; // 对于获取，我们需要取得index后一位 // 1. 数据校验 if (index &lt; 0 || index &gt;= size)&#123; return -1; &#125; ListNode curr = dummy; for(int i = 0; i &lt; index; i++)&#123; curr = curr.next; &#125; return curr.next.val; &#125; public void addAtHead(int val) &#123; // 添加到头部 也就是index = 0 的位置 addAtIndex(0, val); &#125; public void addAtTail(int val) &#123; // 添加到尾部 也就是index = size 的位置 addAtIndex(size, val); &#125; public void addAtIndex(int index, int val) &#123; // 指定位置添加 // 1. 数据校验 if (index &lt; 0)&#123; index = 0; &#125; if (index &gt; size)&#123; return; &#125; // 2. 长度 + 1 size++; // 3. 找对应位置 ListNode prev = dummy; for(int i = 0; i &lt; index; i++)&#123; prev = prev.next; &#125; // 4. 执行添加 ListNode newNode = new ListNode(val); newNode.next = prev.next; prev.next = newNode; &#125; public void deleteAtIndex(int index) &#123; // 删除指定位置 // 1. 数据校验 if (index &lt; 0 || index &gt;= size)&#123; return; &#125; // 2. 长度 - 1 size--; if (index == 0)&#123; dummy = dummy.next; return; &#125; // 3. 找对应位置 ListNode prev = dummy; for (int i = 0; i &lt; index; i++)&#123; prev = prev.next; &#125; prev.next = prev.next.next; &#125;&#125; image-20230905201426319 个人看法 主要难点在于对MyLinkedList的初始化，我们在设置MyLinkedList时选择定义了一个ListNode类型的dummy作为虚拟节点，这样方便我们在后续的增删链表会更加方便，相应的在get的处理上就需要多取一个结点，只要搞定这点，其他都是基础的链表处理。双链表的思路基本大差不差，处理好前后指针的关系即可。 解题思路 在选择使用单链表解题后，基本是按照通过定位被操作节点的上一节点，来对被操作节点进行处理。"},{"title":"链表相交","path":"/wiki/leetcode/链表/链表相交.html","content":"链表相交 面试题 02.07. 链表相交 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 图示两个链表在节点 c1 开始相交**：** img 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 示例 1： img 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Intersected at &#x27;8&#x27;解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： img 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Intersected at &#x27;2&#x27;解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： img 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。 提示： listA 中节点数目为 m listB 中节点数目为 n 0 &lt;= m, n &lt;= 3 * 104 1 &lt;= Node.val &lt;= 105 0 &lt;= skipA &lt;= m 0 &lt;= skipB &lt;= n 如果 listA 和 listB 没有交点，intersectVal 为 0 如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1] 解题思路 通过观察例一例二和例三，我们可以看出，假设链表存在相交，那么相交之后的所有节点是相同的，因此假如存在相交，相交后节点数是相同的。 那么我们只需要依次遍历得到链表的长度，lenA - lenB = x 将更长的链表先移动x步，再依次比较即可。 解题 public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; // 1. 初始化变量 int lenA = 0, lenB = 0; ListNode currA = headA, currB = headB; // 1.1 计算长度 while (currA != null) &#123; lenA++; currA = currA.next; &#125; while (currB != null) &#123; lenB++; currB = currB.next; &#125; // 2. 选出更长的一方 if (lenB &gt; lenA) &#123; ListNode temp = headA; headA = headB; headB = temp; int tempLen = lenA; lenA = lenB; lenB = tempLen; &#125; // 3. 计算差值并移动 currA = headA; currB = headB; int diff = lenA - lenB; while (diff &gt; 0) &#123; currA = currA.next; diff--; &#125; // 4. 遍历比较 while (currA != null) &#123; if (currA == currB) &#123; return currA; &#125; currA = currA.next; currB = currB.next; &#125; // 5. 返回 return null; &#125;&#125; 个人看法 这题实际上实现起来的难度并不大，是一题简单题，主要在于对题目的理解。这里提供一种更简单的实现，上一次看到就不明觉厉，现在再看还是羡慕大佬的思维。 解法2 以示例一为例 img 我们看到链表会相交并且相交于节点8，此时相交后的长度为3，A相交前的长度为2，B相交前的长度为3。 我们令链表A在遍历完A链表后去遍历链表B 令链表B在遍历完链表B后去遍历链表A 那么会存在 A走 2(A相交前的长度) + 3(相交后的长度) + 3(B相交前的长度) B走 3(B相交前的长度) + 3(相交后的长度) + 2(A相交前的长度) 此时，他们会在相同的步数下相交与同一点也就是节点8 再以示例二为例 img 依旧会存在 A走 3(A相交前的长度) + 2(相交后的长度) + 1(B相交前的长度) B走 1(B相交前的长度) + 2(相交后的长度) + 3(A相交前的长度) 在相同的步数下交于节点2 那么也就是说，假如存在某一个节点使得两条链表相交，那么只需要同时开始遍历并在遍历完自身后交换遍历，则一定会在某一点相交。 示例三 img 示例三是不存在链表相交的，但是我们可以 把链表A 看作 2 -》 6 -》 4 -》 null 把链表B 看作 1 -》 5 -》 null 此时可以看作A和B相交于null 总结来说就是，两天链表同时开始遍历并在遍历完自身后交换遍历，假如两点在null相遇，则表示两条链表没有交点，假如两点相遇在某个点，那么这个点就是两条链表的起始交点。 下面给出实现代码 解题 public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; // 1. 初始化变量 ListNode currA = headA, currB = headB; // 2. 确定终止条件，当两节点相遇时结束循环 while(currA != currB)&#123; currA = currA == null ? headB : currA.next; currB = currB == null ? headA : currB.next; &#125; // 3. 直接返回二者之一即可 return currA; &#125;&#125;"},{"title":"管理端-修改分类","path":"/wiki/xiaomo/后台管理端/修改分类-04.html","content":"修改分类 接口地址:/admin/category 请求方式:PUT 请求数据类型:application/json 响应数据类型:*/* 接口描述: 请求示例: &#123; &quot;id&quot;: 0, &quot;name&quot;: &quot;&quot;, &quot;sort&quot;: 0, &quot;type&quot;: 0&#125; 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema categoryDTO categoryDTO body true 分类DTO 分类DTO id 主键 false integer(int64) name 分类名称 false string sort 排序 false integer(int32) type 类型 1 菜品分类 2 套餐分类 false integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«string» 201 Created 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &quot;&quot;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @PutMapping@ApiOperation(&quot;修改分类&quot;)public Result&lt;String&gt; update(@RequestBody CategoryDTO categoryDTO) &#123; log.info(&quot;修改分类：&#123;&#125;&quot;, categoryDTO); return categoryService.update(categoryDTO);&#125; Impl /** * 修改分类 * * @param categoryDTO * @return */@Overridepublic Result&lt;String&gt; update(CategoryDTO categoryDTO) &#123; // 1. 校验参数 if (!categoryDTO.check()) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 初始化参数 Category category = new Category(); BeanUtils.copyProperties(categoryDTO, category); // 3. 修改 updateById(category); // 3.1 删除缓存 redisUtil.cleanCaches(RedisKeyConstant.DELETE_CATEGORY); return Result.success();&#125;"},{"title":"管理端-修改员工密码","path":"/wiki/xiaomo/后台管理端/修改员工密码.html","content":"修改员工密码 接口地址:/admin/employee/editPassword 请求方式:PUT 请求数据类型:application/json 响应数据类型:*/* 接口描述: 请求示例: &#123; &quot;newPassword&quot;: &quot;&quot;, &quot;oldPassword&quot;: &quot;&quot;&#125; 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema employeePasswordDTO employeePasswordDTO body true 修改密码 修改密码 newPassword 新密码 false string oldPassword 旧密码 false string 响应状态: 状态码 说明 schema 200 OK Result«string» 201 Created 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &quot;&quot;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @ApiOperation(&quot;修改员工密码&quot;) @PutMapping(&quot;/editPassword&quot;) public Result&lt;String&gt; editPassword(@RequestBody EmployeePasswordDTO employeePasswordDTO)&#123; return employeeService.editPassword(employeePasswordDTO); &#125; Impl /** * 修改员工密码 * * @param employeePasswordDTO * @return */@Overridepublic Result&lt;String&gt; editPassword(EmployeePasswordDTO employeePasswordDTO) &#123; // 1. 参数校验 if (employeePasswordDTO == null || StringUtils.isBlank(employeePasswordDTO.getOldPassword()) || StringUtils.isBlank(employeePasswordDTO.getNewPassword())) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 验证旧密码是否正确 Employee employee = getById(BaseContext.getCurrentId()); if (! employee.getPassword().equals(DigestUtils.md5DigestAsHex((employeePasswordDTO.getOldPassword() + employee.getSalt()).getBytes())))&#123; // 旧密码错了 throw new PasswordErrorException(MessageConstant.PASSWORD_ERROR); &#125; // 3. 保存新密码 String password = DigestUtils.md5DigestAsHex((employeePasswordDTO.getNewPassword() + employee.getSalt()).getBytes()); update().eq(&quot;id&quot;, employee.getId()).set(&quot;password&quot;, password).update(); // Xuan TODO 修改完密码后是否应该将当前用户登录信息清除，重新登录 // 4. 返回结果 return Result.success();&#125;"},{"title":"管理端-编辑员工信息","path":"/wiki/xiaomo/后台管理端/修改员工信息.html","content":"编辑员工信息 接口地址:/admin/employee 请求方式:PUT 请求数据类型:application/json 响应数据类型:*/* 接口描述: 请求示例: &#123; &quot;id&quot;: 0, &quot;idNumber&quot;: &quot;&quot;, &quot;name&quot;: &quot;&quot;, &quot;phone&quot;: &quot;&quot;, &quot;sex&quot;: &quot;&quot;, &quot;username&quot;: &quot;&quot;&#125; 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema employeeDTO employeeDTO body true 员工注册信息 员工注册信息 id 员工id false integer(int64) idNumber 身份证号 true string name 姓名 true string phone 手机号 true string sex 性别 true string username 用户名 true string 响应状态: 状态码 说明 schema 200 OK Result«string» 201 Created 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &quot;&quot;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @ApiOperation(&quot;编辑员工信息&quot;) @PutMapping() public Result&lt;String&gt; updateEmpInfo(@RequestBody EmployeeDTO employeeDTO)&#123; return employeeService.updateEmpInfo(employeeDTO); &#125; Impl /** * 编辑员工信息 * * @param employeeDTO * @return */@Overridepublic Result&lt;String&gt; updateEmpInfo(EmployeeDTO employeeDTO) &#123; // 1. 数据校验 boolean check = employeeDTO.check(); if (!check)&#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 初始化 Employee employee = new Employee(); BeanUtils.copyProperties(employeeDTO, employee); // 3. 更新数据 updateById(employee); // 4. 返回结果 return Result.success();&#125; 一些问题 在代码编写时我发现这样一段代码是可以复用的，因为我们在检查时总是需要去这样使用。 // 1. 数据校验 if (employeeDTO == null || StringUtils.isBlank(employeeDTO.getName()) || StringUtils.isBlank(employeeDTO.getUsername()) || StringUtils.isBlank(employeeDTO.getSex()) || StringUtils.isBlank(employeeDTO.getPhone()) || StringUtils.isBlank(employeeDTO.getIdNumber())) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; 所以修改为 @Data@ApiModel(value = &quot;员工注册信息&quot;)public class EmployeeDTO implements Serializable &#123; @ApiModelProperty(value = &quot;员工id&quot;) private Long id; @ApiModelProperty(value = &quot;用户名&quot; , required = true) private String username; @ApiModelProperty(value = &quot;姓名&quot; , required = true) private String name; @ApiModelProperty(value = &quot;手机号&quot; , required = true) private String phone; @ApiModelProperty(value = &quot;性别&quot; , required = true) private String sex; @ApiModelProperty(value = &quot;身份证号&quot; , required = true) private String idNumber; public boolean check()&#123; if (this == null || StringUtils.isBlank(this.getName()) || StringUtils.isBlank(this.getUsername()) || StringUtils.isBlank(this.getSex()) || StringUtils.isBlank(this.getPhone()) || StringUtils.isBlank(this.getIdNumber())) &#123; return false; &#125; return true; &#125;&#125; // 1. 数据校验 boolean check = employeeDTO.check(); if (!check)&#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125;"},{"title":"管理端-修改员工账号状态","path":"/wiki/xiaomo/后台管理端/修改员工账号状态.html","content":"修改员工账号状态 接口地址:/admin/employee/status/&#123;status&#125; 请求方式:POST 请求数据类型:application/json 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema id 用户id query true integer(int64) status 账号状态 path true integer(int32) 响应状态: 状态码 说明 schema 200 OK Result 201 Created 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data object msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &#123;&#125;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @ApiOperation(&quot;修改员工账号状态&quot;) @ApiImplicitParams(&#123; @ApiImplicitParam(name = &quot;status&quot;, value = &quot;账号状态&quot;, required = true, dataType = &quot;Integer&quot;), @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户id&quot;, required = true, dataType = &quot;Long&quot;) &#125;) @PostMapping(&quot;/status/&#123;status&#125;&quot;) public Result updateStatus(@PathVariable Integer status, Long id) &#123; return employeeService.updateStatus(status, id); &#125; Impl /** * 修改员工状态 * * @param status * @param id * @return */ @Override public Result updateStatus(Integer status, Long id) &#123; // 1. 数据校验 if (status == null || id == null) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; if (StatusConstant.ENABLE.equals(status) || StatusConstant.DISABLE.equals(status))&#123; // 二者满足其一即可 // 2. 修改员工状态 update().eq(&quot;id&quot;,id).set(&quot;status&quot;, status).update(); // 3. 返回结果 return Result.success(); &#125; throw new BaseException(MessageConstant.STATUS_DATA_ERROR); &#125;"},{"title":"管理端-修改菜品","path":"/wiki/xiaomo/后台管理端/修改菜品-23.html","content":"修改菜品 接口地址:/admin/dish 请求方式:PUT 请求数据类型:application/json 响应数据类型:*/* 接口描述: 请求示例: &#123; &quot;categoryId&quot;: 0, &quot;description&quot;: &quot;&quot;, &quot;flavors&quot;: [ &#123; &quot;dishId&quot;: 0, &quot;id&quot;: 0, &quot;name&quot;: &quot;&quot;, &quot;value&quot;: &quot;&quot; &#125; ], &quot;id&quot;: 0, &quot;image&quot;: &quot;&quot;, &quot;name&quot;: &quot;&quot;, &quot;price&quot;: 0, &quot;status&quot;: 0&#125; 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema dishDTO dishDTO body true 菜品 菜品 categoryId 菜品分类id false integer(int64) description 描述信息 false string flavors 口味 false array 菜品口味 dishId 菜品id false integer id 菜品口味id false integer name 口味名称 false string value 口味数据list false string id 菜品id false integer(int64) image 图片 false string name 菜品名称 false string price 菜品价格 false number status 0 停售 1 起售 false integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«string» 201 Created 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &quot;&quot;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @PutMapping()@ApiOperation(value = &quot;修改菜品&quot;)public Result&lt;String&gt; updateDish(@RequestBody DishDTO dishDTO) &#123; return dishService.updateDish(dishDTO);&#125; Impl /** * 修改菜品 * * @param dishDTO * @return */ @Override @Transactional public Result&lt;String&gt; updateDish(DishDTO dishDTO) &#123; // 1.校验数据 boolean check = dishDTO.check(); if (!check) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 修改菜品 Dish dish = new Dish(); BeanUtils.copyProperties(dishDTO, dish); updateById(dish); // 3. 修改口味 if (dishDTO.getFlavors() != null &amp;&amp; dishDTO.getFlavors().size() &gt; 0) &#123; dishFlavorService.removeByDishId(dish.getId()); dishDTO.getFlavors().forEach(flavor -&gt; flavor.setDishId(dish.getId())); dishFlavorService.saveBatch(dishDTO.getFlavors()); &#125; // 3.1 删除缓存 redisUtil.cleanCaches(RedisKeyConstant.DELETE_DISH); // 4. 返回结果 return Result.success(); &#125;"},{"title":"管理端-分类分页查询","path":"/wiki/xiaomo/后台管理端/分类分页查询-02.html","content":"分类分页查询 接口地址:/admin/category/page 请求方式:GET 请求数据类型:application/x-www-form-urlencoded 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema name 分类名称 query false string page 页码 query false integer(int32) pageSize 每页记录数 query false integer(int32) type 分类类型 1菜品分类 2套餐分类 query false integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«PageResult» 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data PageResult PageResult records array object total integer(int64) msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &#123; &quot;records&quot;: [], &quot;total&quot;: 0\t&#125;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @GetMapping(&quot;/page&quot;)@ApiOperation(&quot;分类分页查询&quot;)public Result&lt;PageResult&gt; page(CategoryPageQueryDTO categoryPageQueryDTO) &#123; log.info(&quot;分页查询：&#123;&#125;&quot;, categoryPageQueryDTO); return categoryService.pageQuery(categoryPageQueryDTO);&#125; Impl /** * 分类分页查询 * * @param categoryPageQueryDTO * @return */@Overridepublic Result&lt;PageResult&gt; pageQuery(CategoryPageQueryDTO categoryPageQueryDTO) &#123; // 1. 校验参数 if (categoryPageQueryDTO == null || categoryPageQueryDTO.getPage() &lt;= 0 || categoryPageQueryDTO.getPageSize() &lt;= 0) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 构建分页查询 Page&lt;Category&gt; categoryPage = new Page&lt;&gt;(categoryPageQueryDTO.getPage(), categoryPageQueryDTO.getPageSize()); LambdaQueryWrapper&lt;Category&gt; categoryLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); if (categoryPageQueryDTO.getType() != null) &#123; categoryLambdaQueryWrapper.eq(Category::getType, categoryPageQueryDTO.getType()); &#125; if (StringUtils.isNotBlank(categoryPageQueryDTO.getName())) &#123; categoryLambdaQueryWrapper.like(Category::getName, categoryPageQueryDTO.getName()); &#125; categoryLambdaQueryWrapper.orderByDesc(Category::getSort); page(categoryPage, categoryLambdaQueryWrapper); // 3. 返回 PageResult pageResult = new PageResult(categoryPage.getTotal(), categoryPage.getRecords()); return Result.success(pageResult);&#125;"},{"title":"管理端-修改菜品状态","path":"/wiki/xiaomo/后台管理端/修改菜品状态-24.html","content":"修改菜品状态 接口地址:/admin/dish/status/&#123;status&#125; 请求方式:POST 请求数据类型:application/json 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema id id body true integer status 菜品状态 path true integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«string» 201 Created 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &quot;&quot;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @PostMapping(&quot;/status/&#123;status&#125;&quot;)@ApiOperation(value = &quot;修改菜品状态&quot;)@ApiImplicitParam( name = &quot;status&quot;, value = &quot;菜品状态&quot;, required = true, dataType = &quot;Integer&quot;, dataTypeClass = Integer.class)public Result&lt;String&gt; updateDishStatus(@RequestBody Long id, @PathVariable Integer status) &#123; return dishService.updateDishStatus(id, status);&#125; Impl /** * 修改菜品状态 * * @param id * @param status * @return */ @Override public Result&lt;String&gt; updateDishStatus(Long id, Integer status) &#123; // 1. 检查参数 if (id == null || status == null) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 修改 if (status.equals(StatusConstant.ENABLE) || status.equals(StatusConstant.DISABLE)) &#123; update().set(&quot;status&quot;, status).eq(&quot;id&quot;, id).update(); // 2.1 删除缓存 redisUtil.cleanCaches(RedisKeyConstant.DELETE_DISH); // 3. 返回 return Result.success(); &#125; return Result.error(MessageConstant.STATUS_DATA_ERROR); &#125;"},{"title":"管理端-启用禁用分类","path":"/wiki/xiaomo/后台管理端/启用、禁用分类-05.html","content":"启用禁用分类 接口地址:/admin/category/status/&#123;status&#125; 请求方式:POST 请求数据类型:application/json 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema id 分类id query true integer(int64) status 分类状态 path true integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«string» 201 Created 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &quot;&quot;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @PostMapping(&quot;/status/&#123;status&#125;&quot;)@ApiOperation(&quot;启用禁用分类&quot;)@ApiImplicitParams(&#123; @ApiImplicitParam( name = &quot;status&quot;, value = &quot;分类状态&quot;, required = true, dataType = &quot;Integer&quot;, dataTypeClass = Integer.class), @ApiImplicitParam( name = &quot;id&quot;, value = &quot;分类id&quot;, required = true, dataType = &quot;Long&quot;, dataTypeClass = Long.class)&#125;)public Result&lt;String&gt; startOrStop(@PathVariable(&quot;status&quot;) Integer status, Long id) &#123; log.info(&quot;启用禁用分类：&#123;&#125;，&#123;&#125;&quot;, status, id); return categoryService.startOrStop(status, id);&#125; Impl /** * 启用或禁用分类 * * @param status * @param id * @return */@Overridepublic Result&lt;String&gt; startOrStop(Integer status, Long id) &#123; // 1. 校验参数 if (status == null || id == null) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 修改 Category category = Category.builder().id(id).status(status).build(); updateById(category); // 2.1 删除缓存 redisUtil.cleanCaches(RedisKeyConstant.DELETE_CATEGORY); // 3. 返回 return Result.success();&#125;"},{"title":"管理端-分页查询菜品","path":"/wiki/xiaomo/后台管理端/分页查询菜品-20.html","content":"分页查询菜品 接口地址:/admin/dish/page 请求方式:GET 请求数据类型:application/x-www-form-urlencoded 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema categoryId 分类id query false integer(int32) name 菜品名称 query false string page 页码 query false integer(int32) pageSize 每页记录数 query false integer(int32) status 状态 0表示禁用 1表示启用 query false integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«PageResult» 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data PageResult PageResult records array object total integer(int64) msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &#123; &quot;records&quot;: [], &quot;total&quot;: 0\t&#125;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @GetMapping(&quot;/page&quot;)@ApiOperation(value = &quot;分页查询菜品&quot;)public Result&lt;PageResult&gt; pageQuery(DishPageQueryDTO dishPageQueryDTO) &#123; return dishService.pageQuery(dishPageQueryDTO);&#125; Impl /** * 分页查询菜品 * * @param dishPageQueryDTO * @return */ @Override @Transactional public Result&lt;PageResult&gt; pageQuery(DishPageQueryDTO dishPageQueryDTO) &#123; // 1. 校验参数 if (dishPageQueryDTO == null || dishPageQueryDTO.getPage() &lt;= 0 || dishPageQueryDTO.getPageSize() &lt;= 0) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 查询条件 Page&lt;Dish&gt; dishPage = new Page&lt;&gt;(dishPageQueryDTO.getPage(), dishPageQueryDTO.getPageSize()); LambdaQueryWrapper&lt;Dish&gt; dishLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); if (dishPageQueryDTO.getCategoryId() != null) &#123; dishLambdaQueryWrapper.eq(Dish::getCategoryId, dishPageQueryDTO.getCategoryId()); &#125; if (dishPageQueryDTO.getName() != null) &#123; dishLambdaQueryWrapper.like(Dish::getName, dishPageQueryDTO.getName()); &#125; if (dishPageQueryDTO.getStatus() != null &amp;&amp; (StatusConstant.ENABLE.equals(dishPageQueryDTO.getStatus()) || StatusConstant.DISABLE.equals(dishPageQueryDTO.getStatus()))) &#123; dishLambdaQueryWrapper.eq(Dish::getStatus, dishPageQueryDTO.getStatus()); &#125; dishLambdaQueryWrapper.orderByDesc(Dish::getUpdateTime); // 3. 查询 page(dishPage, dishLambdaQueryWrapper); // 4. 补全信息 List&lt;DishVO&gt; collect = dishPage.getRecords().stream() .map( dish -&gt; &#123; DishVO dishVO = new DishVO(); BeanUtils.copyProperties(dish, dishVO); dishVO.setCategoryName(categoryMapper.selectById(dish.getCategoryId()).getName()); return dishVO; &#125;) .collect(Collectors.toList()); // 5. 返回 PageResult pageResult = new PageResult(dishPage.getTotal(), collect); return Result.success(pageResult); &#125;"},{"title":"管理端-删除分类","path":"/wiki/xiaomo/后台管理端/删除分类-03.html","content":"删除分类 接口地址:/admin/category 请求方式:DELETE 请求数据类型:application/x-www-form-urlencoded 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema id 分类id query true integer(int64) 响应状态: 状态码 说明 schema 200 OK Result«string» 204 No Content 401 Unauthorized 403 Forbidden 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &quot;&quot;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @DeleteMapping@ApiOperation(&quot;删除分类&quot;)@ApiImplicitParam( name = &quot;id&quot;, value = &quot;分类id&quot;, required = true, dataType = &quot;Long&quot;, dataTypeClass = Long.class)public Result&lt;String&gt; deleteById(Long id) &#123; log.info(&quot;删除分类：&#123;&#125;&quot;, id); return categoryService.deleteById(id);&#125; Impl /** * 删除分类 * * @param id * @return */@Override@Transactionalpublic Result&lt;String&gt; deleteById(Long id) &#123; // 1. 校验参数 if (id == null) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 判断是否存在绑定关系 // 2.1 口味 LambdaQueryWrapper&lt;Dish&gt; dishLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); dishLambdaQueryWrapper.eq(Dish::getCategoryId, id); int countDish = dishService.count(dishLambdaQueryWrapper); if (countDish &gt; 0) &#123; throw new BaseException(MessageConstant.BIND_ALREADY); &#125; // 2.2 套餐 LambdaQueryWrapper&lt;Setmeal&gt; setmealLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId, id); int countSetmeal = setmealService.count(setmealLambdaQueryWrapper); if (countSetmeal &gt; 0) &#123; throw new BaseException(MessageConstant.BIND_ALREADY); &#125; // 3. 删除 removeById(id); // 3.1 删除缓存 redisUtil.cleanCaches(RedisKeyConstant.DELETE_CATEGORY); // 4. 返回 return Result.success();&#125;"},{"title":"管理端-员工信息分页","path":"/wiki/xiaomo/后台管理端/员工信息分页.html","content":"员工信息分页查询 接口地址:/admin/employee/page 请求方式:GET 请求数据类型:application/x-www-form-urlencoded 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema name query false string page query false integer(int32) pageSize query false integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«PageResult» 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data PageResult PageResult records array object total integer(int64) msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &#123; &quot;records&quot;: [], &quot;total&quot;: 0\t&#125;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @ApiOperation(&quot;员工信息分页查询&quot;) @GetMapping(&quot;/page&quot;) public Result&lt;PageResult&gt; pageQuery(EmployeePageQueryDTO pageQueryDTO)&#123; return employeeService.pageQuery(pageQueryDTO); &#125; Impl /** * 员工信息分页查询 * * @param pageQueryDTO * @return Result&lt;PageResult&gt; */ @Override public Result&lt;PageResult&gt; pageQuery(EmployeePageQueryDTO pageQueryDTO) &#123; // 1. 数据校验 if (pageQueryDTO == null || pageQueryDTO.getPage() &lt;= 0 || pageQueryDTO.getPageSize() &lt;= 0)&#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 构建分页查询 Page&lt;Employee&gt; employeePage = new Page&lt;&gt;(pageQueryDTO.getPage(), pageQueryDTO.getPageSize()); LambdaQueryWrapper&lt;Employee&gt; employeeLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); if (StringUtils.isNotBlank(pageQueryDTO.getName()))&#123; employeeLambdaQueryWrapper.eq(Employee::getName, pageQueryDTO.getName()); &#125; employeeLambdaQueryWrapper.orderByDesc(Employee::getUpdateTime); page(employeePage, employeeLambdaQueryWrapper); // 3. 构建返回参数 List&lt;Employee&gt; records = employeePage.getRecords(); long total = employeePage.getTotal(); PageResult pageResult = new PageResult(); pageResult.setTotal(total); pageResult.setRecords(records); // 4. 返回数据 return Result.success(pageResult); &#125; 这里使用的是mp进行分页，配置分页拦截器。 /** * mybatisPlus分页拦截器 * @return */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor()&#123; MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor(); mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor()); return mybatisPlusInterceptor; &#125; 一些问题 image-20230906120644943 通过后端传输过来的数据我们可以看到这里的时间显示格式并不是我们期望的形式。这里有两种解决方法 在对应属性上添加@JsonFormat(pattern = “yyyy-MM-dd HH:mm:ss”)的形式 在WebMvcConfiguration中添加SpringMvc的消息转换器，对日期格式进行统一处理 (推荐) 方法二 @Override protected void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; log.info(&quot;设置消息转换器&quot;); // 创建一个消息转换器对象 MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter = new MappingJackson2HttpMessageConverter(); // 设置转换器 mappingJackson2HttpMessageConverter.setObjectMapper(new JacksonObjectMapper()); // 将转换器添加进容器中 converters.add(0, mappingJackson2HttpMessageConverter); &#125; 关于JacksonObjectMapper，主要是对LocalDate，LocalDateTime，LocalTime等类型进行序列化 /** * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象] * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON] */public class JacksonObjectMapper extends ObjectMapper &#123; public static final String DEFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;; //public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;; public static final String DEFAULT_DATE_TIME_FORMAT = &quot;yyyy-MM-dd HH:mm&quot;; public static final String DEFAULT_TIME_FORMAT = &quot;HH:mm:ss&quot;; public JacksonObjectMapper() &#123; super(); //收到未知属性时不报异常 this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false); //反序列化时，属性不存在的兼容处理 this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); SimpleModule simpleModule = new SimpleModule() .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))) .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT))) .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT))) .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))) .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT))) .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT))); //注册功能模块 例如，可以添加自定义序列化器和反序列化器 this.registerModule(simpleModule); &#125;&#125; image-20230906120823015"},{"title":"管理端-新增分类","path":"/wiki/xiaomo/后台管理端/新增分类-01.html","content":"新增分类 接口地址:/admin/category 请求方式:POST 请求数据类型:application/json 响应数据类型:*/* 接口描述: 请求示例: &#123; &quot;id&quot;: 0, &quot;name&quot;: &quot;&quot;, &quot;sort&quot;: 0, &quot;type&quot;: 0&#125; 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema categoryDTO categoryDTO body true 分类DTO 分类DTO id 主键 false integer(int64) name 分类名称 false string sort 排序 false integer(int32) type 类型 1 菜品分类 2 套餐分类 false integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«string» 201 Created 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &quot;&quot;,\t&quot;msg&quot;: &quot;&quot;&#125; controller /** * 新增分类 * @param categoryDTO * @return */ @PostMapping @ApiOperation(&quot;新增分类&quot;) public Result&lt;String&gt; save(@RequestBody CategoryDTO categoryDTO)&#123; log.info(&quot;新增分类：&#123;&#125;&quot;, categoryDTO); return categoryService.save(categoryDTO); &#125; Impl /** * 新增分类 * * @param categoryDTO * @return */@Overridepublic Result&lt;String&gt; save(CategoryDTO categoryDTO) &#123; // 1. 校验参数 if (!categoryDTO.check()) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 初始化参数 Category category = new Category(); BeanUtils.copyProperties(categoryDTO, category); category.setStatus(StatusConstant.ENABLE); // 3. 保存 save(category); // 3.1 删除缓存 redisUtil.cleanCaches(RedisKeyConstant.DELETE_CATEGORY); // 4. 返回 return Result.success();&#125;"},{"title":"管理端-新增员工","path":"/wiki/xiaomo/后台管理端/新增员工.html","content":"接口 接口路径： POST/admin/employee 请求参数 Headers： 参数名称 参数值 是否必须 示例 备注 Content-Type application/json 是 Body: 名称 类型 是否必须 默认值 备注 其他信息 id integer 非必须 员工id format: int64 idNumber string 必须 身份证 name string 必须 姓名 phone string 必须 手机号 sex string 必须 性别 username string 必须 用户名 返回数据 名称 类型 是否必须 默认值 备注 其他信息 code integer 必须 format: int32 data object 非必须 msg string 非必须 controller @ApiOperation(value = &quot;新增员工&quot;)@PostMapping()public Result&lt;String&gt; addEmp(@RequestBody EmployeeDTO employeeDTO)&#123; return employeeService.addEmp(employeeDTO);&#125; Impl 修改前/** * 新增员工 * * @param employeeDTO * @return Result&lt;String&gt; */ @Override public Result&lt;String&gt; addEmp(EmployeeDTO employeeDTO) &#123; // 1. 数据校验 if (employeeDTO == null || StringUtils.isBlank(employeeDTO.getName()) || StringUtils.isBlank(employeeDTO.getUsername()) || StringUtils.isBlank(employeeDTO.getSex()) || StringUtils.isBlank(employeeDTO.getPhone()) || StringUtils.isBlank(employeeDTO.getIdNumber())) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 初始化员工数据 Employee employee = new Employee(); BeanUtils.copyProperties(employeeDTO, employee); employee.setStatus(StatusConstant.ENABLE); employee.setSalt(RandomStringGenerator.generateRandomString(4)); employee.setPassword( DigestUtils.md5DigestAsHex( (PasswordConstant.DEFAULT_PASSWORD + employee.getSalt()).getBytes())); employee.setCreateTime(LocalDate.now()); employee.setUpdateTime(LocalDate.now()); employee.setCreateUser(BaseContext.getCurrentId()); employee.setUpdateUser(BaseContext.getCurrentId()); // 3.新增 INSERT INTO employee ( name, username, password, phone, sex, id_number, status, // create_time, update_time, create_user, update_user, salt ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, // ?, ?, ?, ? ) save(employee); return Result.success(); &#125; /** * 新增员工 * * @param employeeDTO * @return Result&lt;String&gt; */ @Override public Result&lt;String&gt; addEmp(EmployeeDTO employeeDTO) &#123; // 1. 数据校验 if (employeeDTO == null || StringUtils.isBlank(employeeDTO.getName()) || StringUtils.isBlank(employeeDTO.getUsername()) || StringUtils.isBlank(employeeDTO.getSex()) || StringUtils.isBlank(employeeDTO.getPhone()) || StringUtils.isBlank(employeeDTO.getIdNumber())) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 1.1 手机号正则验证 boolean validate = MobileNumberValidator.validate(employeeDTO.getPhone()); if (!validate)&#123; throw new BaseException(&quot;手机号不正确&quot;); &#125; // 1.2 用户名长度验证 if (employeeDTO.getUsername().length() &lt; 3 || employeeDTO.getUsername().length() &gt; 20)&#123; throw new BaseException(&quot;用户名长度不正确&quot;); &#125; // 2. 初始化员工数据 Employee employee = new Employee(); BeanUtils.copyProperties(employeeDTO, employee); employee.setStatus(StatusConstant.ENABLE); employee.setSalt(RandomStringGenerator.generateRandomString(4)); employee.setPassword( DigestUtils.md5DigestAsHex( (PasswordConstant.DEFAULT_PASSWORD + employee.getSalt()).getBytes())); employee.setCreateTime(LocalDate.now()); employee.setUpdateTime(LocalDate.now()); employee.setCreateUser(BaseContext.getCurrentId()); employee.setUpdateUser(BaseContext.getCurrentId()); // 3.新增 INSERT INTO employee ( name, username, password, phone, sex, id_number, status, // create_time, update_time, create_user, update_user, salt ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, // ?, ?, ?, ? ) save(employee); return Result.success(); &#125; 一些问题 由于username是作为unique唯一索引的，所以在添加的时候可能会出现重复的username导致数据库报错添加失败的问题。 设置全局异常处理器GlobalExceptionHandler对异常进行捕获处理 /** * 全局异常处理器，处理项目中抛出的业务异常 */@RestControllerAdvice@Slf4jpublic class GlobalExceptionHandler &#123; /** * 捕获业务异常 * @param ex * @return */ @ExceptionHandler public Result exceptionHandler(BaseException ex)&#123; log.error(&quot;异常信息：&#123;&#125;&quot;, ex.getMessage()); return Result.error(ex.getMessage()); &#125; /** * sql异常捕获 * @param ex * @return */ @ExceptionHandler public Result exceptionHandler(SQLIntegrityConstraintViolationException ex)&#123; String exMessage = ex.getMessage(); if (exMessage.contains(&quot;Duplicate entry&quot;))&#123; // 重复字段 String[] split = exMessage.split(&quot; &quot;); String msg = split[2] + MessageConstant.ALREADY_EXISTS; return Result.error(msg); &#125;else &#123; return Result.error(MessageConstant.UNKNOWN_ERROR); &#125; &#125;&#125; 这样在我们重复添加的时候前端就能接收到对应的错误信息 image-20230906154533870 在进行前后端联调测试时发现一个bug image-20230906150017125 后台查询回显的数据在前端无法正常保存？ 实际原因是这一条数据是我根据knife4j生成的文档填写数据直接进行添加的，跳过了前端的验证，但是在后台的新增员工又仅是判断了数据不为空，所以导致发生这种情况，所以我决定需要对新增员工模块的代码进行完善。 测试用例 &#123; &quot;idNumber&quot;: &quot;111222333444555&quot;, &quot;name&quot;: &quot;lisi&quot;, &quot;phone&quot;: &quot;12333330987&quot;, &quot;sex&quot;: &quot;男&quot;, &quot;username&quot;: &quot;李四&quot;&#125; 结果 &#123; &quot;code&quot;: 0, &quot;msg&quot;: &quot;手机号不正确&quot;, &quot;data&quot;: null&#125;"},{"title":"管理端-根据Id查询菜品","path":"/wiki/xiaomo/后台管理端/根据id查询菜品-22.html","content":"根据id查询菜品 接口地址:/admin/dish/&#123;id&#125; 请求方式:GET 请求数据类型:application/x-www-form-urlencoded 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema id id path true integer(int64) 响应状态: 状态码 说明 schema 200 OK Result«菜品» 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data 菜品 菜品 categoryId 菜品分类id integer(int64) description 描述信息 string flavors 口味 array 菜品口味 dishId 菜品id integer id 菜品口味id integer name 口味名称 string value 口味数据list string id 菜品id integer(int64) image 图片 string name 菜品名称 string price 菜品价格 number status 0 停售 1 起售 integer(int32) msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &#123; &quot;categoryId&quot;: 0, &quot;description&quot;: &quot;&quot;, &quot;flavors&quot;: [ &#123; &quot;dishId&quot;: 0, &quot;id&quot;: 0, &quot;name&quot;: &quot;&quot;, &quot;value&quot;: &quot;&quot; &#125; ], &quot;id&quot;: 0, &quot;image&quot;: &quot;&quot;, &quot;name&quot;: &quot;&quot;, &quot;price&quot;: 0, &quot;status&quot;: 0\t&#125;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @GetMapping(&quot;/&#123;id&#125;&quot;)@ApiOperation(value = &quot;根据id查询菜品&quot;)@ApiImplicitParam( name = &quot;id&quot;, value = &quot;菜品id&quot;, required = true, dataType = &quot;Long&quot;, dataTypeClass = Long.class)public Result&lt;DishDTO&gt; getDishById(@PathVariable Long id) &#123; return dishService.getDishById(id);&#125; Impl /** * 根据id查询菜品 * * @param id * @return */ @Override @Transactional public Result&lt;DishDTO&gt; getDishById(Long id) &#123; // 1. 检查参数 if (id == null) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 根据id查询dish信息 Dish dish = getById(id); // 3. 根据id查询口味信息 List&lt;DishFlavor&gt; dishFlavors = dishFlavorService.getByDishId(id); // 4. 补全信息 DishDTO dishDTO = new DishDTO(); BeanUtils.copyProperties(dish, dishDTO); dishDTO.setFlavors(dishFlavors); // 5. 返回 return Result.success(dishDTO); &#125;"},{"title":"管理端-根据Ids删除菜品一个或者多个菜品","path":"/wiki/xiaomo/后台管理端/根据ids删除菜品一个或者多个菜品-25.html","content":"根据ids删除菜品一个或者多个菜品 接口地址:/admin/dish 请求方式:DELETE 请求数据类型:application/x-www-form-urlencoded 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema ids 菜品id数组 query true integer(int64) 响应状态: 状态码 说明 schema 200 OK Result«string» 204 No Content 401 Unauthorized 403 Forbidden 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &quot;&quot;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @DeleteMapping()@ApiOperation(value = &quot;根据ids删除菜品一个或者多个菜品&quot;)@ApiImplicitParam( name = &quot;ids&quot;, value = &quot;菜品id数组&quot;, required = true, dataType = &quot;Long&quot;, dataTypeClass = Long.class)public Result&lt;String&gt; deleteDishByIds(@RequestParam Long[] ids) &#123; return dishService.deleteDishByIds(ids);&#125; Impl /** * 根据ids删除菜品一个或者多个菜品 * * @param ids * @return */ @Override public Result&lt;String&gt; deleteDishByIds(Long[] ids) &#123; // 1. 检查参数 if (ids == null || ids.length == 0) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 状态为启用时不能删除 for (Long id : ids) &#123; Dish dish = getById(id); if (!dish.getStatus().equals(StatusConstant.ENABLE)) &#123; throw new StatusIsUpExecption(MessageConstant.STATUS_IS_UP); &#125; // 3. 被套餐关联的菜品不能删除 int count = setmealDishService.count( Wrappers.&lt;SetmealDish&gt;lambdaQuery().eq(SetmealDish::getDishId, id)); if (count &gt; 0) &#123; throw new BaseException(MessageConstant.BIND_ALREADY); &#125; // 3. 删除口味 dishFlavorService.removeByDishId(id); &#125; // 4. 删除菜品 List&lt;Long&gt; collect = Arrays.stream(ids).collect(Collectors.toList()); removeByIds(collect); // 4.1 删除缓存 redisUtil.cleanCaches(RedisKeyConstant.DELETE_DISH); // 5. 返回 return Result.success(); &#125;"},{"title":"管理端-根据分类Id查询菜品","path":"/wiki/xiaomo/后台管理端/根据分类id查询菜品-26.html","content":"根据分类id查询菜品 接口地址:/admin/dish/list 请求方式:GET 请求数据类型:application/x-www-form-urlencoded 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema categoryId 菜品分类id query true integer(int64) 响应状态: 状态码 说明 schema 200 OK Result«List«Dish»» 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data array Dish categoryId integer(int64) createTime string(date-time) createUser integer(int64) description string id integer(int64) image string name string price number status integer(int32) updateTime string(date-time) updateUser integer(int64) msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: [ &#123; &quot;categoryId&quot;: 0, &quot;createTime&quot;: &quot;&quot;, &quot;createUser&quot;: 0, &quot;description&quot;: &quot;&quot;, &quot;id&quot;: 0, &quot;image&quot;: &quot;&quot;, &quot;name&quot;: &quot;&quot;, &quot;price&quot;: 0, &quot;status&quot;: 0, &quot;updateTime&quot;: &quot;&quot;, &quot;updateUser&quot;: 0 &#125;\t],\t&quot;msg&quot;: &quot;&quot;&#125; controller @GetMapping(&quot;/list&quot;)@ApiOperation(value = &quot;根据分类id查询菜品&quot;)@ApiImplicitParam( name = &quot;categoryId&quot;, value = &quot;菜品分类id&quot;, required = true, dataType = &quot;Long&quot;, dataTypeClass = Long.class)public Result&lt;List&lt;Dish&gt;&gt; listByCategoryId(@RequestParam Long categoryId) &#123; return dishService.listByCategoryId(categoryId);&#125; Impl /** * 根据分类id查询菜品 * * @param categoryId * @return */ @Override public Result&lt;List&lt;Dish&gt;&gt; listByCategoryId(Long categoryId) &#123; // 1. 检查参数 if (categoryId == null) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 查询 List&lt;Dish&gt; dishList = list( Wrappers.&lt;Dish&gt;lambdaQuery() .eq(Dish::getCategoryId, categoryId) .eq(Dish::getStatus, StatusConstant.ENABLE)); // 3. 返回 return Result.success(dishList); &#125;"},{"title":"管理端-根据员工Id查询","path":"/wiki/xiaomo/后台管理端/根据员工id查询.html","content":"根据id获取员工信息 接口地址:/admin/employee/&#123;id&#125; 请求方式:GET 请求数据类型:application/x-www-form-urlencoded 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema id 员工id path true integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«员工信息传递» 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data 员工信息传递 员工信息传递 id 员工id integer(int64) idNumber 身份证号 string name 员工姓名 string password 密码 string phone 手机号 string sex 性别 string username 用户名 string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &#123; &quot;id&quot;: 0, &quot;idNumber&quot;: &quot;&quot;, &quot;name&quot;: &quot;&quot;, &quot;password&quot;: &quot;&quot;, &quot;phone&quot;: &quot;&quot;, &quot;sex&quot;: &quot;&quot;, &quot;username&quot;: &quot;&quot;\t&#125;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @ApiOperation(&quot;根据id获取员工信息&quot;) @ApiImplicitParam(name = &quot;id&quot;, value = &quot;员工id&quot;, required = true, dataType = &quot;Integer&quot;) @GetMapping(&quot;/&#123;id&#125;&quot;) public Result&lt;EmployeeInfoVO&gt; getEmpById(@PathVariable Integer id) &#123; return employeeService.getEmpById(id); &#125; Impl /** * 根据id获取员工信息 * * @param id * @return */ @Override public Result&lt;EmployeeInfoVO&gt; getEmpById(Integer id) &#123; // 1. 数据校验 if (id == null)&#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 查询数据 Employee employee = getById(id); if (employee == null)&#123; throw new AccountNotFoundException(MessageConstant.ACCOUNT_NOT_FOUND); &#125; // 3. 拷贝返回数值 EmployeeInfoVO employeeInfoVO = new EmployeeInfoVO(); BeanUtils.copyProperties(employee, employeeInfoVO); // 4. 返回数据 return Result.success(employeeInfoVO); &#125; 一些问题 在进行前后端联调测试时发现一个bug image-20230906150017125 后台查询回显的数据在前端无法正常保存？ 实际原因是这一条数据是我根据knife4j生成的文档填写数据直接进行添加的，跳过了前端的验证，但是在后台的新增员工又仅是判断了数据不为空，所以导致发生这种情况，所以我决定需要对新增员工模块的代码进行完善。"},{"title":"管理端-根据类型查询分类","path":"/wiki/xiaomo/后台管理端/根据类型查询分类-06.html","content":"根据类型查询分类 接口地址:/admin/category/list 请求方式:GET 请求数据类型:application/x-www-form-urlencoded 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema type 分类类型 query true integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«List«Category»» 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data array Category createTime string(date-time) createUser integer(int64) id integer(int64) name string sort integer(int32) status integer(int32) type integer(int32) updateTime string(date-time) updateUser integer(int64) msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: [ &#123; &quot;createTime&quot;: &quot;&quot;, &quot;createUser&quot;: 0, &quot;id&quot;: 0, &quot;name&quot;: &quot;&quot;, &quot;sort&quot;: 0, &quot;status&quot;: 0, &quot;type&quot;: 0, &quot;updateTime&quot;: &quot;&quot;, &quot;updateUser&quot;: 0 &#125;\t],\t&quot;msg&quot;: &quot;&quot;&#125; controller @GetMapping(&quot;/list&quot;)@ApiOperation(&quot;根据类型查询分类&quot;)@ApiImplicitParam( name = &quot;type&quot;, value = &quot;分类类型&quot;, required = true, dataType = &quot;Integer&quot;, dataTypeClass = Integer.class)public Result&lt;List&lt;Category&gt;&gt; list(@RequestParam(value = &quot;type&quot;, required = false) Integer type) &#123; log.info(&quot;根据类型查询分类：&#123;&#125;&quot;, type); return categoryService.list(type);&#125; Impl /** * 管理端/用户端 查询所有分类 * * @param type * @return */ @Override public Result&lt;List&lt;Category&gt;&gt; list(Integer type) &#123; // 1. 参数校验 if (type == null) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 查询 // 2.1 查询是否存在缓存 String key = RedisKeyConstant.CACHE_CATEGORY_BY_TYPE + type; List&lt;Category&gt; list = redisUtil.getList(key, Category.class); if (list != null) &#123; return Result.success(list); &#125; list = list( Wrappers.&lt;Category&gt;lambdaQuery() .eq(Category::getStatus, StatusConstant.ENABLE) .eq(type != null, Category::getType, type) .orderByDesc(Category::getSort)); // 2.2 回存缓存 redisUtil.set(key, list); // 3. 返回 return Result.success(list); &#125;"},{"title":"用户端-根据分类Id查询套餐","path":"/wiki/xiaomo/后台管理端/用户端-根据分类id查询套餐-36.html","content":"根据分类id查询套餐 接口地址:/user/setmeal/list 请求方式:GET 请求数据类型:application/x-www-form-urlencoded 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema categoryId categoryId query false integer(int64) 响应状态: 状态码 说明 schema 200 OK Result«List«Setmeal»» 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data array Setmeal categoryId integer(int64) createTime string(date-time) createUser integer(int64) description string id integer(int64) image string name string price number status integer(int32) updateTime string(date-time) updateUser integer(int64) msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: [ &#123; &quot;categoryId&quot;: 0, &quot;createTime&quot;: &quot;&quot;, &quot;createUser&quot;: 0, &quot;description&quot;: &quot;&quot;, &quot;id&quot;: 0, &quot;image&quot;: &quot;&quot;, &quot;name&quot;: &quot;&quot;, &quot;price&quot;: 0, &quot;status&quot;: 0, &quot;updateTime&quot;: &quot;&quot;, &quot;updateUser&quot;: 0 &#125;\t],\t&quot;msg&quot;: &quot;&quot;&#125; controller @GetMapping(&quot;/list&quot;)@ApiOperation(&quot;根据分类id查询套餐&quot;)public Result&lt;List&lt;Setmeal&gt;&gt; list(Long categoryId) &#123; return setmealService.listByCategoryId(categoryId);&#125; Impl /** * 用户端根据分类id查询套餐 * * @param categoryId * @return */@Overridepublic Result&lt;List&lt;Setmeal&gt;&gt; listByCategoryId(Long categoryId) &#123; // 1. 检查参数 if (categoryId == null) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 执行查询 // 2.1 查询缓存中是否包含需要的数据 String key = RedisKeyConstant.CACHE_SETMEAL_BY_CATEGORYID + categoryId; List&lt;Setmeal&gt; setmealList = redisUtil.getList(key, Setmeal.class); if (setmealList != null &amp;&amp; setmealList.size() &gt; 0) &#123; return Result.success(setmealList); &#125; setmealList = list( Wrappers.&lt;Setmeal&gt;lambdaQuery() .eq(Setmeal::getCategoryId, categoryId) .eq(Setmeal::getStatus, StatusConstant.ENABLE)); // 2.2 回存缓存 redisUtil.set(key, setmealList); // 3. 返回结果 return Result.success(setmealList);&#125;"},{"title":"管理端-添加菜品","path":"/wiki/xiaomo/后台管理端/添加菜品-21.html","content":"添加菜品 接口地址:/admin/dish 请求方式:POST 请求数据类型:application/json 响应数据类型:*/* 接口描述: 请求示例: &#123; &quot;categoryId&quot;: 0, &quot;description&quot;: &quot;&quot;, &quot;flavors&quot;: [ &#123; &quot;dishId&quot;: 0, &quot;id&quot;: 0, &quot;name&quot;: &quot;&quot;, &quot;value&quot;: &quot;&quot; &#125; ], &quot;id&quot;: 0, &quot;image&quot;: &quot;&quot;, &quot;name&quot;: &quot;&quot;, &quot;price&quot;: 0, &quot;status&quot;: 0&#125; 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema dishDTO dishDTO body true 菜品 菜品 categoryId 菜品分类id false integer(int64) description 描述信息 false string flavors 口味 false array 菜品口味 dishId 菜品id false integer id 菜品口味id false integer name 口味名称 false string value 口味数据list false string id 菜品id false integer(int64) image 图片 false string name 菜品名称 false string price 菜品价格 false number status 0 停售 1 起售 false integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«string» 201 Created 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &quot;&quot;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @PostMapping()@ApiOperation(value = &quot;添加菜品&quot;)public Result&lt;String&gt; addDish(@RequestBody DishDTO dishDTO) &#123; return dishService.addDish(dishDTO);&#125; Impl @Override@Transactionalpublic Result&lt;String&gt; addDish(DishDTO dishDTO) &#123; // 1.校验数据 boolean check = dishDTO.check(); if (!check) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 添加菜品 Dish dish = new Dish(); BeanUtils.copyProperties(dishDTO, dish); dish.setStatus(StatusConstant.ENABLE); save(dish); // 3. 保存菜品口味 List&lt;DishFlavor&gt; flavors = dishDTO.getFlavors(); if (flavors != null &amp;&amp; flavors.size() &gt; 0) &#123; flavors.forEach( flavor -&gt; &#123; flavor.setDishId(dish.getId()); &#125;); &#125; dishFlavorService.saveBatch(flavors); // 3.1 删除缓存 redisUtil.cleanCaches(RedisKeyConstant.DELETE_DISH); // 4. 返回结果 return Result.success();&#125;"},{"title":"用户端-根据类型查询分类","path":"/wiki/xiaomo/后台管理端/用户端-根据类型查询分类-07.html","content":"查询分类 接口地址:/user/category/list 请求方式:GET 请求数据类型:application/x-www-form-urlencoded 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema type 分类类型：1-菜品分类，2-套餐分类 query true integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«List«Category»» 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data array Category createTime string(date-time) createUser integer(int64) id integer(int64) name string sort integer(int32) status integer(int32) type integer(int32) updateTime string(date-time) updateUser integer(int64) msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: [ &#123; &quot;createTime&quot;: &quot;&quot;, &quot;createUser&quot;: 0, &quot;id&quot;: 0, &quot;name&quot;: &quot;&quot;, &quot;sort&quot;: 0, &quot;status&quot;: 0, &quot;type&quot;: 0, &quot;updateTime&quot;: &quot;&quot;, &quot;updateUser&quot;: 0 &#125;\t],\t&quot;msg&quot;: &quot;&quot;&#125; controller @GetMapping(&quot;/list&quot;)@ApiOperation(&quot;查询分类&quot;)@ApiImplicitParam(name = &quot;type&quot;, value = &quot;分类类型：1-菜品分类，2-套餐分类&quot;, required = true)public Result&lt;List&lt;Category&gt;&gt; list(Integer type) &#123; return categoryService.list(type);&#125; Impl /** * 用户端查询所有分类 * * @param type * @return */@Overridepublic Result&lt;List&lt;Category&gt;&gt; list(Integer type) &#123; // 1. 参数校验 if (type == null) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 查询 // 2.1 查询是否存在缓存 String key = RedisKeyConstant.CACHE_CATEGORY_BY_TYPE + type; List&lt;Category&gt; list = redisUtil.getList(key, Category.class); if (list != null) &#123; return Result.success(list); &#125; list = list( Wrappers.&lt;Category&gt;lambdaQuery() .eq(Category::getStatus, StatusConstant.ENABLE) .eq(type != null, Category::getType, type) .orderByDesc(Category::getSort)); // 2.2 回存缓存 redisUtil.set(key, list); // 3. 返回 return Result.success(list);&#125;"},{"title":"用户端-根据分类Id查询菜品、分类名及菜品口味","path":"/wiki/xiaomo/后台管理端/用户端-根据分类id查询菜品及分类名及菜品口味.html","content":"根据分类id查询菜品 接口地址:/user/dish/list 请求方式:GET 请求数据类型:application/x-www-form-urlencoded 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema categoryId 分类id query true integer(int64) 响应状态: 状态码 说明 schema 200 OK Result«List«DishVO»» 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data array DishVO categoryId integer(int64) categoryName string description string flavors array 菜品口味 dishId 菜品id integer id 菜品口味id integer name 口味名称 string value 口味数据list string id integer(int64) image string name string price number status integer(int32) updateTime string(date-time) msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: [ &#123; &quot;categoryId&quot;: 0, &quot;categoryName&quot;: &quot;&quot;, &quot;description&quot;: &quot;&quot;, &quot;flavors&quot;: [ &#123; &quot;dishId&quot;: 0, &quot;id&quot;: 0, &quot;name&quot;: &quot;&quot;, &quot;value&quot;: &quot;&quot; &#125; ], &quot;id&quot;: 0, &quot;image&quot;: &quot;&quot;, &quot;name&quot;: &quot;&quot;, &quot;price&quot;: 0, &quot;status&quot;: 0, &quot;updateTime&quot;: &quot;&quot; &#125;\t],\t&quot;msg&quot;: &quot;&quot;&#125; controller @GetMapping(&quot;/list&quot;)@ApiOperation(&quot;根据分类id查询菜品、分类名及菜品口味&quot;)@ApiImplicitParam(name = &quot;categoryId&quot;, value = &quot;分类id&quot;, required = true)public Result&lt;List&lt;DishVO&gt;&gt; list(Long categoryId) &#123; return dishService.listWithFlavorByCategoryId(categoryId);&#125; Impl /** * 用户端根据分类id查询菜品和口味 * * @param categoryId * @return */@Override@Transactionalpublic Result&lt;List&lt;DishVO&gt;&gt; listWithFlavorByCategoryId(Long categoryId) &#123; // 1. 校验参数 if (categoryId == null) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 查询菜品 // 2.1 查询缓存中是否包含相应数据 String key = RedisKeyConstant.CACHE_DISH_FLAVOR_BY_CATEGORYID + categoryId; List&lt;DishVO&gt; dishVOS = redisUtil.getList(key, DishVO.class); if (dishVOS != null &amp;&amp; dishVOS.size() &gt; 0) &#123; return Result.success(dishVOS); &#125; dishVOS = dishMapper.selectDishWithCategoryNameByCategoryId(categoryId); // 3. 补全信息 dishVOS.forEach( dishVO -&gt; &#123; dishVO.setFlavors(dishFlavorService.getByDishId(dishVO.getId())); &#125;); // 4. 返回 return Result.success(dishVOS);&#125;"},{"title":"用户端-根据套餐Id查询包含的菜品列表","path":"/wiki/xiaomo/后台管理端/用户端-根据套餐id查询包含的菜品-37.html","content":"根据套餐id查询包含的菜品列表 接口地址:/user/setmeal/dish/&#123;id&#125; 请求方式:GET 请求数据类型:application/x-www-form-urlencoded 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema id id path true integer(int64) 响应状态: 状态码 说明 schema 200 OK Result«List«DishItemVO»» 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data array DishItemVO copies integer(int32) description string image string name string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: [ &#123; &quot;copies&quot;: 0, &quot;description&quot;: &quot;&quot;, &quot;image&quot;: &quot;&quot;, &quot;name&quot;: &quot;&quot; &#125;\t],\t&quot;msg&quot;: &quot;&quot;&#125; controller @GetMapping(&quot;/dish/&#123;id&#125;&quot;)@ApiOperation(&quot;根据套餐id查询包含的菜品列表&quot;)@ApiImplicitParam( name = &quot;id&quot;, value = &quot;套餐id&quot;, required = true, dataType = &quot;Long&quot;, dataTypeClass = Long.class)public Result&lt;List&lt;DishItemVO&gt;&gt; dishList(@PathVariable(&quot;id&quot;) Long id) &#123; return setmealService.dishList(id);&#125; Impl /** * 用户端根据套餐id查询菜品 * * @param id * @return */ @Override @Transactional public Result&lt;List&lt;DishItemVO&gt;&gt; dishList(Long id) &#123; // 1. 校验参数 if (id == null) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 查询 // 2.1 查询缓存中是否有对应数据 String key = RedisKeyConstant.CACHE_DISH_BY_SETMEALID + id; List&lt;DishItemVO&gt; dishItemVOS = redisUtil.getList(key, DishItemVO.class); if (dishItemVOS != null &amp;&amp; dishItemVOS.size() &gt; 0) &#123; return Result.success(dishItemVOS); &#125; dishItemVOS = setmealDishMapper.selectDishBySetmealId(id); // 2.2 回存缓存 redisUtil.set(key,dishItemVOS); // 3. 返回 return Result.success(dishItemVOS); &#125;"},{"title":"管理端-修改套餐状态","path":"/wiki/xiaomo/后台管理端/管理端-修改套餐状态-34.html","content":"修改套餐状态 接口地址:/admin/setmeal/status/&#123;status&#125; 请求方式:POST 请求数据类型:application/json 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema status 套餐状态 path true integer(int32) id id query false integer(int64) 响应状态: 状态码 说明 schema 200 OK Result«string» 201 Created 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &quot;&quot;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @PostMapping(&quot;/status/&#123;status&#125;&quot;)@ApiOperation(&quot;修改套餐状态&quot;)@ApiImplicitParam( name = &quot;status&quot;, value = &quot;套餐状态&quot;, required = true, dataType = &quot;Integer&quot;, dataTypeClass = Integer.class)public Result&lt;String&gt; updateSetmealStatus(@PathVariable Integer status, Long id) &#123; return setmealService.updateSetmealStatus(status, id);&#125; Impl /** * 修改套餐状态 * * @param status * @param id * @return */@Overridepublic Result&lt;String&gt; updateSetmealStatus(Integer status, Long id) &#123; // 1. 参数校验 if (status == null || id == null || (StatusConstant.ENABLE.equals(status) &amp;&amp; StatusConstant.DISABLE.equals(status))) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 修改状态 update().set(&quot;status&quot;, status).eq(&quot;id&quot;, id).update(); // 2.1 删除套餐缓存 redisUtil.cleanCaches(RedisKeyConstant.DELETE_SETMEAL); // 3. 返回结果 return Result.success();&#125;"},{"title":"管理端-员工登录模块","path":"/wiki/xiaomo/后台管理端/登录模块.html","content":"接口 接口路径： POST/admin/employee/login 请求参数 Headers： 参数名称 参数值 是否必须 示例 备注 Content-Type application/json 是 Body: 名称 类型 是否必须 默认值 备注 其他信息 password string 必须 密码 username string 必须 用户名 返回数据 名称 类型 是否必须 默认值 备注 其他信息 code integer 必须 format: int32 data object 非必须 员工登录返回的数据格式 备注: 员工登录返回的数据格式 id integer 非必须 主键值 format: int64 name string 非必须 姓名 token string 非必须 jwt令牌 userName string 非必须 用户名 msg string 非必须 controller @PostMapping(&quot;/login&quot;) @ApiOperation(value = &quot;登入&quot;) public Result&lt;EmployeeLoginVO&gt; login(@RequestBody EmployeeLoginDTO employeeLoginDTO) &#123; log.info(&quot;员工登录：&#123;&#125;&quot;, employeeLoginDTO); return employeeService.login(employeeLoginDTO); &#125; impl /** * 员工登录 * * @param employeeLoginDTO * @return Result&lt;EmployeeLoginVO&gt; */ @Override public Result&lt;EmployeeLoginVO&gt; login(EmployeeLoginDTO employeeLoginDTO) &#123; // 1. 检查变量是否有效 if (employeeLoginDTO == null || StringUtils.isBlank(employeeLoginDTO.getUsername()) || StringUtils.isBlank(employeeLoginDTO.getPassword())) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 根据用户名查询数据是否存在 LambdaQueryWrapper&lt;Employee&gt; employeeLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); employeeLambdaQueryWrapper.eq(Employee::getUsername, employeeLoginDTO.getUsername()); Employee employee = getOne(employeeLambdaQueryWrapper); // 3. 判断用户数据是否存在 if (employee == null) &#123; throw new AccountNotFoundException(MessageConstant.ACCOUNT_NOT_FOUND); &#125; // 4. 比对密码是否一致 String password = DigestUtils.md5DigestAsHex( (employeeLoginDTO.getPassword() + employee.getSalt()).getBytes()); if (!password.equals(employee.getPassword())) &#123; throw new PasswordErrorException(MessageConstant.PASSWORD_ERROR); &#125; // 5. 判断账号状态 if (employee.getStatus().equals(StatusConstant.DISABLE)) &#123; throw new AccountLockedException(MessageConstant.ACCOUNT_LOCKED); &#125; // 6. 登录成功后，生成jwt令牌 Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(); claims.put(JwtClaimsConstant.EMP_ID, employee.getId()); String token = JwtUtil.createJWT(jwtProperties.getAdminSecretKey(), jwtProperties.getAdminTtl(), claims); EmployeeLoginVO employeeLoginVO = EmployeeLoginVO.builder() .id(employee.getId()) .userName(employee.getUsername()) .name(employee.getName()) .token(token) .build(); return Result.success(employeeLoginVO); &#125;"},{"title":"管理端-分页查询套餐","path":"/wiki/xiaomo/后台管理端/管理端-修改套餐-33.html","content":"修改套餐 接口地址:/admin/setmeal 请求方式:PUT 请求数据类型:application/json 响应数据类型:*/* 接口描述: 请求示例: &#123; &quot;categoryId&quot;: 0, &quot;description&quot;: &quot;&quot;, &quot;id&quot;: 0, &quot;image&quot;: &quot;&quot;, &quot;name&quot;: &quot;&quot;, &quot;price&quot;: 0, &quot;setmealDishes&quot;: [ &#123; &quot;copies&quot;: 0, &quot;dishId&quot;: 0, &quot;id&quot;: 0, &quot;name&quot;: &quot;&quot;, &quot;price&quot;: 0, &quot;setmealId&quot;: 0 &#125; ], &quot;status&quot;: 0&#125; 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema setmealDTO setmealDTO body true 套餐DTO 套餐DTO categoryId 分类id false integer(int64) description 描述信息 false string id 套餐id false integer(int64) image 图片 false string name 套餐名称 false string price 套餐价格 false number setmealDishes 套餐菜品关系 false array 套餐菜品关系 copies 份数 false integer dishId 菜品id false integer id id false integer name 菜品名称 （冗余字段） false string price 菜品原价 false number setmealId 套餐id false integer status 状态 0:停用 1:启用 false integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«string» 201 Created 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &quot;&quot;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @PutMapping()@ApiOperation(&quot;修改套餐&quot;)public Result&lt;String&gt; updateSetmeal(@RequestBody SetmealDTO setmealDTO) &#123; return setmealService.updateSetmeal(setmealDTO);&#125; Impl /** * 修改套餐 * * @param setmealDTO * @return */ @Override @Transactional public Result&lt;String&gt; updateSetmeal(SetmealDTO setmealDTO) &#123; // 1. 参数校验 boolean check = setmealDTO.check(); if (!check) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 修改套餐信息 Setmeal setmeal = new Setmeal(); BeanUtils.copyProperties(setmealDTO, setmeal); updateById(setmeal); // 3. 修改套餐和菜品之间的关系 setmealDishService.removeBySetmealId(setmeal.getId()); setmealDTO.getSetmealDishes().forEach(setmealDish -&gt; setmealDish.setSetmealId(setmeal.getId())); setmealDishService.saveBatch(setmealDTO.getSetmealDishes()); // 3.1 删除有关套餐的缓存 redisUtil.cleanCaches(RedisKeyConstant.DELETE_SETMEAL); // 4. 返回结果 return Result.success(); &#125;"},{"title":"管理端-分页查询套餐","path":"/wiki/xiaomo/后台管理端/管理端-分页查询套餐-31.html","content":"分页查询套餐 接口地址:/admin/setmeal/page 请求方式:GET 请求数据类型:application/x-www-form-urlencoded 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema categoryId 分类id query false integer(int32) name 套餐名称 query false string page 当前页 query false integer(int32) pageSize 每页显示条数 query false integer(int32) status 状态 0表示禁用 1表示启用 query false integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«PageResult» 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data PageResult PageResult records array object total integer(int64) msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &#123; &quot;records&quot;: [], &quot;total&quot;: 0\t&#125;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @GetMapping(&quot;/page&quot;)@ApiOperation(&quot;分页查询套餐&quot;)public Result&lt;PageResult&gt; pageQuery(SetmealPageQueryDTO setmealPageQueryDTO) &#123; return setmealService.pageQuery(setmealPageQueryDTO);&#125; Impl /** * 分页查询套餐 * * @param setmealPageQueryDTO * @return */ @Override @Transactional public Result&lt;PageResult&gt; pageQuery(SetmealPageQueryDTO setmealPageQueryDTO) &#123; // 1. 参数校验 boolean check = setmealPageQueryDTO.check(); if (!check) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 分页查询 Page&lt;Setmeal&gt; setmealPage = new Page&lt;Setmeal&gt;(setmealPageQueryDTO.getPage(), setmealPageQueryDTO.getPageSize()); // 3. 条件查询 LambdaQueryWrapper&lt;Setmeal&gt; setmealLambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;(); if (StringUtils.isNotBlank(setmealPageQueryDTO.getName())) &#123; setmealLambdaQueryWrapper.like(Setmeal::getName, setmealPageQueryDTO.getName()); &#125; if (setmealPageQueryDTO.getCategoryId() != null) &#123; setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId, setmealPageQueryDTO.getCategoryId()); &#125; if (setmealPageQueryDTO.getStatus() != null &amp;&amp; (StatusConstant.ENABLE.equals(setmealPageQueryDTO.getStatus()) || StatusConstant.DISABLE.equals(setmealPageQueryDTO.getStatus()))) &#123; setmealLambdaQueryWrapper.eq(Setmeal::getStatus, setmealPageQueryDTO.getStatus()); &#125; setmealLambdaQueryWrapper.orderByDesc(Setmeal::getUpdateTime); // 4. 执行查询 page(setmealPage, setmealLambdaQueryWrapper); // 5. 返回结果 PageResult pageResult = new PageResult(setmealPage.getTotal(), setmealPage.getRecords()); return Result.success(pageResult); &#125;"},{"title":"管理端-根据类型查询分类","path":"/wiki/xiaomo/后台管理端/管理端-新增套餐-30.html","content":"新增套餐 接口地址:/admin/setmeal 请求方式:POST 请求数据类型:application/json 响应数据类型:*/* 接口描述: 请求示例: &#123; &quot;categoryId&quot;: 0, &quot;description&quot;: &quot;&quot;, &quot;id&quot;: 0, &quot;image&quot;: &quot;&quot;, &quot;name&quot;: &quot;&quot;, &quot;price&quot;: 0, &quot;setmealDishes&quot;: [ &#123; &quot;copies&quot;: 0, &quot;dishId&quot;: 0, &quot;id&quot;: 0, &quot;name&quot;: &quot;&quot;, &quot;price&quot;: 0, &quot;setmealId&quot;: 0 &#125; ], &quot;status&quot;: 0&#125; 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema setmealDTO setmealDTO body true 套餐DTO 套餐DTO categoryId 分类id false integer(int64) description 描述信息 false string id 套餐id false integer(int64) image 图片 false string name 套餐名称 false string price 套餐价格 false number setmealDishes 套餐菜品关系 false array 套餐菜品关系 copies 份数 false integer dishId 菜品id false integer id id false integer name 菜品名称 （冗余字段） false string price 菜品原价 false number setmealId 套餐id false integer status 状态 0:停用 1:启用 false integer(int32) 响应状态: 状态码 说明 schema 200 OK Result«string» 201 Created 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &quot;&quot;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @PostMapping()@ApiOperation(&quot;新增套餐&quot;)public Result&lt;String&gt; addSetmeal(@RequestBody SetmealDTO setmealDTO) &#123; return setmealService.addSetmeal(setmealDTO);&#125; Impl /** * 新增套餐 * * @param setmealDTO * @return */ @Override @Transactional public Result&lt;String&gt; addSetmeal(SetmealDTO setmealDTO) &#123; // 1. 检查参数 boolean check = setmealDTO.check(); if (!check) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; setmealDTO .getSetmealDishes() .forEach( setmealDish -&gt; &#123; boolean check1 = setmealDish.check(); if (!check1) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; &#125;); // 2. 添加套餐信息 Setmeal setmeal = new Setmeal(); BeanUtils.copyProperties(setmealDTO, setmeal); save(setmeal); // 3. 建立套餐和菜品之间的关系 setmealDTO .getSetmealDishes() .forEach( setmealDish -&gt; &#123; setmealDish.setSetmealId(setmeal.getId()); &#125;); // 4. 保存套餐和菜品之间的关系 List&lt;SetmealDish&gt; setmealDishes = setmealDTO.getSetmealDishes(); setmealDishService.saveBatch(setmealDishes); // 4.1 删除redis中套餐相关的缓存 redisUtil.cleanCaches(RedisKeyConstant.DELETE_SETMEAL); // 5. 返回结果 return Result.success(); &#125;"},{"title":"管理端-删除套餐","path":"/wiki/xiaomo/后台管理端/管理端-删除套餐-35.html","content":"删除套餐 接口地址:/admin/setmeal 请求方式:DELETE 请求数据类型:application/x-www-form-urlencoded 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema ids 套餐id数组 query true 响应状态: 状态码 说明 schema 200 OK Result«string» 204 No Content 401 Unauthorized 403 Forbidden 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data string msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &quot;&quot;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @DeleteMapping()@ApiOperation(&quot;删除套餐&quot;)@ApiImplicitParam( name = &quot;ids&quot;, value = &quot;套餐id数组&quot;, required = true, dataType = &quot;Long[]&quot;, dataTypeClass = Long[].class)public Result&lt;String&gt; deleteSetmeal(Long[] ids) &#123; return setmealService.deleteSetmeal(ids);&#125; Impl /** * 删除套餐 * * @param ids * @return */ @Override @Transactional public Result&lt;String&gt; deleteSetmeal(Long[] ids) &#123; // 1. 参数校验 if (ids == null || ids.length == 0) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 在启售中的套餐不能删除 for (Long id : ids) &#123; Setmeal setmeal = getById(id); if (StatusConstant.ENABLE.equals(setmeal.getStatus())) &#123; throw new StatusIsUpExecption(MessageConstant.STATUS_IS_UP); &#125; // 3. 删除套餐和菜品之间的关系 setmealDishService.removeBySetmealId(id); &#125; // 4. 删除套餐 removeByIds(Arrays.asList(ids)); // 4.1 删除套餐缓存 redisUtil.cleanCaches(RedisKeyConstant.DELETE_SETMEAL); // 5. 返回结果 return Result.success(); &#125;"},{"title":"管理端-分页查询套餐","path":"/wiki/xiaomo/后台管理端/管理端-根据id查询套餐-32.html","content":"根据id查询套餐 接口地址:/admin/setmeal/&#123;id&#125; 请求方式:GET 请求数据类型:application/x-www-form-urlencoded 响应数据类型:*/* 接口描述: 请求参数: 请求参数: 参数名称 参数说明 请求类型 是否必须 数据类型 schema id 套餐id path true integer(int64) 响应状态: 状态码 说明 schema 200 OK Result«套餐DTO» 401 Unauthorized 403 Forbidden 404 Not Found 响应参数: 参数名称 参数说明 类型 schema code integer(int32) integer(int32) data 套餐DTO0 套餐DTO0 categoryId 分类id integer(int64) description 描述信息 string id 套餐id integer(int64) image 图片 string name 套餐名称 string price 套餐价格 number setmealDishes 套餐菜品关系 array 套餐菜品关系 copies 份数 integer dishId 菜品id integer id id integer name 菜品名称 （冗余字段） string price 菜品原价 number setmealId 套餐id integer status 状态 0:停用 1:启用 integer(int32) updateTime string(date-time) msg string 响应示例: &#123;\t&quot;code&quot;: 0,\t&quot;data&quot;: &#123; &quot;categoryId&quot;: 0, &quot;description&quot;: &quot;&quot;, &quot;id&quot;: 0, &quot;image&quot;: &quot;&quot;, &quot;name&quot;: &quot;&quot;, &quot;price&quot;: 0, &quot;setmealDishes&quot;: [ &#123; &quot;copies&quot;: 0, &quot;dishId&quot;: 0, &quot;id&quot;: 0, &quot;name&quot;: &quot;&quot;, &quot;price&quot;: 0, &quot;setmealId&quot;: 0 &#125; ], &quot;status&quot;: 0, &quot;updateTime&quot;: &quot;&quot;\t&#125;,\t&quot;msg&quot;: &quot;&quot;&#125; controller @GetMapping(&quot;/&#123;id&#125;&quot;)@ApiOperation(&quot;根据id查询套餐&quot;)@ApiImplicitParam( name = &quot;id&quot;, value = &quot;套餐id&quot;, required = true, dataType = &quot;Long&quot;, dataTypeClass = Long.class)public Result&lt;SetmealVO&gt; getSetmealById(@PathVariable Long id) &#123; return setmealService.getSetmealById(id);&#125; Impl /** * 根据id查询套餐 * * @param id * @return */ @Override @Transactional public Result&lt;SetmealVO&gt; getSetmealById(Long id) &#123; // 1. 参数校验 if (id == null) &#123; throw new NullDataException(MessageConstant.NULL_DATA); &#125; // 2. 根据id查询套餐信息 // 2.1 查询redis缓存中是否包含对应数据 String key = RedisKeyConstant.CACHE_SETMEAL_BY_ID + id; SetmealVO setmealVO = redisUtil.get(key, SetmealVO.class); if (setmealVO != null) &#123; return Result.success(setmealVO); &#125; Setmeal setmeal = getById(id); // 3. 根据id查询关联菜品信息 List&lt;SetmealDish&gt; setmealDishes = setmealDishService.list( Wrappers.&lt;SetmealDish&gt;lambdaQuery().eq(SetmealDish::getSetmealId, id)); // 4. 补全信息 setmealVO = new SetmealVO(); BeanUtils.copyProperties(setmeal, setmealVO); setmealVO.setSetmealDishes(setmealDishes); // 4.1 回存缓存 redisUtil.set(key, setmealVO); // 5. 返回结果 return Result.success(setmealVO); &#125;"}]